
use data::Iterator::{Iterator, Collect};
use ops::{Cast, Concat, comparison::{Eq, Ord}};

/// A Unicode string, represented as a list of characters.
/// ```vi
/// let string = "12 + 34 = {12 + 34}";
/// string // "12 + 34 = 46"
/// ```
#[builtin = "String"]
pub struct* String(pub List[Char]);

pub mod String {
  /// The length (number of characters) of the string.
  pub fn .len(&String(List(len, _, _))) -> N32 {
    len
  }

  pub fn .split(self: String, sep: String) -> List[String] {
    let list = [];
    loop {
      let (found, remaining) = self.split_once(sep);
      list ++= [found];
      if remaining is Some(remaining) {
        self = remaining;
        continue;
      } else {
        list
      }
    }
  }

  pub fn .split_trim(self: String, sep: String) -> List[String] {
    let list = [];
    let start = true;
    let ~end = true;
    loop {
      let (found, remaining) = self.split_once(sep);
      let empty = found.len() == 0;
      start = empty and start;
      if !start and !~end {
        list ++= [found];
      }
      ~end ~= empty and ~end;
      if remaining is Some(remaining) {
        self = remaining;
        continue;
      } else {
        list
      }
    }
  }

  pub fn .split_once(self: String, sep: String) -> (String, Option[String]) {
    let prefix = "";
    let suffix = self;
    while suffix.len() >= sep.len() {
      let iter_ref = suffix.iter_ref();
      for &a in &sep {
        let (&b, _iter) = iter_ref.advance().assume();
        iter_ref = _iter;
        if a != b {
          break;
        }
      } else {
        return (prefix, Some(String(safe move(iter_ref.tail()))));
      }
      if suffix!.pop_front() is Some(char) {
        prefix ++= String([char]);
      } else {
        break;
      }
    }
    (prefix ++ suffix, None())
  }

  pub fn .strip_prefix(self: String, &prefix: &String) -> Result[String, String] {
    if self.len() < prefix.len() {
      return Err(prefix);
    }
    let iter_ref = self.iter_ref();
    for &a in &prefix {
      let (&b, _iter) = iter_ref.advance().assume();
      iter_ref = _iter;
      if a != b {
        return Err(self);
      }
    }
    Ok(String(safe move(iter_ref.tail())))
  }

  pub fn .trim_front(String(chars)) -> String {
    chars.drop_while(fn* (&c: &Char) { c.is_whitespace() });
    String(chars)
  }

  pub fn .trim_back(String(chars)) -> String {
    chars.trim_back_where(fn* (&c: &Char) { c.is_whitespace() });
    String(chars)
  }

  pub fn .trim(self: String) -> String {
    self.trim_front().trim_back()
  }

  pub fn .starts_with(&self: &String, &prefix: &String) -> Bool {
    if self.len() < prefix.len() {
      return false;
    }
    for (&a, &b) in self.iter_ref().zip(prefix.iter_ref()) {
      if a != b {
        return false;
      }
    }
    true
  }

  pub fn .ends_with(&self: &String, &suffix: &String) -> Bool {
    if self.len() < suffix.len() {
      return false;
    }
    let skip = self.len() - suffix.len();
    for (&a, &b) in self.iter_ref().skip(skip).zip(suffix.iter_ref()) {
      if a != b {
        return false;
      }
    }
    true
  }

  pub fn .split_at(String(chars), i: N32) -> (String, String) {
    let (prefix, suffix) = chars.split_at(i);
    (String(prefix), String(suffix))
  }

  pub impl : Eq[String] {
    fn eq(&self: &String, &other: &String) -> Bool {
      self! == other!
    }

    fn ne(&self: &String, &other: &String) -> Bool {
      self! != other!
    }
  }

  pub impl : Ord[String] {
    fn cmp(&a: &String, &b: &String) -> Ord {
      a!.cmp(&b!)
    }

    fn lt(a: &String, b: &String) -> Bool {
      Ord::lt_from_cmp(a, b)
    }

    fn le(a: &String, b: &String) -> Bool {
      Ord::le_from_cmp(a, b)
    }
  }

  pub impl : Concat[String, String, String] {
    fn concat(String(a), String(b)) -> String {
      String(a ++ b)
    }
  }

  pub fn .repeat(self: String, count: N32) -> String {
    let out = "";
    for _ in 0..count {
      out ++= self;
    }
    out
  }

  pub impl from_chars: Cast[List[Char], String] {
    fn cast(chars: List[Char]) -> String {
      String(chars)
    }
  }

  pub impl to_chars: Cast[String, List[Char]] {
    fn cast(String(chars)) -> List[Char] {
      chars
    }
  }

  pub impl iter_ref: Cast[&String, List::IterRef[Char]] {
    fn cast(&String(chars)) -> List::IterRef[Char] {
      chars.iter_ref()
    }
  }

  pub impl iter: Cast[String, List::Iter[Char]] {
    fn cast(String(chars)) -> List::Iter[Char] {
      chars.iter()
    }
  }

  /// Collect an iterator of `Char` into a `String`.
  /// ```vi
  /// (48..91).map(fn* (n: N32) { n as Char }).collect[String, _, _]()
  /// // "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  /// ```
  pub impl : Collect[String, Char] {
    fn collect[I; Iterator[I, Char]](iter: I) -> String {
      String(iter.collect[List[Char], _, _]())
    }
  }

  pub impl : Show[String] {
    fn show(&self: &String) -> Show {
      let escaped = "";
      for char in self {
        escaped ++= when {
          char == '"' { "\\\"" }
          char == '{' { "\\\{" }
          _ { char.escape() }
        };
      }
      Show::Literal("\"{escaped}\"")
    }
  }
}
