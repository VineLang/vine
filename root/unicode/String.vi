
use ops::{Cast, Concat, comparison::{Eq, Ord}};

/// A Unicode string, represented as a list of characters.
/// ```vi
/// let string = "12 + 34 = {12 + 34}";
/// string // "12 + 34 = 46"
/// ```
#[builtin = "String"]
pub struct* String(pub List[Char]);

pub mod String {
  /// The length (number of characters) of the string.
  pub fn .len(&String(List(len, _, _))) -> N32 {
    len
  }

  pub fn .split(self: String, sep: String) -> List[String] {
    let list = [];
    loop {
      let (found, remaining) = self.split_once(sep);
      list ++= [found];
      if remaining is Some(remaining) {
        self = remaining;
        continue;
      } else {
        list
      }
    }
  }

  pub fn .split_trim(self: String, sep: String) -> List[String] {
    let list = [];
    let start = true;
    let ~end = true;
    loop {
      let (found, remaining) = self.split_once(sep);
      let empty = found.len() == 0;
      start = empty and start;
      if !start and !~end {
        list ++= [found];
      }
      ~end ~= empty and ~end;
      if remaining is Some(remaining) {
        self = remaining;
        continue;
      } else {
        list
      }
    }
  }

  pub fn .split_once(self: String, sep: String) -> (String, Option[String]) {
    let prefix = "";
    let suffix = self;
    while suffix.len() >= sep.len() {
      let iter_ref = suffix.iter_ref();
      for &a in sep.iter_ref() {
        let (&b, _iter) = iter_ref.advance().assume();
        iter_ref = _iter;
        if a != b {
          break;
        }
      } else {
        return (prefix, Some(String(unsafe::move(iter_ref.tail()))));
      }
      if suffix!.pop_front() is Some(char) {
        prefix ++= String([char]);
      } else {
        break;
      }
    }
    (prefix ++ suffix, None())
  }

  pub fn .strip_prefix(self: String, &prefix: &String) -> Result[String, String] {
    if self.len() < prefix.len() {
      return Err(prefix);
    }
    let iter_ref = self.iter_ref();
    for &a in prefix.iter_ref() {
      let (&b, _iter) = iter_ref.advance().assume();
      iter_ref = _iter;
      if a != b {
        return Err(self);
      }
    }
    Ok(String(unsafe::move(iter_ref.tail())))
  }

  pub fn .trim_front(String(chars)) -> String {
    chars.drop_while(fn* (&c: &Char) { c.is_whitespace() });
    String(chars)
  }

  pub fn .trim_back(String(chars)) -> String {
    chars.trim_back_where(fn* (&c: &Char) { c.is_whitespace() });
    String(chars)
  }

  pub fn .trim(self: String) -> String {
    self.trim_front().trim_back()
  }

  pub fn .starts_with(&self: &String, &prefix: &String) -> Bool {
    if self.len() < prefix.len() {
      return false;
    }
    let self_iter = self.iter_ref();
    for &a in prefix.iter_ref() {
      let (&b, _self_iter) = self_iter.advance().assume();
      self_iter = _self_iter;
      if a != b {
        break false;
      }
    } else {
      true
    }
  }

  pub fn .split_at(String(chars), i: N32) -> (String, String) {
    let (prefix, suffix) = chars.split_at(i);
    (String(prefix), String(suffix))
  }

  pub impl eq: Eq[String] {
    fn eq(&self: &String, &other: &String) -> Bool {
      self! == other!
    }

    fn ne(&self: &String, &other: &String) -> Bool {
      self! != other!
    }
  }

  pub impl ord: Ord[String] {
    fn cmp(&a: &String, &b: &String) -> Ord {
      a!.cmp(&b!)
    }

    fn lt(a: &String, b: &String) -> Bool {
      Ord::lt_from_cmp(a, b)
    }

    fn le(a: &String, b: &String) -> Bool {
      Ord::le_from_cmp(a, b)
    }
  }

  pub impl concat: Concat[String, String, String] {
    fn concat(String(a), String(b)) -> String {
      String(a ++ b)
    }
  }

  pub fn .repeat(self: String, count: N32) -> String {
    let out = "";
    for _ in 0..count {
      out ++= self;
    }
    out
  }

  pub impl from_chars: Cast[List[Char], String] {
    fn cast(chars: List[Char]) -> String {
      String(chars)
    }
  }

  pub impl to_chars: Cast[String, List[Char]] {
    fn cast(String(chars)) -> List[Char] {
      chars
    }
  }

  pub fn .iter_ref(&String(chars)) -> List::IterRef[Char] {
    chars.iter_ref()
  }

  pub fn .iter(String(chars)) -> List::Iter[Char] {
    chars.iter()
  }

  pub impl show: Show[String] {
    fn show(&self: &String) -> Show {
      Show::Literal("\"{self}\"")
    }
  }
}
