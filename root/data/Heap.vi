
use logical::Nullable;
use ops::{Cast, Concat, comparison::Ord};
use util::{duplicate, erase};
use data::Iterator::{Iterator, Iterate};

/// A min-heap, which provides efficient access to the smallest value in the heap.
pub struct Heap[T]((N32, Nullable[Node[T]]));

type Node[T] = (T, Heap[T], Heap[T]);

pub mod Heap[T; Ord[T]] {
  pub impl [T]: Default[Heap[T]] {
    const default: Heap[T] = Heap::empty;
  }

  /// The empty heap.
  /// ```vi
  /// Heap::empty // Heap([])
  /// ```
  pub const empty[T]: Heap[T] = Heap(0, safe Nullable::null());

  /// Create a heap containing a single element.
  /// ```vi
  /// Heap::single(46) // Heap([46])
  /// ```
  pub fn single[T](value: T) -> Heap[T] {
    Heap(1, safe Nullable::data(value, Heap::empty, Heap::empty))
  }

  /// Insert a value into the heap. `O(log n)`
  /// ```vi
  /// let heap = Heap::empty;
  /// heap.insert(3);
  /// heap.insert(1);
  /// heap.insert(2);
  /// heap as List // [1, 2, 3]
  /// ```
  pub fn .insert[...](&self: &Heap[T], value: T) {
    self ++= Heap::single(value);
  }

  /// Remove the smallest value from the heap. `O(log n)`
  pub fn .pop[...](&Heap[T](rank, node)) -> Option[T] {
    if rank == 0 {
      None()
    } else {
      let (value, left, right) = safe node.data;
      Heap(rank, node) = left ++ right;
      Some(value)
    }
  }

  /// Peek at the smallest value in the heap. `O(1)`
  pub fn .peek[...](&Heap[T](rank, node)) -> Option[&T] {
    if rank == 0 {
      None()
    } else {
      let &(value, _, _) = safe &node.data;
      Some(&value)
    }
  }

  pub fn .is_empty[T](&Heap[T](rank, _)) -> Bool {
    rank == 0
  }

  fn .rank[T](&Heap[T](rank, _)) -> N32 {
    rank
  }

  fn .value[T](&Heap[T](_, safe Nullable::data(value, _, _))) -> &T {
    &value
  }

  /// Count the number of elements in the heap. `O(n)`
  pub fn .count[T](&Heap[T](rank, node)) -> N32 {
    if rank == 0 {
      0
    } else {
      let &(_, left, right) = safe &node.data;
      1 + Heap::count(&left) + Heap::count(&right)
    }
  }

  /// Merge two heaps. `O(log n)`
  /// ```vi
  /// let a = [5, 3, 1] as Heap;
  /// let b = [0, 4, 2] as Heap;
  /// let merged = a ++ b;
  /// merged as List // [0, 1, 2, 3, 4, 5]
  /// ```
  pub impl [...]: Concat[Heap[T], Heap[T], Heap[T]] {
    fn concat(self: Heap[T], other: Heap[T]) -> Heap[T] {
      if self.rank() == 0 {
        Heap(_, safe Nullable::null()) = self;
        return other;
      }
      if other.rank() == 0 {
        Heap(_, safe Nullable::null()) = other;
        return self;
      }
      if self.value() > other.value() {
        swap(&self, &other);
      }
      let &Heap(rank, safe Nullable::data(_, left, right)) = &self;
      right ++= other;
      if right.rank() > left.rank() {
        swap(&left, &right);
      }
      rank = right.rank() + 1;
      self
    }
  }

  #[safe become(duplicate)]
  pub impl [T+]: Fork[Heap[T]] {
    fn fork(&Heap[T](rank, node)) -> Heap[T] {
      if rank == 0 {
        Heap::empty
      } else {
        let &(value, left, right) = safe &node.data;
        Heap(rank, safe Nullable::data(value, left, right))
      }
    }
  }

  #[safe become(erase)]
  pub impl [T?]: Drop[Heap[T]] {
    fn drop(Heap[T](rank, node)) {
      if rank == 0 {
        safe node.null;
      } else {
        safe node.data;
      }
    }
  }

  /// Build a heap out of the elements of a list.
  /// ```vi
  /// let heap = [3, 1, 2] as Heap;
  /// heap.pop() // Some(1)
  /// heap.pop() // Some(2)
  /// heap.pop() // Some(3)
  /// heap.pop() // None
  /// ```
  pub impl from_list[...]: Cast[List[T], Heap[T]] {
    fn cast(list: List[T]) -> Heap[T] {
      let heap = Heap::empty;
      for value in list {
        heap.insert(value);
      }
      heap
    }
  }

  /// Convert a heap to a list in ascending order.
  /// ```vi
  /// let heap = Heap::empty;
  /// heap.insert(5);
  /// heap.insert(3);
  /// heap.insert(2);
  /// heap.insert(4);
  /// heap.insert(1);
  /// heap as List // [1, 2, 3, 4, 5]
  /// ```
  pub impl to_list[...]: Cast[Heap[T], List[T]] {
    fn cast(self: Heap[T]) -> List[T] {
      let list = [];
      while self.pop() is Some(value) {
        list.push_back(value);
      }
      Heap(_, safe Nullable::null()) = self;
      list
    }
  }

  pub struct* Iter[T](Heap[T]);

  /// Iterate over the elements of the heap in ascending order.
  /// ```vi
  /// let heap = [3, 1, 2];
  /// for value in heap {
  ///   io.println("{value}");
  /// }
  /// ```
  /// ```
  /// 1
  /// 2
  /// 3
  /// ```
  pub impl iter[...]: Iterate[Heap[T], Iter[T], T] {
    fn iter(self: Heap[T]) -> Iter[T] {
      Iter(self)
    }
  }

  pub mod Iter[...] {
    pub impl [...]: Iterator[Iter[T], T] {
      fn advance(Iter[T](heap)) -> Option[(T, Iter[T])] {
        if heap.pop() is Some(value) {
          Some(value, Iter(heap))
        } else {
          Heap(_, safe Nullable::null()) = heap;
          None()
        }
      }
    }
  }

  /// Display the heap. The first displayed value is the minimum value, but all
  /// other values are displayed in an arbitrary order.
  /// ```vi
  /// let heap = [5, 2, 1, 3, 4] as Heap
  /// "{heap.show()}" // Heap([1, 2, 5, 3, 4])
  /// ```
  pub impl [T; Show[T]]: Show[Heap[T]] {
    fn show(&self: &Heap[T]) -> Show {
      Show::Constructor("Heap", Show::List(self._show()))
    }
  }

  fn ._show[T; Show[T]](&Heap[T](rank, node)) -> List[Show] {
    if rank == 0 {
      []
    } else {
      let &(value, left, right) = safe &node.data;
      [value.show()] ++ left._show() ++ right._show()
    }
  }
}
