
use ops::{Cast, comparison::Ord};
use derive::Tuple;
use util::transmute;

pub trait[I] Iterator[T] {
  #[builtin = "advance"]
  fn .advance(iter: I) -> Option[(T, I)];
}

pub mod Iterator[I, T; Iterator[I, T]] {
  pub const empty[T]: Empty[T] = Empty();

  pub struct Empty[T](());

  pub mod Empty {
    pub impl [T]: Fork[Empty[T]];
    pub impl [T]: Drop[Empty[T]];

    pub impl [T]: Iterator[Empty[T], T] {
      fn advance(Empty[T]()) -> Option[(T, Empty[T])] {
        None()
      }
    }
  }

  pub fn one[T](value: T) -> One[T] {
    One(Some(value))
  }

  pub struct* One[T](Option[T]);

  pub mod One {
    pub impl [T]: Iterator[One[T], T] {
      fn advance(One[T](value)) -> Option[(T, One[T])] {
        Option::map(value, fn? (value) { (value, One(None())) })
      }
    }
  }

  pub fn from_next[T, F*; fn F() -> Option[T]](f: F) -> FromNext[F] {
    FromNext(f)
  }

  pub struct* FromNext[F](F);

  pub mod FromNext {
    pub impl [T, F*; fn F() -> Option[T]]: Iterator[FromNext[F], T] {
      fn advance(FromNext[F](f)) -> Option[(T, FromNext[F])] {
        if f() is Some(value) {
          Some(value, FromNext(f))
        } else {
          None()
        }
      }
    }
  }

  pub fn .map[... U, F*; fn F(T) -> U](iter: I, f: F) -> Map[I, F] {
    Map(iter, f)
  }

  pub struct* Map[I, F]((I, F));

  pub mod Map[...] {
    pub impl [... U, F*; fn F(T) -> U]: Iterator[Map[I, F], U] {
      fn advance(Map[I, F](iter, f)) -> Option[(U, Map[I, F])] {
        match iter.advance() {
          Some(value, iter) { Some(f(value), iter.map(f)) }
          None() { None() }
        }
      }
    }
  }

  pub fn .filter[... F*; fn F(&T) -> Bool](iter: I, f: F) -> Filter[I, F] {
    Filter(iter, f)
  }

  pub struct* Filter[I, F]((I, F));

  pub mod Filter[...] {
    pub impl [... T?, F*; fn F(&T) -> Bool]: Iterator[Filter[I, F], T] {
      fn advance(Filter[I, F](iter, f)) -> Option[(T, Filter[I, F])] {
        loop {
          match iter.advance() {
            Some(value, _iter) {
              iter = _iter;
              if f(&value) {
                Some(value, Filter(iter, f))
              } else {
                continue;
              }
            }
            None() { None() }
          }
        }
      }
    }
  }

  pub fn .filter_map[... U, F*; fn F(T) -> Option[U]](iter: I, f: F) -> FilterMap[I, F] {
    FilterMap(iter, f)
  }

  pub struct* FilterMap[I, F]((I, F));

  pub mod FilterMap[...] {
    pub impl [... U, F*; fn F(T) -> Option[U]]: Iterator[FilterMap[I, F], U] {
      fn advance(FilterMap[I, F](iter, f)) -> Option[(U, FilterMap[I, F])] {
        loop {
          match iter.advance() {
            Some(value, _iter) {
              iter = _iter;
              if f(value) is Some(value) {
                Some(value, FilterMap(iter, f))
              } else {
                continue;
              }
            }
            None() { None() }
          }
        }
      }
    }
  }

  pub fn .skip[... T?](iter: I, count: N32) -> Skip[I] {
    Skip(iter, count)
  }

  pub struct* Skip[I]((I, N32));

  pub mod Skip[...] {
    pub impl [... T?]: Iterator[Skip[I], T] {
      fn advance(Skip[I](iter, count)) -> Option[(T, Skip[I])] {
        while count != 0 {
          count -= 1;
          if iter.advance() is Some(_, _iter) {
            iter = _iter;
          } else {
            return None();
          }
        }
        Option::map(iter.advance(), fn? ((value, iter)) { (value, Skip(iter, 0)) })
      }
    }
  }

  pub fn .skip_while[... T?, F*; fn F(&T) -> Bool](iter: I, f: F) -> SkipWhile[I, F] {
    SkipWhile(iter, Some(f))
  }

  pub struct* SkipWhile[I, F]((I, Option[F]));

  pub mod SkipWhile[...] {
    pub impl [... T?, F*; fn F(&T) -> Bool]: Iterator[SkipWhile[I, F], T] {
      fn advance(SkipWhile[I, F](iter, f)) -> Option[(T, SkipWhile[I, F])] {
        if f is Some(f) {
          while iter.advance() is Some(value, _iter) {
            iter = _iter;
            if !f(&value) {
              break Some(value, SkipWhile(iter, None()));
            }
          } else {
            None()
          }
        } else {
          Option::map(iter.advance(), fn? ((value, iter)) { (value, SkipWhile(iter, None())) })
        }
      }
    }
  }

  /// Returns an iterator of `List[T]`s, each with length `size`.
  /// The last value returned by this iterator may have length less than `size`,
  /// if the number of elements in `iter` is not evenly divisible by `size`.
  ///
  /// If `size` is 0, lists of length 1 are returned in the iterator.
  pub fn .chunks[... I](iter: I, size: N32) -> Chunks[I] {
    Chunks(Some(iter), size)
  }

  pub struct* Chunks[I](Option[I], N32);

  pub mod Chunks[I] {
    pub impl [... T; Iterator[I, T]]: Iterator[Chunks[I], List[T]] {
      fn advance(Chunks[I](iter, size)) -> Option[(List[T], Chunks[I])] {
        assert iter is Some(iter) else { None() }
        assert iter.advance() is Some((value, iter)) else { None() }

        let chunk = [value];

        loop {
          if chunk.len() >= size {
            return Some(chunk, Chunks(Some(iter), size));
          }

          match iter.advance() {
            Some((value, rest)) {
              chunk.push_back(value);
              iter = rest;
              continue;
            }
            None() {
              return Some(chunk, Chunks(None(), size));
            }
          }
        }
      }
    }
  }

  pub fn .take[... I?](iter: I, count: N32) -> Take[I] {
    Take(iter, count)
  }

  pub struct* Take[I]((I, N32));

  pub mod Take[...] {
    pub impl [... I?]: Iterator[Take[I], T] {
      fn advance(Take[I](iter, count)) -> Option[(T, Take[I])] {
        if count != 0 and iter.advance() is Some(value, iter) {
          Some(value, Take(iter, count - 1))
        } else {
          None()
        }
      }
    }
  }

  pub fn .take_while[... I?, F*; fn F(&T) -> Bool](iter: I, f: F) -> TakeWhile[I, F] {
    TakeWhile(iter, f)
  }

  pub struct* TakeWhile[I, F]((I, F));

  pub mod TakeWhile[...] {
    pub impl [... I?, T?, F*; fn F(&T) -> Bool]: Iterator[TakeWhile[I, F], T] {
      fn advance(TakeWhile[I, F](iter, f)) -> Option[(T, TakeWhile[I, F])] {
        if iter.advance() is Some(value, iter) and f(&value) {
          Some(value, TakeWhile(iter, f))
        } else {
          None()
        }
      }
    }
  }

  pub fn .map_while[... I?, U, F*; fn F(T) -> Option[U]](iter: I, f: F) -> MapWhile[I, F] {
    MapWhile(iter, f)
  }

  pub struct* MapWhile[I, F]((I, F));

  pub mod MapWhile[...] {
    pub impl [... I?, U, F*; fn F(T) -> Option[U]]: Iterator[MapWhile[I, F], U] {
      fn advance(MapWhile[I, F](iter, f)) -> Option[(U, MapWhile[I, F])] {
        if iter.advance() is Some(value, iter) and f(value) is Some(value) {
          Some(value, MapWhile(iter, f))
        } else {
          None()
        }
      }
    }
  }

  pub fn .zip[... I?, T?, J?, U; Iterator[J, U]](i: I, j: J) -> Zip[(I, J)] {
    Zip(i, j)
  }

  pub struct* Zip[Is](Is);

  pub mod Zip[Is] {
    pub impl iter_singleton[I, T; Iterator[I, T]]: Iterator[Zip[(I,)], (T,)] {
      fn advance(Zip[(I,)]((iter,))) -> Option[((T,), Zip[(I,)])] {
        safe transmute[Option[(T, I)], Option[((T,), Zip[(I,)])]](iter.advance())
      }
    }

    pub impl iter_tuple[
      IS, I, IR, TS, T, TR;
      Tuple[IS, I, IR],
      Iterator[I, T],
      Iterator[Zip[IR], TR],
      Tuple[TS, T, TR],
      Drop[I],
      Drop[IR],
      Drop[T];
    ]: Iterator[Zip[IS], TS] {
      fn advance(Zip[IS](iters)) -> Option[(TS, Zip[IS])] {
        let (i, ir) = iters as (I, IR);
        if i.advance() is Some(t, i) and Zip(ir).advance() is Some(tr, Zip(ir)) {
          Some((t, tr) as TS, Zip((i, ir) as IS))
        } else {
          None()
        }
      }
    }
  }

  pub fn .flatten[I, J, T; Iterator[I, J], Iterator[J, T]](iter: I) -> Flatten[I, J] {
    Flatten(None(), iter)
  }

  pub struct* Flatten[I, J]((Option[J], I));

  pub mod Flatten {
    pub impl [I, J, T; Iterator[I, J], Iterator[J, T]]: Iterator[Flatten[I, J], T] {
      fn advance(Flatten[I, J](j, i)) -> Option[(T, Flatten[I, J])] {
        if j is Some(j) and j.advance() is Some(t, j) {
          Some(t, Flatten(Some(j), i))
        } else {
          while i.advance() is Some(j, _i) {
            i = _i;
            if j.advance() is Some(t, j) {
              break Some(t, Flatten(Some(j), i));
            }
          } else {
            None()
          }
        }
      }
    }
  }

  pub fn .flat_map[... J, U, F*; fn F(T) -> J, Iterator[J, T]](iter: I, f: F) -> Flatten[
    Map[I, F], J;
  ] {
    iter.map(f).flatten()
  }

  pub impl concat[... J; Iterator[J, T]]: ops::Concat[I, J, Concat[I, J]] {
    fn concat(i: I, j: J) -> Concat[I, J] {
      Concat(Some(i), j)
    }
  }

  pub struct* Concat[I, J]((Option[I], J));

  pub mod Concat[...] {
    pub impl [... J; Iterator[J, T]]: Iterator[Concat[I, J], T] {
      fn advance(Concat[I, J](i, j)) -> Option[(T, Concat[I, J])] {
        when {
          i is Some(i) and i.advance() is Some(value, i) { Some(value, Concat(Some(i), j)) }
          j.advance() is Some(value, j) { Some(value, Concat(None(), j)) }
          _ { None() }
        }
      }
    }
  }

  pub fn .enumerate[...](iter: I) -> Map[I, Enumerate] {
    iter.map(Enumerate(&0))
  }

  pub struct* Enumerate(&N32);

  pub mod Enumerate {
    pub impl [T]: fn Enumerate(T) -> (N32, T) {
      fn call(Enumerate(&index), (value: T,)) -> (N32, T) {
        let result = (index, value);
        index += 1;
        result
      }
    }
  }

  pub trait[] Window[W, T] {
    fn start[I; Iterator[I, T]](iter: I) -> Option[(W, I)];
    fn .shift(window: &W, value: T) -> T;
  }

  pub mod Window {
    pub impl nil[T]: Window[(), T] {
      fn start[I; Iterator[I, T]](iter: I) -> Option[((), I)] {
        Some((), iter)
      }
      fn shift(&(), value: T) -> T {
        value
      }
    }

    pub impl tuple[T?, W, R; Tuple[W, T, R], Window[R, T]]: Window[W, T] {
      fn start[I; Iterator[I, T]](iter: I) -> Option[(W, I)] {
        if iter.advance() is Some(init, iter) and Window::start[R, T, I](iter) is Some(rest, iter) {
          Some((init, rest) as W, iter)
        } else {
          None()
        }
      }

      fn shift(&window: &W, value: T) -> T {
        let &(init, rest) = &window as &(T, R);
        let value = rest.shift(value);
        replace(&init, value)
      }
    }
  }

  pub struct* Windows[I, R](Option[R], I);

  pub fn .windows[I, T, R; Iterator[I, T]](iter: I) -> Windows[I, R] {
    Windows(None(), iter)
  }

  pub mod Windows {
    pub impl iter[I, T, W, R; Iterator[I, T], Tuple[W, T, R], Window[R, T], Fork[R], Drop[R]]: Iterator[
      Windows[I, R], W;
    ] {
      fn advance(Windows[I, R](rest, iter)) -> Option[(W, Windows[I, R])] {
        let (rest, iter) = when {
          rest is Some(rest) { (rest, iter) }
          Window::start[R, T, I](iter) is Some(rest, iter) { (rest, iter) }
          _ {
            return None();
          }
        };
        if iter.advance() is Some(value, iter) {
          let init = rest.shift(value);
          Some((init, rest) as W, Windows(Some(rest), iter))
        } else {
          None()
        }
      }
    }
  }

  pub fn .inspect[... F*; fn F(&T)](iter: I, f: F) -> Map[I, Inspect[F]] {
    iter.map(Inspect(f))
  }

  pub struct* Inspect[F](F);

  pub mod Inspect {
    pub impl [T, F*; fn F(&T)]: fn Inspect[F](T) -> T {
      fn call(Inspect[F](f), (value: T,)) -> T {
        f(&value);
        value
      }
    }
  }

  pub fn .forked[I, T; Iterator[I, &T], Fork[T]](iter: I) -> Map[I, fn Fork::fork] {
    iter.map(Fork::fork)
  }

  pub fn .count[... T?](iter: I) -> N32 {
    let len = 0;
    for _ in iter {
      len += 1;
    }
    len
  }

  pub fn .find[... I?, T?, F*; fn F(&T) -> Bool](iter: I, f: F) -> Option[T] {
    for value in iter {
      if f(&value) {
        break Some(value);
      }
    } else {
      None()
    }
  }

  pub fn .find_map[... I?, U, F*; fn F(T) -> Option[U]](iter: I, f: F) -> Option[U] {
    for value in iter {
      if f(value) is Some(value) {
        break Some(value);
      }
    } else {
      None()
    }
  }

  pub fn .for_each[... F*; fn F(T)](iter: I, f: F) {
    for value in iter {
      f(value);
    }
  }

  pub fn .fold[... U, F*; fn F(U, T) -> U](iter: I, init: U, f: F) -> U {
    let current = init;
    for value in iter {
      current = f(current, value);
    }
    current
  }

  pub fn .reduce[... F*; fn F(T, T) -> T](iter: I, f: F) -> Option[T] {
    match iter.advance() {
      Some(value, iter) { Some(iter.fold(value, f)) }
      None() { None() }
    }
  }

  pub fn .all[... I?, F*; fn F(T) -> Bool](iter: I, f: F) -> Bool {
    for value in iter {
      if !f(value) {
        break false;
      }
    } else {
      true
    }
  }

  pub fn .any[... I?, F*; fn F(T) -> Bool](iter: I, f: F) -> Bool {
    for value in iter {
      if f(value) {
        break true;
      }
    } else {
      false
    }
  }

  pub fn .nth[... I?, T?](iter: I, index: N32) -> Option[T] {
    for value in iter {
      if index == 0 {
        break Some(value);
      } else {
        index -= 1;
      }
    } else {
      None()
    }
  }

  pub fn .last[... I?, T?](iter: I) -> Option[T] {
    if iter.advance() is Some(current, iter) {
      for value in iter {
        current = value;
      }
      Some(current)
    } else {
      None()
    }
  }

  pub fn .max[... T?; Ord[T]](iter: I) -> Option[T] {
    if iter.advance() is Some(max, iter) {
      for value in iter {
        if value > max {
          max = value;
        }
      }
      Some(max)
    } else {
      None()
    }
  }

  pub fn .min[... T?; Ord[T]](iter: I) -> Option[T] {
    if iter.advance() is Some(min, iter) {
      for value in iter {
        if value < min {
          min = value;
        }
      }
      Some(min)
    } else {
      None()
    }
  }

  pub use Collect::collect as _;
}

pub trait[C] Collect[T] {
  fn .collect[I; Iterator[I, T]](iter: I) -> C;
}

pub struct* Fused[I](pub Option[I]);

pub mod Fused {
  pub fn new[I](iter: I) -> Fused[I] {
    Fused(Some(iter))
  }

  pub fn .next[I, T; Iterator[I, T]](&Fused[I](inner)) -> Option[T] {
    if inner is Some(iter) and iter.advance() is Some(value, iter) {
      inner = Some(iter);
      Some(value)
    } else {
      inner = None();
      None()
    }
  }
}

pub trait[C] Iterate[I, T] {
  #[builtin = "iter"]
  fn .iter(c: C) -> I;
}

pub mod Iterate {
  pub impl iterate[C, I, T; Cast[C, I], Iterator[I, T]]: Iterate[C, I, T] {
    fn iter(collection: C) -> I {
      collection as I
    }
  }

  pub fn .iter_ref[C, I, T; Iterate[&C, I, T]](&collection: &C) -> I {
    iter(&collection)
  }

  pub impl iterate_singleton[C, I, T; Iterate[C, I, T]]: Iterate[(C,), Zip[(I,)], (T,)] {
    fn iter((c: C,)) -> Zip[(I,)] {
      Zip((c.iter(),))
    }
  }

  pub impl iterate_tuple[
    Cs, C, Cr, Is, I, Ir, Ts, T, Tr;
    Tuple[Cs, C, Cr],
    Iterate[C, I, T],
    Iterate[Cr, Zip[Ir], Tr],
    Tuple[Is, I, Ir],
    Tuple[Ts, T, Tr];
  ]: Iterate[Cs, Zip[Is], Ts] {
    fn iter(cs: Cs) -> Zip[Is] {
      let (c, cr) = cs as (C, Cr);
      Zip((c.iter(), cr.iter()!) as Is)
    }
  }
}
