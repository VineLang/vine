
use #root::ops::Cast;

pub trait Iterator[Self, Item] {
  #[builtin = "advance"]
  fn .advance(self: Self) -> Option[(Item, Self)];
}

pub mod Iterator[I, T; Iterator[I, T]] {
  pub const empty[T]: Empty[T] = Empty();

  pub struct Empty[T](());

  pub mod Empty {
    pub impl fork[T]: Fork[Empty[T]];
    pub impl drop[T]: Drop[Empty[T]];

    pub impl iterator[T]: Iterator[Empty[T], T] {
      fn advance(Empty[T]()) -> Option[(T, Empty[T])] {
        None()
      }
    }
  }

  pub fn one[T](value: T) -> One[T] {
    One(Some(value))
  }

  pub struct* One[T](Option[T]);

  pub mod One {
    pub impl iterator[T]: Iterator[One[T], T] {
      fn advance(One[T](value)) -> Option[(T, One[T])] {
        Option::map(value, fn? (value) { (value, One(None())) })
      }
    }
  }

  pub fn from_next[T, F*; fn F() -> Option[T]](f: F) -> FromNext[F] {
    FromNext(f)
  }

  pub struct* FromNext[F](F);

  pub mod FromNext {
    pub impl iterator[T, F*; fn F() -> Option[T]]: Iterator[FromNext[F], T] {
      fn advance(FromNext[F](f)) -> Option[(T, FromNext[F])] {
        if f() is Some(value) {
          Some(value, FromNext(f))
        } else {
          None()
        }
      }
    }
  }

  pub fn .map[... U, F*; fn F(T) -> U](iter: I, f: F) -> Map[I, F] {
    Map(iter, f)
  }

  pub struct* Map[I, F]((I, F));

  pub mod Map[...] {
    pub impl iterator[... U, F*; fn F(T) -> U]: Iterator[Map[I, F], U] {
      fn advance(Map[I, F](iter, f)) -> Option[(U, Map[I, F])] {
        match iter.advance() {
          Some(value, iter) { Some(f(value), iter.map(f)) }
          None() { None() }
        }
      }
    }
  }

  pub fn .filter[... F*; fn F(&T) -> Bool](iter: I, f: F) -> Filter[I, F] {
    Filter(iter, f)
  }

  pub struct* Filter[I, F]((I, F));

  pub mod Filter[...] {
    pub impl iterator[... T?, F*; fn F(&T) -> Bool]: Iterator[Filter[I, F], T] {
      fn advance(Filter[I, F](iter, f)) -> Option[(T, Filter[I, F])] {
        loop {
          match iter.advance() {
            Some(value, _iter) {
              iter = _iter;
              if f(&value) {
                Some(value, Filter(iter, f))
              } else {
                continue;
              }
            }
            None() { None() }
          }
        }
      }
    }
  }

  pub fn .filter_map[... U, F*; fn F(T) -> Option[U]](iter: I, f: F) -> FilterMap[I, F] {
    FilterMap(iter, f)
  }

  pub struct* FilterMap[I, F]((I, F));

  pub mod FilterMap[...] {
    pub impl iterator[... U, F*; fn F(T) -> Option[U]]: Iterator[FilterMap[I, F], U] {
      fn advance(FilterMap[I, F](iter, f)) -> Option[(U, FilterMap[I, F])] {
        loop {
          match iter.advance() {
            Some(value, _iter) {
              iter = _iter;
              if f(value) is Some(value) {
                Some(value, FilterMap(iter, f))
              } else {
                continue;
              }
            }
            None() { None() }
          }
        }
      }
    }
  }

  pub fn .skip[... T?](iter: I, count: N32) -> Skip[I] {
    Skip(iter, count)
  }

  pub struct* Skip[I]((I, N32));

  pub mod Skip[...] {
    pub impl iterator[... T?]: Iterator[Skip[I], T] {
      fn advance(Skip[I](iter, count)) -> Option[(T, Skip[I])] {
        while count != 0 {
          count -= 1;
          if iter.advance() is Some(_, _iter) {
            iter = _iter;
          } else {
            return None();
          }
        }
        Option::map(iter.advance(), fn? ((value, iter)) { (value, Skip(iter, 0)) })
      }
    }
  }

  pub fn .skip_while[... T?, F*; fn F(&T) -> Bool](iter: I, f: F) -> SkipWhile[I, F] {
    SkipWhile(iter, Some(f))
  }

  pub struct* SkipWhile[I, F]((I, Option[F]));

  pub mod SkipWhile[...] {
    pub impl iterator[... T?, F*; fn F(&T) -> Bool]: Iterator[SkipWhile[I, F], T] {
      fn advance(SkipWhile[I, F](iter, f)) -> Option[(T, SkipWhile[I, F])] {
        if f is Some(f) {
          while iter.advance() is Some(value, _iter) {
            iter = _iter;
            if !f(&value) {
              break Some(value, SkipWhile(iter, None()));
            }
          } else {
            None()
          }
        } else {
          Option::map(iter.advance(), fn? ((value, iter)) { (value, SkipWhile(iter, None())) })
        }
      }
    }
  }

  pub fn .take[... I?](iter: I, count: N32) -> Take[I] {
    Take(iter, count)
  }

  pub struct* Take[I]((I, N32));

  pub mod Take[...] {
    pub impl iterator[... I?]: Iterator[Take[I], T] {
      fn advance(Take[I](iter, count)) -> Option[(T, Take[I])] {
        if count != 0 and iter.advance() is Some(value, iter) {
          Some(value, Take(iter, count - 1))
        } else {
          None()
        }
      }
    }
  }

  pub fn .take_while[... I?, F*; fn F(&T) -> Bool](iter: I, f: F) -> TakeWhile[I, F] {
    TakeWhile(iter, f)
  }

  pub struct* TakeWhile[I, F]((I, F));

  pub mod TakeWhile[...] {
    pub impl iterator[... I?, T?, F*; fn F(&T) -> Bool]: Iterator[TakeWhile[I, F], T] {
      fn advance(TakeWhile[I, F](iter, f)) -> Option[(T, TakeWhile[I, F])] {
        if iter.advance() is Some(value, iter) and f(&value) {
          Some(value, TakeWhile(iter, f))
        } else {
          None()
        }
      }
    }
  }

  pub fn .map_while[... I?, U, F*; fn F(T) -> Option[U]](iter: I, f: F) -> MapWhile[I, F] {
    MapWhile(iter, f)
  }

  pub struct* MapWhile[I, F]((I, F));

  pub mod MapWhile[...] {
    pub impl iterator[... I?, U, F*; fn F(T) -> Option[U]]: Iterator[MapWhile[I, F], U] {
      fn advance(MapWhile[I, F](iter, f)) -> Option[(U, MapWhile[I, F])] {
        if iter.advance() is Some(value, iter) and f(value) is Some(value) {
          Some(value, MapWhile(iter, f))
        } else {
          None()
        }
      }
    }
  }

  pub fn .zip[... I?, T?, J?, U; Iterator[J, U]](i: I, j: J) -> Zip[I, J] {
    Zip(i, j)
  }

  pub struct* Zip[I, J]((I, J));

  pub mod Zip[...] {
    pub impl iterator[... I?, T?, J?, U; Iterator[J, U]]: Iterator[Zip[I, J], (T, U)] {
      fn advance(Zip[I, J](i, j)) -> Option[((T, U), Zip[I, J])] {
        if i.advance() is Some(t, i) and j.advance() is Some(u, j) {
          Some((t, u), Zip(i, j))
        } else {
          None()
        }
      }
    }
  }

  pub fn .flatten[I, J, T; Iterator[I, J], Iterator[J, T]](iter: I) -> Flatten[I, J] {
    Flatten(None(), iter)
  }

  pub struct* Flatten[I, J]((Option[J], I));

  pub mod Flatten {
    pub impl iterator[I, J, T; Iterator[I, J], Iterator[J, T]]: Iterator[Flatten[I, J], T] {
      fn advance(Flatten[I, J](j, i)) -> Option[(T, Flatten[I, J])] {
        if j is Some(j) and j.advance() is Some(t, j) {
          Some(t, Flatten(Some(j), i))
        } else {
          while i.advance() is Some(j, _i) {
            i = _i;
            if j.advance() is Some(t, j) {
              break Some(t, Flatten(Some(j), i));
            }
          } else {
            None()
          }
        }
      }
    }
  }

  pub fn .flat_map[... J, U, F*; fn F(T) -> J, Iterator[J, T]](iter: I, f: F) -> Flatten[
    Map[I, F], J;
  ] {
    iter.map(f).flatten()
  }

  pub impl concat[... J; Iterator[J, T]]: ops::Concat[I, J, Concat[I, J]] {
    fn concat(i: I, j: J) -> Concat[I, J] {
      Concat(Some(i), j)
    }
  }

  pub struct* Concat[I, J]((Option[I], J));

  pub mod Concat[...] {
    pub impl iterator[... J; Iterator[J, T]]: Iterator[Concat[I, J], T] {
      fn advance(Concat[I, J](i, j)) -> Option[(T, Concat[I, J])] {
        when {
          i is Some(i) and i.advance() is Some(value, i) { Some(value, Concat(Some(i), j)) }
          j.advance() is Some(value, j) { Some(value, Concat(None(), j)) }
          _ { None() }
        }
      }
    }
  }

  pub fn .enumerate[...](iter: I) -> Map[I, Enumerate] {
    iter.map(Enumerate(&0))
  }

  pub struct* Enumerate(&N32);

  pub mod Enumerate {
    pub impl call[T]: fn Enumerate(T) -> (N32, T) {
      fn call(Enumerate(&index), (value: T,)) -> (N32, T) {
        let result = (index, value);
        index += 1;
        result
      }
    }
  }

  pub fn .inspect[... F*; fn F(&T)](iter: I, f: F) -> Map[I, Inspect[F]] {
    iter.map(Inspect(f))
  }

  pub struct* Inspect[F](F);

  pub mod Inspect {
    pub impl Inspect[T, F*; fn F(&T)]: fn Inspect[F](T) -> T {
      fn call(Inspect[F](f), (value: T,)) -> T {
        f(&value);
        value
      }
    }
  }

  pub fn .forked[I, T; Iterator[I, &T], Fork[T]](iter: I) -> Map[I, fn Fork::fork] {
    iter.map(Fork::fork)
  }

  pub fn .count[... T?](iter: I) -> N32 {
    let len = 0;
    for _ in iter {
      len += 1;
    }
    len
  }

  pub fn .find[... I?, T?, F*; fn F(&T) -> Bool](iter: I, f: F) -> Option[T] {
    for value in iter {
      if f(&value) {
        break Some(value);
      }
    } else {
      None()
    }
  }

  pub fn .find_map[... I?, U, F*; fn F(T) -> Option[U]](iter: I, f: F) -> Option[U] {
    for value in iter {
      if f(value) is Some(value) {
        break Some(value);
      }
    } else {
      None()
    }
  }

  pub fn .for_each[... F*; fn F(T)](iter: I, f: F) {
    for value in iter {
      f(value);
    }
  }

  pub fn .fold[... U, F*; fn F(U, T) -> U](iter: I, init: U, f: F) -> U {
    let current = init;
    for value in iter {
      current = f(current, value);
    }
    current
  }

  pub fn .reduce[... F*; fn F(T, T) -> T](iter: I, f: F) -> Option[T] {
    match iter.advance() {
      Some(value, iter) { Some(iter.fold(value, f)) }
      None() { None() }
    }
  }

  pub fn .all[... I?, F*; fn F(T) -> Bool](iter: I, f: F) -> Bool {
    for value in iter {
      if !f(value) {
        break false;
      }
    } else {
      true
    }
  }

  pub fn .any[... I?, F*; fn F(T) -> Bool](iter: I, f: F) -> Bool {
    for value in iter {
      if f(value) {
        break true;
      }
    } else {
      false
    }
  }

  pub fn .nth[... I?, T?](iter: I, index: N32) -> Option[T] {
    for value in iter {
      if index == 0 {
        break Some(value);
      } else {
        index -= 1;
      }
    } else {
      None()
    }
  }

  pub fn .last[... I?, T?](iter: I) -> Option[T] {
    if iter.advance() is Some(current, iter) {
      for value in iter {
        current = value;
      }
      Some(current)
    } else {
      None()
    }
  }

  pub use Collect::collect as _;
}

pub trait Collect[C, T] {
  fn .collect[I; Iterator[I, T]](iter: I) -> C;
}

pub struct* Fused[I](pub Option[I]);

pub mod Fused {
  pub fn new[I](iter: I) -> Fused[I] {
    Fused(Some(iter))
  }

  pub fn .next[I, T; Iterator[I, T]](&Fused[I](inner)) -> Option[T] {
    if inner is Some(iter) and iter.advance() is Some(value, iter) {
      inner = Some(iter);
      Some(value)
    } else {
      inner = None();
      None()
    }
  }
}

pub trait Iterate[C, I, T] {
  fn .iter(c: C) -> I;
}

pub mod Iterate {
  pub impl iterate[C, I, T; Cast[C, I], Iterator[I, T]]: Iterate[C, I, T] {
    fn iter(collection: C) -> I {
      collection as I
    }
  }

  pub fn .iter_ref[C, I, T; Iterate[&C, I, T]](&collection: &C) -> I {
    iter(&collection)
  }
}
