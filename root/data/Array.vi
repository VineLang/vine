
use ops::{Cast, comparison::Eq};

/// A contiguous, indexed collection of `T`.
///
/// Values can be efficiently accessed by index, and added/removed from the
/// beginning/end of the array.
///
/// Iterating over all of the values is less efficient; if this is being done
/// regularly, consider using a `List[T]` instead.
pub struct Array[T]((N32, Node[T]));

pub mod Array {
  pub const empty[T]: Array[T] = Array(0, unsafe::eraser);

  pub fn single[T](value: T) -> Array[T] {
    Array(1, value as Node)
  }

  /// Create an array containing `len` copies of `value`.
  ///
  /// ```vi
  /// Array::new(6, ".") // Array([".", ".", ".", ".", ".", "."])
  /// ```
  pub fn new[T*](len: N32, value: T) -> Array[T] {
    if len == 0 {
      Array::empty
    } else {
      Array(len, Node::new(len, value))
    }
  }

  /// Convert a list to an array, preserving the order of values. `O(n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array // Array([1, 2, 3])
  /// ```
  pub impl from_list[T]: Cast[List[T], Array[T]] {
    fn cast(List[T](len, buf, _end)) -> Array[T] {
      unsafe::erase(_end);
      let array = Array::from_fn(
        len,
        fn* () {
          let List::Buf(head, tail) = buf;
          buf = tail;
          head
        },
      );
      unsafe::erase(buf);
      array
    }
  }

  /// Convert a list to an array, preserving the order of values. `O(n)`
  /// ```vi
  /// let array = Array::empty;
  /// array.push_back(1);
  /// array.push_back(2);
  /// array.push_back(3);
  /// array as List // [1, 2, 3]
  /// ```
  pub impl to_list[T]: Cast[Array[T], List[T]] {
    fn cast(self: Array[T]) -> List[T] {
      let end;
      List(self.len(), self.fold_back(~end, fn* (a, b) { List::Buf(b, a) }), end)
    }
  }

  /// Create an array with the given length, where each value is produced
  /// in order by calling the function. `O(n)`
  /// ```vi
  /// let i = 0;
  /// let array = Array::from_fn(3, fn* () { i += 1; i });
  /// array // Array([1, 2, 3])
  /// ```
  pub fn from_fn[T, F*; fn F() -> T](len: N32, f: F) -> Array[T] {
    if len == 0 {
      Array::empty
    } else {
      let ~ins;
      let (node, outs) = Node::unzip_with(len, ~ins, fn* (f: F) { (f(), f) });
      let outs = Array(len, outs);
      outs.pop_back().assume();
      outs.push_front(f);
      let Array(_, outs) = outs;
      ~ins = outs;
      Array(len, node)
    }
  }

  /// Iterate over the values of the array in order.
  pub fn .for_each[T, F*; fn F(T)](self: Array[T], f: F) {
    let f = debug::with_state(f);
    self.fold_front(
      f,
      fn* (f: debug::WithState[F], value) {
        f(value);
        f
      },
    );
  }

  /// Fold over the array, starting from the front.
  /// ```vi
  /// let array = Array([1, 2, 3]);
  /// let str = array.fold_front("initial", fn* (str: String, value: N32) {
  ///   "f({str}, {value})"
  /// });
  /// str // "f(f(f(initial, 1), 2), 3)"
  /// ```
  pub fn .fold_front[T, U, F*; fn F(U, T) -> U](Array[T](len, node), initial: U, f: F) -> U {
    if len == 0 {
      unsafe::erase(node);
      initial
    } else {
      let ~ins;
      let zipped = Array(len, Node::zip_with(len, ~ins, node, f));
      let out = zipped.pop_back().assume();
      zipped.push_front(initial);
      let Array(_, node) = zipped;
      ~ins = node;
      out
    }
  }

  /// Fold over the array, starting from the back.
  /// ```vi
  /// let array = Array([1, 2, 3]);
  /// let str = array.back("initial", fn* (value: N32, str: String) {
  ///   "f({value}, {str})"
  /// });
  /// str // "f(1, f(2, f(3, initial)))"
  /// ```
  pub fn .fold_back[T, U, F*; fn F(U, T) -> U](Array[T](len, node), initial: U, f: F) -> U {
    if len == 0 {
      unsafe::erase(node);
      initial
    } else {
      let ~ins;
      let zipped = Array(len, Node::zip_with(len, ~ins, node, f));
      let out = zipped.pop_front().assume();
      zipped.push_back(initial);
      let Array(_, node) = zipped;
      ~ins = node;
      out
    }
  }

  /// The length of the array. `O(1)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.len() // 3
  /// ```
  pub fn .len[T](&self: &Array[T]) -> N32 {
    self.0
  }

  /// Access the `i`th element of the array. `O(log n)`
  /// ```vi
  /// let array = ["a", "b", "C"] as Array;
  /// array.at(1) // Some(&"b")
  /// array.at(2).assume().* = "c";
  /// array // Array(["a", "b", "c"])
  /// ```
  pub fn .at[T](&Array[T](len, *node), i: N32) -> Option[&T] {
    if i >= len {
      let &_ = node;
      return None();
    }
    let size = len;
    while size > 1 {
      (node, size) = Node::half(node, size, i % 2);
      i /= 2;
    }
    Some(node as &T)
  }

  /// Get the `i`th element of the array. `O(log n)`
  /// ```vi
  /// let array = ["a", "b", "c"] as Array;
  /// array.get(0) // Some("a")
  /// array.get(1) // Some("b")
  /// array.get(3) // None
  /// ```
  pub fn .get[T+](&self: &Array[T], i: N32) -> Option[T] {
    self.at(i).as_fork()
  }

  /// Append a value to the end of the array. `O(log n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.push_back(4);
  /// array // Array([1, 2, 3, 4])
  /// ```
  pub fn .push_back[T](&Array[T](len, *node), value: T) {
    if len == 0 {
      let &node = node;
      unsafe::erase(node);
      node = value as Node;
    } else {
      let size = len;
      while size > 1 {
        (node, size) = Node::half(node, size, size % 2);
      }
      let &node = node;
      node = Node(node, value as Node);
    }
    len += 1;
  }

  /// Append a value to the beginning of the array. `O(log n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.push_front(0);
  /// array // Array([0, 1, 2, 3])
  /// ```
  pub fn .push_front[T](&Array[T](len, *node), value: T) {
    if len == 0 {
      let &node = node;
      unsafe::erase(node);
      node = value as Node;
    } else {
      let size = len;
      while size > 1 {
        let &Node(left, right) = node;
        (left, right) = (right, left);
        node = &left;
        size = size / 2;
      }
      let &node = node;
      node = Node(value as Node, node);
    }
    len += 1;
  }

  /// Remove the last value from the array. `O(log n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.pop_back() // Some(3)
  /// array // Array([1, 2])
  /// ```
  pub fn .pop_back[T](&Array[T](len, *node)) -> Option[T] {
    when {
      len == 0 { None() }
      len == 1 {
        len = 0;
        Some(unsafe::move(node) as T)
      }
      _ {
        let size = len;
        len -= 1;
        loop {
          let parity = (size - 1) % 2;
          let &parent = node;
          (node, size) = Node::half(&parent, size, parity);
          if size != 1 {
            continue;
          }
          let value = unsafe::move(node) as T;
          let Node(left, right) = parent;
          parent = if parity == 0 {
            unsafe::erase(left);
            right
          } else {
            unsafe::erase(right);
            left
          };
          Some(value)
        }
      }
    }
  }

  /// Remove the first value from the array. `O(log n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.pop_front() // Some(1)
  /// array // Array([2, 3])
  /// ```
  pub fn .pop_front[T](&Array[T](len, *node)) -> Option[T] {
    when {
      len == 0 { None() }
      len == 1 {
        len = 0;
        Some(unsafe::move(node) as T)
      }
      _ {
        let size = len;
        len -= 1;
        loop {
          let &parent = node;
          let &Node(left, right) = &parent;
          (left, right) = (right, left);
          node = &right;
          size = (size + 1) / 2;
          if size != 1 {
            continue;
          }
          let value = unsafe::move(node) as T;
          unsafe::erase(parent);
          parent = unsafe::move(&left);
          Some(value)
        }
      }
    }
  }

  /// Map over the array, applying the function to each element.
  ///
  /// While the elements stay in the given order, the function is not necessarily applied to the
  /// elements in that order.
  ///
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.map_unordered(fn* (val: N32) { val * 2 }) // Array([2, 4, 6])
  /// ```
  pub fn .map_unordered[T, U, F*; fn F(T) -> U](Array[T](len, node), f: F) -> Array[U] {
    if len == 0 {
      unsafe::erase(node);
      Array::empty
    } else {
      Array(len, Node::map_unordered(node, len, f))
    }
  }

  /// Reverse the elements of the array. `O(n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.reverse();
  /// array // Array([3, 2, 1])
  /// ```
  pub fn .reverse[T](&Array[T](len, node)) {
    node.reverse(len)
  }

  /// Returns an array with the elements reversed. `O(n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.reversed() // Array([3, 2, 1])
  /// ```
  pub fn .reversed[T](self: Array[T]) -> Array[T] {
    self.reverse();
    self
  }

  pub impl eq[T; Eq[T]]: Eq[Array[T]] {
    fn eq(&Array[T](len, node), &Array[T](len_other, other)) -> Bool {
      len == len_other and (len == 0 or Node::eq(len, &node, &other))
    }

    fn ne(&a: &Array[T], &b: &Array[T]) -> Bool {
      !(a == b)
    }
  }

  #[become(unsafe::duplicate)]
  pub impl fork[T+]: Fork[Array[T]] {
    fn fork(&Array[T](len, node)) -> Array[T] {
      if len == 0 {
        Array::empty
      } else {
        Array(len, Node::fork(len, &node))
      }
    }
  }

  #[become(unsafe::erase)]
  pub impl drop[T?]: Drop[Array[T]] {
    fn drop(Array[T](len, node)) {
      if len == 0 {
        unsafe::erase(node)
      } else {
        Node::drop(len, node)
      }
    }
  }

  pub impl show[T; Show[T]]: Show[Array[T]] {
    fn show(&self: &Array[T]) -> Show {
      Show::Constructor("Array", self.&.as[&List].*.show())
    }
  }
}

/// The internal tree structure of an array.
///
/// Whether this is a leaf or branch node is stored out of band in the length
/// of the array. If this is a leaf node, the content is actually `T`. If this
/// is a branch node, the left child stores the even indices, and the right
/// child stores the odd indices.
///
/// For example, the array `[0, 1, 2, 3, 4, 5, 6]` would be represented as:
/// ```vi
/// Array(5, Node(Node(Node(0, 4), Node(2, 6)), Node(Node(1, 5), 3)))
/// ```
struct Node[T]((Node[T], Node[T]));

mod Node {
  pub impl leaf_to_node[T]: Cast[T, Node[T]] = unsafe::transmute;
  pub impl node_to_leaf[T]: Cast[Node[T], T] = unsafe::transmute;

  pub fn new[T+](len: N32, value: T) -> Node[T] {
    if len == 1 {
      value as Node
    } else {
      Node(Node::new((len + 1) / 2, value), Node::new(len / 2, value))
    }
  }

  pub fn .half[T](&Node(l, r): &Node[T], len: N32, x: N32) -> (&Node[T], N32) {
    if x == 0 {
      (&l, (len + 1) / 2)
    } else {
      (&r, len / 2)
    }
  }

  pub fn .map_unordered[T, U, F*; fn F(T) -> U](node: Node[T], len: N32, f: F) -> Node[U] {
    if len == 1 {
      f(node as T) as Node
    } else {
      let Node(l, r) = node;
      Node(map_unordered(l, (len + 1) / 2, f), map_unordered(r, len / 2, f))
    }
  }

  pub fn .reverse[T](&self: &Node[T], len: N32) {
    if len > 1 {
      let &Node(left, right) = &self;
      if len % 2 == 0 {
        (left, right) = (right, left);
      }
      left.reverse((len + 1) / 2);
      right.reverse(len / 2);
    }
  }

  pub fn zip_with[T, U, V, F+; fn F(T, U) -> V](len: N32, x: Node[T], y: Node[U], f: F) -> Node[V] {
    if len == 1 {
      f(x as T, y as U) as Node
    } else {
      let Node(xl, xr) = x;
      let Node(yl, yr) = y;
      Node(zip_with((len + 1) / 2, xl, yl, f), zip_with(len / 2, xr, yr, f))
    }
  }

  pub fn unzip_with[T, U, V, F+; fn F(T) -> (U, V)](len: N32, x: Node[T], f: F) -> (
    Node[U],
    Node[V],
  ) {
    if len == 1 {
      let (u, v) = f(x as T);
      (u as Node, v as Node)
    } else {
      let Node(l, r) = x;
      let (lx, ly) = unzip_with((len + 1) / 2, l, f);
      let (rx, ry) = unzip_with(len / 2, r, f);
      (Node(lx, rx), Node(ly, ry))
    }
  }

  /// Checks wether two nodes of the same lengths are equal. This method is only safe to call on
  /// nodes of the same lengths.
  pub fn eq[T; Eq[T]](len: N32, &self: &Node[T], &other: &Node[T]) -> Bool {
    if len == 1 {
      &self as &T == &other as &T
    } else {
      let &Node(l, r) = &self;
      let &Node(other_l, other_r) = &other;
      eq((len + 1) / 2, &l, &other_l) and eq(len / 2, &r, &other_r)
    }
  }

  pub fn fork[T+](len: N32, &node: &Node[T]) -> Node[T] {
    if len == 1 {
      (&node).as[&T].*.fork().as[Node[T]]
    } else {
      let &Node(l, r) = &node;
      Node(fork((len + 1) / 2, &l), fork(len / 2, &r))
    }
  }

  pub fn drop[T?](len: N32, node: Node[T]) {
    if len == 1 {
      _ = node as T;
    } else {
      let Node(l, r) = node;
      drop((len + 1) / 2, l);
      drop(len / 2, r);
    }
  }
}
