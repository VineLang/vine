
use List::Stream;
use logical::Nullable;
use ops::{Cast, Index::{Index, IndexPlace, IndexSpace, IndexValue}, comparison::Eq};
use util::{duplicate, erase};

/// A contiguous, indexed collection of `T`.
///
/// Values can be efficiently accessed by index, and added/removed from the
/// beginning/end of the array.
///
/// Iterating over all of the values is less efficient; if this is being done
/// regularly, consider using a `List[T]` instead.
pub struct Array[T]((N32, Nullable[Node[T]]));

pub mod Array {
  pub const empty[T]: Array[T] = Array(0, safe Nullable::null());

  pub fn single[T](value: T) -> Array[T] {
    Array(1, safe Nullable::data(Node::leaf(value)))
  }

  /// Create an array containing `len` copies of `value`.
  ///
  /// ```vi
  /// Array::new(6, ".") // Array([".", ".", ".", ".", ".", "."])
  /// ```
  pub fn new[T*](len: N32, value: T) -> Array[T] {
    if len == 0 {
      Array::empty
    } else {
      Array(len, safe Nullable::data(Node::new(len, value)))
    }
  }

  /// Convert a list to an array, preserving the order of values. `O(n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array // Array([1, 2, 3])
  /// ```
  pub impl from_list[T]: Cast[List[T], Array[T]] {
    fn cast(List[T](len, front, back)) -> Array[T] {
      let array = Array::from_fn(len, fn* () { safe front.pop() });
      safe (Stream::done(), ~Stream::done()) = (front, back);
      array
    }
  }

  /// Convert a list to an array, preserving the order of values. `O(n)`
  /// ```vi
  /// let array = Array::empty;
  /// array.push_back(1);
  /// array.push_back(2);
  /// array.push_back(3);
  /// array as List // [1, 2, 3]
  /// ```
  pub impl to_list[T]: Cast[Array[T], List[T]] {
    fn cast(self: Array[T]) -> List[T] {
      let len = self.len();
      let (front, back) = Stream::pair;
      Array::for_each(self, fn* (value: T) { back.push(value) });
      List(len, front, back)
    }
  }

  /// Create an array with the given length, where each value is produced
  /// in order by calling the function. `O(n)`
  /// ```vi
  /// let i = 0;
  /// let array = Array::from_fn(3, fn* () { i += 1; i });
  /// array // Array([1, 2, 3])
  /// ```
  pub fn from_fn[T, F*; fn F() -> T](len: N32, f: F) -> Array[T] {
    if len == 0 {
      Array::empty
    } else {
      let node;
      Array::for_each(
        Array(len, ~node),
        fn* (~t) {
          t = f();
        },
      );
      Array(len, node)
    }
  }

  /// Iterate over the values of the array in order.
  pub fn .for_each[T, F*; fn F(T)](self: Array[T], f: F) {
    let f = debug::with_state(f);
    self.fold_front(
      f,
      fn* (f: debug::WithState[F], value) {
        f(value);
        f
      },
    );
  }

  /// Fold over the array, starting from the front.
  /// ```vi
  /// let array = Array([1, 2, 3]);
  /// let str = array.fold_front("initial", fn* (str: String, value: N32) {
  ///   "f({str}, {value})"
  /// });
  /// str // "f(f(f(initial, 1), 2), 3)"
  /// ```
  pub fn .fold_front[T, U, F*; fn F(U, T) -> U](Array[T](len, node), initial: U, f: F) -> U {
    if len == 0 {
      safe node.null;
      initial
    } else {
      let final;
      let loop values;
      Node::push_back(len, &~values, ~final);
      values = Node::zip_with(len, values, safe node.data, f);
      Node::push_front(len, &values, initial);
      final
    }
  }

  /// Fold over the array, starting from the back.
  /// ```vi
  /// let array = Array([1, 2, 3]);
  /// let str = array.back("initial", fn* (value: N32, str: String) {
  ///   "f({value}, {str})"
  /// });
  /// str // "f(1, f(2, f(3, initial)))"
  /// ```
  pub fn .fold_back[T, U, F*; fn F(U, T) -> U](Array[T](len, node), initial: U, f: F) -> U {
    if len == 0 {
      safe node.null;
      initial
    } else {
      let final;
      let loop values;
      Node::push_front(len, &~values, ~final);
      values = Node::zip_with(len, values, safe node.data, f);
      Node::push_back(len, &values, initial);
      final
    }
  }

  pub fn .reduce_unordered[T, F*; fn F(T, T) -> T](Array[T](len, node), f: F) -> Option[T] {
    if len == 0 {
      safe node.null;
      None()
    } else {
      Some(safe node.data.reduce_unordered(len, f))
    }
  }

  /// The length of the array. `O(1)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.len() // 3
  /// ```
  pub fn .len[T](&self: &Array[T]) -> N32 {
    self.0
  }

  /// Access the `i`th element of the array. `O(log n)`
  /// ```vi
  /// let array = ["a", "b", "C"] as Array;
  /// array.at(1) // Some(&"b")
  /// array.at(2).assume().* = "c";
  /// array // Array(["a", "b", "c"])
  /// ```
  pub fn .at[T](&Array[T](len, node), i: N32) -> Option[&T] {
    assert i < len else { None() }
    let node = safe &node.data;
    let size = len;
    while size > 1 {
      (node, size) = safe Node::half(node, size, i % 2);
      i /= 2;
    }
    Some(safe &node.*.leaf)
  }

  /// Get the `i`th element of the array. `O(log n)`
  /// ```vi
  /// let array = ["a", "b", "c"] as Array;
  /// array.get(0) // Some("a")
  /// array.get(1) // Some("b")
  /// array.get(3) // None
  /// ```
  pub fn .get[T+](&self: &Array[T], i: N32) -> Option[T] {
    self.at(i).as_fork()
  }

  /// Append a value to the end of the array. `O(log n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.push_back(4);
  /// array // Array([1, 2, 3, 4])
  /// ```
  pub fn .push_back[T](&Array[T](len, node), value: T) {
    if len == 0 {
      safe node.null;
      safe node.data = Node::leaf(value);
    } else {
      Node::push_back(len, safe &node.data, value);
    }
    len += 1;
  }

  /// Append a value to the beginning of the array. `O(log n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.push_front(0);
  /// array // Array([0, 1, 2, 3])
  /// ```
  pub fn .push_front[T](&Array[T](len, node), value: T) {
    if len == 0 {
      safe node.null;
      safe node.data = Node::leaf(value);
    } else {
      Node::push_front(len, safe &node.data, value);
    }
    len += 1;
  }

  /// Remove the last value from the array. `O(log n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.pop_back() // Some(3)
  /// array // Array([1, 2])
  /// ```
  pub fn .pop_back[T](&Array[T](len, node)) -> Option[T] {
    when {
      len == 0 { None() }
      len == 1 {
        len = 0;
        let value = safe node.data.leaf;
        node = safe Nullable::null();
        Some(value)
      }
      _ {
        len -= 1;
        let value;
        Node::push_back(len, safe &~node.data, ~value);
        Some(value)
      }
    }
  }

  /// Remove the first value from the array. `O(log n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.pop_front() // Some(1)
  /// array // Array([2, 3])
  /// ```
  pub fn .pop_front[T](&Array[T](len, node)) -> Option[T] {
    when {
      len == 0 { None() }
      len == 1 {
        len = 0;
        let value = safe node.data.leaf;
        node = safe Nullable::null();
        Some(value)
      }
      _ {
        len -= 1;
        let value;
        Node::push_front(len, safe &~node.data, ~value);
        Some(value)
      }
    }
  }

  /// Map over the array, applying the function to each element.
  ///
  /// While the elements stay in the given order, the function is not necessarily applied to the
  /// elements in that order.
  ///
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.map_unordered(fn* (val: N32) { val * 2 }) // Array([2, 4, 6])
  /// ```
  pub fn .map_unordered[T, U, F*; fn F(T) -> U](Array[T](len, node), f: F) -> Array[U] {
    if len == 0 {
      safe node.null;
      Array::empty
    } else {
      Array(len, safe Nullable::data(Node::map_unordered(node.data, len, f)))
    }
  }

  /// Reverse the elements of the array. `O(n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.reverse();
  /// array // Array([3, 2, 1])
  /// ```
  pub fn .reverse[T](&Array[T](len, node)) {
    if len != 0 {
      safe node.data.reverse(len)
    }
  }

  /// Returns an array with the elements reversed. `O(n)`
  /// ```vi
  /// let array = [1, 2, 3] as Array;
  /// array.reversed() // Array([3, 2, 1])
  /// ```
  pub fn .reversed[T](self: Array[T]) -> Array[T] {
    self.reverse();
    self
  }

  /// Zips the two arrays with a given function combining the corresponding elements.
  ///
  /// Safety: Errors if the two arrays have different lengths.
  /// ```vi
  /// let left = ["ab", "x"] as Array;
  /// let right = ["cd", "yz"] as Array;
  /// left.zip_with(right, Concat::concat) // Array(["abcd", "xyz"])
  /// ```
  pub fn .zip_with[T, U, V, F*; fn F(T, U) -> V](
    Array[T](len_left, left),
    Array[U](len_right, right),
    f: F,
  ) -> Array[V] {
    when {
      len_left != len_right {
        debug::error_with("`Array::zip_with` called on arrays of unequal lengths", (left, right))
      }
      len_left == 0 {
        safe left.null;
        safe right.null;
        Array::empty
      }
      _ { Array(len_left, safe Nullable::data(Node::zip_with(len_left, left.data, right.data, f))) }
    }
  }

  // Unzips the array with a given function producing two new arrays.
  /// ```vi
  /// let array = ["abcde", "qwerty"] as Array;
  /// let (left, right) = array.unzip_with(fn* (s: String) { s.split_at(3) })
  /// left // Array(["abc", "qwe"])
  /// right // Array(["de", "rty"])
  /// ```
  pub fn .unzip_with[T, F*, U, V; fn F(T) -> (U, V)](Array[T](len, node), f: F) -> (
    Array[U],
    Array[V],
  ) {
    if len == 0 {
      safe node.null;
      (Array::empty, Array::empty)
    } else {
      let (left, right) = Node::unzip_with(len, safe node.data, f);
      (Array(len, safe Nullable::data(left)), Array(len, safe Nullable::data(right)))
    }
  }

  pub impl [T; Eq[T]]: Eq[Array[T]] {
    fn eq(&Array[T](len, node), &Array[T](len_other, other)) -> Bool {
      len == len_other and (len == 0 or Node::eq(len, safe &node.data, safe &other.data))
    }

    fn ne(&a: &Array[T], &b: &Array[T]) -> Bool {
      !(a == b)
    }
  }

  #[safe become(duplicate)]
  pub impl [T+]: Fork[Array[T]] {
    fn fork(&Array[T](len, node)) -> Array[T] {
      if len == 0 {
        Array::empty
      } else {
        Array(len, safe Nullable::data(Node::fork(len, &node.data)))
      }
    }
  }

  #[safe become(erase)]
  pub impl [T?]: Drop[Array[T]] {
    fn drop(Array[T](len, node)) {
      if len == 0 {
        safe node.null;
      } else {
        Node::drop(len, safe node.data);
      }
    }
  }

  pub impl [T; Show[T]]: Show[Array[T]] {
    fn show(&self: &Array[T]) -> Show {
      Show::Constructor("Array", self.&.as[&List].*.show())
    }
  }

  pub impl [T]: Index[Array[T], N32, T] {}

  pub impl [T]: IndexPlace[Array[T], N32, T] {
    fn assume_at(&self: &Array[T], index: N32) -> &T {
      self.at(index).assume()
    }
  }

  pub impl [T?]: IndexSpace[Array[T], N32, T];

  pub impl [T+]: IndexValue[Array[T], N32, T];
}

/// The internal tree structure of an array.
///
/// Whether this is a leaf or branch node is stored out of band in the length
/// of the array. If this is a leaf node, the content is actually `T`. If this
/// is a branch node, the left child stores the even indices, and the right
/// child stores the odd indices.
///
/// For example, the array `[0, 1, 2, 3, 4, 5, 6]` would be represented as:
/// ```vi
/// Array(
///   5,
///   Nullable::data(Node::branch(
///     Node::branch(
///       Node::branch(
///         Node::leaf(0),
///         Node::leaf(4),
///       ),
///       Node::branch(
///         Node::leaf(2),
///         Node::leaf(6),
///       ),
///     ),
///     Node::branch(
///       Node::branch(
///         Node::leaf(1),
///         Node::leaf(5),
///       ),
///       Node::leaf(3),
///     ),
///   )),
/// )
/// ```
#[self_dual]
unsafe enum Node[T] {
  leaf(T),
  branch(Node[T], Node[T]),
}

mod Node {
  pub fn new[T+](len: N32, value: T) -> Node[T] {
    if len == 1 {
      safe Node::leaf(value)
    } else {
      safe Node::branch(Node::new((len + 1) / 2, value), Node::new(len / 2, value))
    }
  }

  pub unsafe fn .half[T](&Node::branch[T](l, r), len: N32, x: N32) -> (&Node[T], N32) {
    if x == 0 {
      (&l, (len + 1) / 2)
    } else {
      (&r, len / 2)
    }
  }

  pub fn .reduce_unordered[T, F*; fn F(T, T) -> T](node: Node[T], len: N32, f: F) -> T {
    if len == 1 {
      safe node.leaf
    } else {
      let safe Node::branch(l, r) = node;
      f(l.reduce_unordered((len + 1) / 2, f), r.reduce_unordered(len / 2, f))
    }
  }

  pub fn .map_unordered[T, U, F*; fn F(T) -> U](node: Node[T], len: N32, f: F) -> Node[U] {
    if len == 1 {
      safe Node::leaf(f(node.leaf))
    } else {
      let safe Node::branch(l, r) = node;
      safe Node::branch(map_unordered(l, (len + 1) / 2, f), map_unordered(r, len / 2, f))
    }
  }

  pub fn .reverse[T](&self: &Node[T], len: N32) {
    if len != 1 {
      let safe &Node::branch(left, right) = &self;
      if len % 2 == 0 {
        swap(&left, &right);
      }
      left.reverse((len + 1) / 2);
      right.reverse(len / 2);
    }
  }

  pub fn zip_with[T, U, V, F+; fn F(T, U) -> V](len: N32, x: Node[T], y: Node[U], f: F) -> Node[V] {
    if len == 1 {
      safe Node::leaf(f(x.leaf, y.leaf))
    } else {
      let safe Node::branch(xl, xr) = x;
      let safe Node::branch(yl, yr) = y;
      safe Node::branch(zip_with((len + 1) / 2, xl, yl, f), zip_with(len / 2, xr, yr, f))
    }
  }

  pub fn unzip_with[T, U, V, F+; fn F(T) -> (U, V)](len: N32, x: Node[T], f: F) -> (
    Node[U],
    Node[V],
  ) {
    let f = fn+ (~u, ~v) {
      let loop t;
      (u, v) = f(t);
      ~t
    };
    let (y, z);
    ~Node::zip_with(len, ~y, ~z, f) = x;
    (y, z)
  }

  pub fn eq[T; Eq[T]](len: N32, &self: &Node[T], &other: &Node[T]) -> Bool {
    if len == 1 {
      safe self.leaf == other.leaf
    } else {
      let safe &Node::branch(l, r) = &self;
      let safe &Node::branch(other_l, other_r) = &other;
      eq((len + 1) / 2, &l, &other_l) and eq(len / 2, &r, &other_r)
    }
  }

  pub fn fork[T+](len: N32, &node: &Node[T]) -> Node[T] {
    if len == 1 {
      safe Node::leaf(node.leaf.fork())
    } else {
      let safe &Node::branch(l, r) = &node;
      safe Node::branch(fork((len + 1) / 2, &l), fork(len / 2, &r))
    }
  }

  pub fn drop[T?](len: N32, node: Node[T]) {
    if len == 1 {
      _ = safe node.leaf;
    } else {
      let safe Node::branch(l, r) = node;
      drop((len + 1) / 2, l);
      drop(len / 2, r);
    }
  }

  pub fn push_front[T](len: N32, &node: &Node[T], value: T) {
    if len == 1 {
      node = safe Node::branch(Node::leaf(value), node);
    } else {
      let safe &Node::branch(left, right) = &node;
      swap(&left, &right);
      Node::push_front(len / 2, &left, value);
    }
  }

  pub fn push_back[T](len: N32, &node: &Node[T], value: T) {
    if len == 1 {
      node = safe Node::branch(node, Node::leaf(value));
    } else {
      let safe &Node::branch(left, right) = &node;
      let &half = if len % 2 == 0 {
        &left
      } else {
        &right
      };
      Node::push_back(len / 2, &half, value)
    }
  }
}
