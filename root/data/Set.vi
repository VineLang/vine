
use data::Iterator::{Iterator, Collect, Iterate};
use debug::Show;
use logical::Nullable;
use ops::{Cast, Concat, comparison::Ord};
use util::{duplicate, erase};

pub struct Set[T]((N32, Nullable[SetNode[T]]));

type SetNode[T] = (Set[T], T, Set[T]);

pub mod Set[T; Ord[T]] {
  pub const empty[T]: Set[T] = Set(0, safe Nullable::null());

  fn new[T](left: Set[T], value: T, right: Set[T]) -> Set[T] {
    Set(left.len() + right.len() + 1, safe Nullable::data(left, value, right))
  }

  pub impl from_list[... T?]: Cast[List[T], Set[T]] {
    fn cast(entries: List[T]) -> Set[T] {
      let set = Set::empty[T];
      for value in entries {
        set.insert(value);
      }
      set
    }
  }

  pub fn .clear[... T?](&self: &Set[T]) {
    self = Set::empty;
  }

  pub fn .len[T](&Set[T](len, _)) -> N32 {
    len
  }

  pub fn .insert[...](&Set[T](len, node), new: T) -> Option[T] {
    if len == 0 {
      len = 1;
      safe node.null;
      safe node.data = (empty, new, empty);
      None()
    } else {
      let &(left, value, right) = safe &node.data;
      let old;
      match new.cmp(&value) {
        Ord::Lt() {
          old = left.insert(new);
          len = size(safe &node.data);
          balance_right(safe &node.data);
        }
        Ord::Eq() {
          old = Some(value);
          value = new;
        }
        Ord::Gt() {
          old = right.insert(new);
          len = size(safe &node.data);
          balance_left(safe &node.data);
        }
      }
      old
    }
  }

  pub impl concat[... T?]: Concat[Set[T], Set[T], Set[T]] {
    fn concat(self: Set[T], other: Set[T]) -> Set[T] {
      for value in other {
        self.insert(value);
      }
      self
    }
  }

  pub fn .has[...](&Set[T](len, node), &key: &T) -> Bool {
    if len == 0 {
      false
    } else {
      let &(left, value, right) = safe &node.data;
      match key.cmp(&value) {
        Ord::Lt() { left.has(&key) }
        Ord::Eq() { true }
        Ord::Gt() { right.has(&key) }
      }
    }
  }

  pub fn .at_eq[...](&Set[T](len, node), &key: &T) -> Option[&T] {
    if len == 0 {
      None()
    } else {
      let &(left, value, right) = safe &node.data;
      match key.cmp(&value) {
        Ord::Lt() { left.at_eq(&key) }
        Ord::Eq() { Some(&value) }
        Ord::Gt() { right.at_eq(&key) }
      }
    }
  }

  pub fn .get_eq[... T+](&self: &Set[T], key: &T) -> Option[T] {
    self.at_eq(key).as_fork()
  }

  pub fn .at_le[...](&Set[T](len, node), &key: &T) -> Option[&T] {
    if len == 0 {
      None()
    } else {
      let &(left, value, right) = safe &node.data;
      match key.cmp(&value) {
        Ord::Lt() { left.at_le(&key) }
        Ord::Eq() { Some(&value) }
        Ord::Gt() {
          if right.at_le(&key) is Some(value) {
            Some(value)
          } else {
            Some(&value)
          }
        }
      }
    }
  }

  pub fn .get_le[... T+](&self: &Set[T], &key: &T) -> Option[T] {
    self.at_le(&key).as_fork()
  }

  pub fn .at_ge[...](&Set[T](len, node), &key: &T) -> Option[&T] {
    if len == 0 {
      None()
    } else {
      let &(left, value, right) = safe &node.data;
      match key.cmp(&value) {
        Ord::Lt() {
          if left.at_ge(&key) is Some(value) {
            Some(value)
          } else {
            Some(&value)
          }
        }
        Ord::Eq() { Some(&value) }
        Ord::Gt() { right.at_ge(&key) }
      }
    }
  }

  pub fn .get_ge[... T+](&self: &Set[T], &key: &T) -> Option[T] {
    self.at_ge(&key).as_fork()
  }

  pub fn .remove[... T](&Set[T](len, node), &key: &T) -> Option[T] {
    if len == 0 {
      None()
    } else {
      let (left, value, right) = safe node.data;
      let old;
      match key.cmp(&value) {
        Ord::Lt() {
          old = left.remove(&key);
          safe node.data = (left, value, right);
          len = Set::size(safe &node.data);
          balance_left(safe &node.data);
        }
        Ord::Eq() {
          old = Some(value);
          len -= 1;
          node = merge_balanced(left, right);
        }
        Ord::Gt() {
          old = right.remove(&key);
          safe node.data = (left, value, right);
          len = Set::size(safe &node.data);
          balance_right(safe &node.data);
        }
      }
      old
    }
  }

  pub fn .remove_min[...](&self: &Set[T]) -> Option[T] {
    if self.len() == 0 {
      None()
    } else {
      Some(self._remove_min())
    }
  }

  pub fn .remove_max[...](&self: &Set[T]) -> Option[T] {
    if self.len() == 0 {
      None()
    } else {
      Some(self._remove_max())
    }
  }

  fn ._remove_min[T](&Set[T](len, node)) -> T {
    len -= 1;
    let (left, value, right) = safe node.data;
    if left.len() == 0 {
      Set(_, safe Nullable::null()) = left;
      Set(_, node) = right;
      value
    } else {
      let min = left._remove_min();
      safe node.data = (left, value, right);
      balance_left(safe &node.data);
      min
    }
  }

  fn ._remove_max[T](&Set[T](len, node)) -> T {
    len -= 1;
    let (left, value, right) = safe node.data;
    if right.len() == 0 {
      Set(_, node) = left;
      Set(_, safe Nullable::null()) = right;
      value
    } else {
      let max = right._remove_max();
      safe node.data = (left, value, right);
      balance_right(safe &node.data);
      max
    }
  }

  /// Maps the values of the set
  ///
  /// Safety: Is only safe if the order of elements is preserved by the mapping function.
  pub.data fn .map[... U, F*; fn F(T) -> U](Set[T](len, node), f: F) -> Set[U] {
    if len == 0 {
      safe node.null;
      Set::empty
    } else {
      let (left, value, right) = safe node.data;
      Set::new(Set::map(left, f), f(value), Set::map(right, f))
    }
  }

  pub impl iter_ref[...]: Iterate[&Set[T], IterRef[T], &T] {
    fn iter(&self: &Set[T]) -> IterRef[T] {
      IterRef(&self, [])
    }
  }

  pub struct IterRef[T]((&Set[T], List[&(T, Set[T])]));

  pub mod IterRef[T] {
    pub impl iterator[...]: Iterator[IterRef[T], &T] {
      fn advance(IterRef[T](current, stack)) -> Option[(&T, IterRef[T])] {
        loop {
          let &Set(len, node) = current;
          if len == 0 {
            break;
          }
          let &(left, value, right) = safe &node.data;
          stack.push_front(&(value, right));
          current = &left;
          continue;
        }
        if stack.head_tail() is Some(&(value, node), stack) {
          Some(&value, IterRef(&node, stack))
        } else {
          None()
        }
      }
    }

    pub impl fork[...]: Fork[IterRef[T]];
    pub impl drop[...]: Drop[IterRef[T]];
  }

  pub impl iter[...]: Iterate[Set[T], Iter[T], T] {
    fn iter(self: Set[T]) -> Iter[T] {
      Iter(self, [])
    }
  }

  pub struct* Iter[T]((Set[T], List[(T, Set[T])]));

  pub mod Iter[T] {
    pub impl iterator[...]: Iterator[Iter[T], T] {
      fn advance(Iter[T](current, stack)) -> Option[(T, Iter[T])] {
        loop {
          let Set(len, node) = current;
          if len == 0 {
            safe node.null;
            break;
          }
          let (left, value, right) = safe node.data;
          stack.push_front((value, right));
          current = left;
          continue;
        }
        if stack.head_tail() is Some((value, node), stack) {
          Some(value, Iter(node, stack))
        } else {
          None()
        }
      }
    }
  }

  pub impl collect[T?; Ord[T]]: Collect[Set[T], T] {
    fn collect[I; Iterator[I, T]](iter: I) -> Set[T] {
      let set = Set::empty;
      for value in iter {
        set.insert(value);
      }
      set
    }
  }

  pub impl to_list[...]: Cast[Set[T], List[T]] {
    fn cast(Set[T](len, node)) -> List[T] {
      if len == 0 {
        safe node.null;
        []
      } else {
        let (left, value, right) = safe node.data;
        left as List ++ [value] ++ right as List
      }
    }
  }

  pub impl show[... ; Show[T]]: Show[Set[T]] {
    fn show(&self: &Set[T]) -> Show {
      let entries = [];
      for &value in &self {
        entries.push_back(value.show());
      }
      Show::Constructor("Set", Show::List(entries))
    }
  }

  // TODO(#118): make private once tests can be written inline
  pub fn .balanced[...](&Set[T](len, node)) -> Bool {
    if len == 0 {
      true
    } else {
      let &(left, _, right) = safe &node.data;
      let x = is_balanced(&left, &right) and is_balanced(&right, &left);
      x and left.balanced() and right.balanced()
    }
  }

  #[safe become(duplicate)]
  pub impl [T+]: Fork[Set[T]] {
    fn fork(&Set[T](len, node)) -> Set[T] {
      if len == 0 {
        Set::empty
      } else {
        Set(len, safe Nullable::data(node.data.fork()))
      }
    }
  }

  #[safe become(erase)]
  pub impl [T?]: Drop[Set[T]] {
    fn drop(Set[T](len, node)) {
      if len == 0 {
        safe node.null;
      } else {
        _ = safe node.data;
      }
    }
  }
}

fn balance_left[T](&node: &SetNode[T]) {
  let (l, e, r) = node;
  node = if is_balanced(&l, &r) {
    (l, e, r)
  } else {
    let Set(_, safe Nullable::data(rl, re, rr)) = r;
    if is_single(&rl, &rr) {
      (Set::new(l, e, rl), re, rr)
    } else {
      let Set(_, safe Nullable::data(rll, rle, rlr)) = rl;
      (Set::new(l, e, rll), rle, Set::new(rlr, re, rr))
    }
  }
}

fn balance_right[T](&node: &SetNode[T]) {
  let (l, e, r) = node;
  node = if is_balanced(&r, &l) {
    (l, e, r)
  } else {
    let Set(_, safe Nullable::data(ll, le, lr)) = l;
    if is_single(&lr, &ll) {
      (ll, le, Set::new(lr, e, r))
    } else {
      let Set(_, safe Nullable::data(lrl, lre, lrr)) = lr;
      (Set::new(ll, le, lrl), lre, Set::new(lrr, e, r))
    }
  }
}

fn merge_balanced[T](Set[T](len_left, left), Set[T](len_right, right)) -> Nullable[SetNode[T]] {
  when {
    len_left == 0 {
      safe left.null;
      right
    }
    len_right == 0 {
      safe right.null;
      left
    }
    _ {
      let left = Set(len_left, left);
      let right = Set(len_right, right);
      let value = if len_left > len_right {
        left._remove_max()
      } else {
        right._remove_min()
      };
      safe Nullable::data(left, value, right)
    }
  }
}

fn is_balanced[T](&Set[T](a, _), &Set[T](b, _)) -> Bool {
  3 * a + 2 >= b
}

fn is_single[T](&Set[T](a, _), &Set[T](b, _)) -> Bool {
  a <= 2 * b
}

fn size[T](&(Set(l, _), _, Set(r, _)): &SetNode[T]) -> N32 {
  l + r + 1
}
