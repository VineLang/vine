
use data::Iterator::{Iterator, Collect, Iterate};
use ops::{Cast, Concat, Range::{Range, Bound}, comparison::{Eq, Ord}};
use util::{duplicate, erase};

/// A linear collection of `T`.
///
/// Lists are optimized for fast concatenation and in-order iteration.
/// Accessing the first value in a list is `O(1)`, but accessing an arbitrary
/// value is `O(n)`.
/// ```vi
/// let list = [1, 2, 3];
/// list.push_front(0);
/// list // [0, 1, 2, 3]
/// list.push_back(4);
/// list // [0, 1, 2, 3, 4]
/// list ++= [5, 6];
/// list // [0, 1, 2, 3, 4, 5, 6]
/// list.pop_front() // Some(0)
/// list // [1, 2, 3, 4, 5, 6]
/// for value in list {
///   io.println("{value}"); // prints 1, 2, 3, 4, 5, 6
/// }
/// ```
///
/// If frequently accessing elements by index, consider using an array instead.
#[builtin = "List"]
pub struct List[T](pub.root N32, Stream[T], ~Stream[T]);

pub.root unsafe enum Stream[T] {
  done(),
  more(T, Stream[T]),
}

pub mod List {
  pub const empty[T]: List[T] = [];

  /// The length of the list. `O(1)`
  pub fn .len[T](&self: &List[T]) -> N32 {
    self.0
  }

  /// Create a list with `len` copies of `value`.
  /// ```vi
  /// let list = List::new(3, ".");
  /// list // [".", ".", "."]
  /// ```
  pub fn new[T*](len: N32, value: T) -> List[T] {
    let (front, back) = Stream::pair;
    for _ in 0..len {
      back.push(value);
    }
    List(len, front, back)
  }

  /// Create a list with the given length, where each value is produced
  /// in order by calling the function. `O(n)`
  /// ```vi
  /// let i = 0;
  /// let list = List::from_fn(3, fn* () { i += 1; i });
  /// list // [1, 2, 3]
  /// ```
  pub fn from_fn[T, F*; fn F() -> T](len: N32, f: F) -> List[T] {
    let (front, back) = Stream::pair;
    for _ in 0..len {
      back.push(f());
    }
    List(len, front, back)
  }

  /// Access the `i`th element of the list. `O(i)`
  /// ```vi
  /// let list = ["a", "b", "C"];
  /// list.at(1) // Some(&"b")
  /// list.at(2).assume().* = "c";
  /// list // List(["a", "b", "c"])
  /// ```
  /// If this is being done regularly, consider using an `Array` instead.
  pub fn .at[T](&List[T](len, front, _), i: N32) -> Option[&T] {
    assert i < len else { None() }
    let cursor = &front;
    for _ in 0..i {
      cursor = safe cursor.*.tail();
    }
    Some(safe cursor.*.head())
  }

  /// Get the `i`th element of the list. `O(i)`
  /// ```vi
  /// let array = ["a", "b", "c"];
  /// array.get(0) // Some("a")
  /// array.get(1) // Some("b")
  /// array.get(3) // None
  /// ```
  /// If this is being done regularly, consider using an `Array` instead.
  pub fn .get[T+](&self: &List[T], i: N32) -> Option[T] {
    self.at(i).as_fork()
  }

  pub fn .slice[T?, B1?, B2?; Bound[B1, N32], Bound[B2, N32]](
    self: List[T],
    Range[B1, B2](start, end),
  ) -> List[T] {
    // Underflow does not matter, still correct
    let end_index = self.len() - 1;
    let i = 0;
    let slice = [];

    while !start.left_of(&i) and self.pop_front() is Some(_) {
      i += 1;
    }
    if end.right_of(&end_index) {
      return self;
    }
    while end.right_of(&i) and self.pop_front() is Some(value) {
      slice.push_back(value);
      i += 1;
    }
    slice
  }

  pub fn .split_at[T](self: List[T], i: N32) -> (List[T], List[T]) {
    assert i < self.len() else { (self, []) }
    let prefix = [];
    while i != 0 and self.pop_front() is Some(value) {
      prefix.push_back(value);
      i -= 1;
    }
    (prefix, self)
  }

  pub fn .map[T, U, F*; fn F(T) -> U](self: List[T], f: F) -> List[U] {
    let len = self.len();
    let (front, back) = Stream::pair;
    for val in self {
      back.push(f(val));
    }
    List(len, front, back)
  }

  pub fn .map_ref[T, U, F*; fn F(&T) -> U](&self: &List[T], f: F) -> List[U] {
    let len = self.len();
    let (front, back) = Stream::pair;
    for &val in &self {
      back.push(f(&val));
    }
    List(len, front, back)
  }

  pub fn .filter[T?, F*; fn F(&T) -> Bool](self: List[T], pred: F) -> List[T] {
    let result = [];
    for value in self {
      if pred(&value) {
        result.push_back(value);
      }
    }
    result
  }

  pub fn .pop_front[T](&List[T](len, front, _)) -> Option[T] {
    if len != 0 {
      len -= 1;
      Some(safe front.pop())
    } else {
      None()
    }
  }

  pub fn .head_tail[T](List[T](len, front, back)) -> Option[(T, List[T])] {
    if len != 0 {
      let head = safe front.pop();
      Some(head, List(len - 1, front, back))
    } else {
      safe (Stream::done(), ~Stream::done()) = (front, back);
      None()
    }
  }

  pub impl [T]: Concat[List[T], List[T], List[T]] {
    fn concat(List[T](a_len, a_front, a_back), List[T](b_len, b_front, b_back)) -> List[T] {
      ~a_back = b_front;
      List(a_len + b_len, a_front, b_back)
    }
  }

  /// Append a value to the end of the list. `O(1)`
  /// ```vi
  /// let list = [1, 2, 3];
  /// list.push_back(4);
  /// list // [1, 2, 3, 4]
  /// ```
  pub fn .push_back[T](&list: &List[T], el: T) {
    list ++= [el];
  }

  /// Append a value to the beginning of the list. `O(1)`
  /// ```vi
  /// let list = [1, 2, 3];
  /// list.push_front(0);
  /// list // [0, 1, 2, 3]
  /// ```
  pub fn .push_front[T](&list: &List[T], el: T) {
    list = [el] ++ list;
  }

  /// Insert an element at position `i` in the list.
  /// ```vi
  /// let list = ["foo", "bar", "qux"]
  /// list.insert(2, "bar");
  /// list // ["foo", "bar", "baz", "qux"]
  /// ```
  /// If `i` is greater than the length of the list, the element will be added
  /// to the end.
  pub fn .insert[T](&list: &List[T], i: N32, el: T) {
    assert i < list.len() else {
      list.push_back(el);
    }
    let &List(len, front, _) = &list;
    let cursor = &front;
    for _ in 0..i {
      cursor = safe cursor.*.tail();
    }
    cursor.*.push(el);
    len += 1;
  }

  pub fn .find[T, F*; fn F(&T) -> Bool](&self: &List[T], pred: F) -> Option[&T] {
    for &value in &self {
      if pred(&value) {
        break Some(&value);
      }
    } else {
      None()
    }
  }

  pub fn .contains[T; Eq[T]](&self: &List[T], &el: &T) -> Bool {
    List::find(&self, fn* (&e: &T) { e == el }) is Some(&_)
  }

  pub fn .join[T; Cast[T, String]](list: List[T], sep: String) -> String {
    if list.head_tail() is Some(head, tail) {
      let str = "{head}";
      for val in tail {
        str ++= "{sep}{val}";
      }
      str
    } else {
      ""
    }
  }

  /// Remove items from the beginning of the list as long as the predicate returns `true`.
  /// ```vi
  /// let list = [0, 1, 3, 5, 0, 6, 0, 2];
  /// list.drop_while(fn* (value: N32) { value <= 3 });
  /// list // [5, 0, 6, 0, 2]
  /// ```
  pub fn .drop_while[T?, F*; fn F(&T) -> Bool](&list: &List[T], pred: F) {
    while list.pop_front() is Some(value) {
      if !pred(&value) {
        list.push_front(value);
        break;
      }
    }
  }

  /// Remove items from the beginning of the list as long as the predicate returns `true`.
  /// ```vi
  /// let list = [0, 1, 3, 5, 0, 6, 0, 2];
  /// list.trim_back_where(fn* (value: N32) { value <= 3 });
  /// list // [0, 1, 3, 5, 0, 6]
  /// ```
  pub fn .trim_back_where[T?, F*; fn F(&T) -> Bool](&self: &List[T], pred: F) {
    let trimmed = [];
    let ~trimming = true;
    for elem in self {
      let matches = pred(&elem);
      if !~trimming {
        trimmed.push_back(elem);
      }
      if !matches {
        ~trimming = false;
      }
    }
    self = trimmed;
  }

  pub impl [T; Show[T]]: Show[List[T]] {
    fn show(&self: &List[T]) -> Show {
      Show::List(self.map_ref(Show::show))
    }
  }

  /// Stably sort the list in ascending order. `O(n log n)`
  /// ```vi
  /// let list = [3, 1, 6, 4, 7];
  /// list.sort();
  /// list // [1, 3, 4, 6, 7]
  /// ```
  pub fn .sort[T; Ord[T]](&list: &List[T]) {
    if list.len() > 1 {
      let len = list.len();
      let sorted = list.sort_prefix(len);
      safe erase(list);
      list = sorted;
    }
  }

  fn .sort_prefix[T; Ord[T]](&list: &List[T], n: N32) -> List[T] {
    if n == 1 {
      [list.pop_front().assume()]
    } else {
      merge(sort_prefix(&list, n / 2), sort_prefix(&list, (n + 1) / 2))
    }
  }

  fn merge[T; Ord[T]](a: List[T], b: List[T]) -> List[T] {
    if a.len() == 0 or b.len() == 0 {
      return a ++ b;
    }
    let out = [];
    let x = a.pop_front().assume();
    let y = b.pop_front().assume();

    loop {
      if y < x {
        out.push_back(y);
        if b.head_tail() is Some(y_, b_) {
          y = y_;
          b = b_;
          continue;
        } else {
          out ++ [x] ++ a
        }
      } else {
        out.push_back(x);
        if a.head_tail() is Some(x_, a_) {
          x = x_;
          a = a_;
          continue;
        } else {
          out ++ [y] ++ b
        }
      }
    }
  }

  /// Checks whether the list is sorted in ascending order.
  /// ```vi
  /// [3, 1, 6, 4, 7].is_sorted() // false
  /// [1, 3, 4, 6, 7].is_sorted() // true
  /// ```
  pub fn .is_sorted[T; Ord[T]](&list: &List[T]) -> Bool {
    for (&prev, &next) in list.iter_ref().windows() {
      if prev > next {
        return false;
      }
    }
    true
  }

  /// Iterate over the elements of the list.
  /// ```vi
  /// let list = [1, 0, 4, 6];
  /// for value in list {
  ///   io.println("{list}");
  /// }
  /// ```
  /// ```
  /// 1
  /// 0
  /// 4
  /// 6
  /// ```
  pub impl iter[T]: Iterate[List[T], Iter[T], T] {
    fn iter(self: List[T]) -> Iter[T] {
      Iter(self)
    }
  }

  pub struct* Iter[T](List[T]);

  pub mod Iter {
    pub impl [T]: Iterator[Iter[T], T] {
      fn advance(Iter[T](List(len, front, back))) -> Option[(T, Iter[T])] {
        if len != 0 {
          let head = safe front.pop();
          Some(head, Iter(List(len - 1, front, back)))
        } else {
          safe (Stream::done(), ~Stream::done()) = (front, back);
          None()
        }
      }
    }

    /// Convert the remaining elements in this iterator back into a list. `O(1)`
    pub impl to_list[T]: Cast[Iter[T], List[T]] {
      fn cast(Iter[T](list)) -> List[T] {
        list
      }
    }
  }

  /// Iterate over the elements of the list by reference.
  /// ```vi
  /// let list = [0, 5, 3, 5];
  /// for &value in &list {
  ///   value += 1;
  /// }
  /// list // [1. 6. 4. 6]
  /// ```
  pub impl iter_ref[T]: Iterate[&List[T], IterRef[T], &T] {
    fn iter(&List[T](len, front, _)) -> IterRef[T] {
      IterRef(len, &front)
    }
  }

  pub struct IterRef[T](N32, &Stream[T]);

  pub mod IterRef {
    pub impl [T]: Iterator[IterRef[T], &T] {
      fn advance(IterRef[T](len, cursor)) -> Option[(&T, IterRef[T])] {
        if len != 0 {
          let head = safe cursor.*.head();
          Some(head, IterRef(len - 1, safe cursor.*.tail()))
        } else {
          None()
        }
      }
    }

    pub impl [T]: Fork[IterRef[T]];
    pub impl [T]: Drop[IterRef[T]];
  }

  /// Collect the items of an iterator into a list.
  /// ```vi
  /// (0..6).collect[List, _, _]() // [0, 1, 2, 3, 4, 5]
  /// ```
  pub impl [T]: Collect[List[T], T] {
    fn collect[I; Iterator[I, T]](iter_ref: I) -> List[T] {
      let list = [];
      for value in iter_ref {
        list.push_back(value);
      }
      list
    }
  }

  /// Construct a list with the elements reversed.
  /// ```vi
  /// let list = [1, 2, 3, 4];
  /// list.reversed() // [4, 3, 2, 1]
  /// ```
  pub fn .reversed[T](self: List[T]) -> List[T] {
    let len = self.len();
    let (front, back) = Stream::pair;
    for value in self {
      front.push(value);
    }
    List(len, front, back)
  }

  /// Reverse the elements of the list.
  /// ```vi
  /// let list = [1, 2, 3, 4];
  /// list.reverse();
  /// list // [4, 3, 2, 1]
  /// ```
  pub fn .reverse[T](&self: &List[T]) {
    self = self.reversed();
  }

  pub impl [T; Eq[T]]: Eq[List[T]] {
    fn eq(&a: &List[T], &b: &List[T]) -> Bool {
      if a.len() != b.len() {
        return false;
      }
      for (a, b) in a.iter_ref().zip(b.iter_ref()) {
        if a != b {
          return false;
        }
      }
      true
    }

    fn ne(&a: &List[T], &b: &List[T]) -> Bool {
      !(a == b)
    }
  }

  pub impl [T; Ord[T]]: Ord[List[T]] {
    fn cmp(&a: &List[T], &b: &List[T]) -> Ord {
      let a_iter = a.iter_ref();
      let b_iter = b.iter_ref();
      let ord = loop {
        match (a_iter.advance(), b_iter.advance()) {
          (None(), None()) { Ord::Eq() }
          (None(), Some(_)) { Ord::Lt() }
          (Some(_), None()) { Ord::Gt() }
          (Some(&a, _a_iter), Some(&b, _b_iter)) {
            (a_iter, b_iter) = (_a_iter, _b_iter);
            match a.cmp(&b) {
              Ord::Lt() { Ord::Lt() }
              Ord::Eq() {
                continue;
              }
              Ord::Gt() { Ord::Gt() }
            }
          }
        }
      };
      ord
    }

    fn lt(a: &List[T], b: &List[T]) -> Bool {
      Ord::lt_from_cmp(a, b)
    }

    fn le(a: &List[T], b: &List[T]) -> Bool {
      Ord::le_from_cmp(a, b)
    }
  }

  #[safe become(duplicate)]
  pub impl [T+]: Fork[List[T]] {
    fn fork(&self: &List[T]) -> List[T] {
      self.map_ref(Fork::fork)
    }
  }

  #[safe become(erase)]
  pub impl [T?]: Drop[List[T]] {
    fn drop(self: List[T]) {
      for _ in self {}
    }
  }
}

pub.root mod Stream {
  pub const pair[T]: (Stream[T], ~Stream[T]) = do {
    let loop stream;
    (stream, ~stream)
  };

  pub fn .push[T](&stream: &Stream[T], value: T) {
    stream = safe Stream::more(value, stream);
  }

  pub unsafe fn .pop[T](&stream: &Stream[T]) -> T {
    let Stream::more(head, tail) = stream;
    stream = tail;
    head
  }

  pub unsafe fn .head[T](&stream: &Stream[T]) -> &T {
    let &Stream::more(head, _) = &stream;
    &head
  }

  pub unsafe fn .tail[T](&stream: &Stream[T]) -> &Stream[T] {
    let &Stream::more(_, tail) = &stream;
    &tail
  }

  pub use back::push as _;

  pub mod back {
    pub fn .push[T](&~stream: &~Stream[T], value: T) {
      stream.push(value);
    }
  }
}
