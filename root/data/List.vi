
use data::Iterator::{Iterator, Collect};
use ops::{Cast, Concat, Range::{Range, Bound}, comparison::{Eq, Ord}};

/// A linear collection of `T`.
///
/// Lists are optimized for fast concatenation and in-order iteration.
/// Accessing the first value in a list is `O(1)`, but accessing an arbitrary
/// value is `O(n)`.
/// ```vi
/// let list = [1, 2, 3];
/// list.push_front(0);
/// list // [0, 1, 2, 3]
/// list.push_back(4);
/// list // [0, 1, 2, 3, 4]
/// list ++= [5, 6];
/// list // [0, 1, 2, 3, 4, 5, 6]
/// list.pop_front() // Some(0)
/// list // [1, 2, 3, 4, 5, 6]
/// for value in list {
///   io.println("{value}"); // prints 1, 2, 3, 4, 5, 6
/// }
/// ```
///
/// If frequently accessing elements by index, consider using an array instead.
#[builtin = "List"]
pub struct List[T](pub.root N32, Buf[T], ~Buf[T]);

pub.root struct Buf[T](pub.root T, Buf[T]);

pub mod List {
  pub const empty[T]: List[T] = [];

  /// The length of the list. `O(1)`
  pub fn .len[T](&self: &List[T]) -> N32 {
    self.0
  }

  /// Create a list with `len` copies of `value`.
  /// ```vi
  /// let list = List::new(3, ".");
  /// list // [".", ".", "."]
  /// ```
  pub fn new[T*](len: N32, value: T) -> List[T] {
    let list = [];
    for _ in 0..len {
      list.push_back(value);
    }
    list
  }

  /// Create a list with the given length, where each value is produced
  /// in order by calling the function. `O(n)`
  /// ```vi
  /// let i = 0;
  /// let list = List::from_fn(3, fn* () { i += 1; i });
  /// list // [1, 2, 3]
  /// ```
  pub fn from_fn[T, F*; fn F() -> T](len: N32, f: F) -> List[T] {
    let list = [];
    for _ in 0..len {
      list.push_back(f());
    }
    list
  }

  /// Access the `i`th element of the list. `O(i)`
  /// ```vi
  /// let list = ["a", "b", "C"];
  /// list.at(1) // Some(&"b")
  /// list.at(2).assume().* = "c";
  /// list // List(["a", "b", "c"])
  /// ```
  /// If this is being done regularly, consider using an `Array` instead.
  pub fn .at[T](&List[T](len, *buf, _), i: N32) -> Option[&T] {
    if i >= len {
      let &_ = buf;
      return None();
    }
    for _ in 0..i {
      let &Buf(_, *tail) = buf;
      buf = tail;
    }
    let &Buf(*head, _) = buf;
    Some(head)
  }

  /// Get the `i`th element of the list. `O(i)`
  /// ```vi
  /// let array = ["a", "b", "c"];
  /// array.get(0) // Some("a")
  /// array.get(1) // Some("b")
  /// array.get(3) // None
  /// ```
  /// If this is being done regularly, consider using an `Array` instead.
  pub fn .get[T+](&self: &List[T], i: N32) -> Option[T] {
    self.at(i).as_fork()
  }

  pub fn .slice[T?, B1?, B2?; Bound[B1, N32], Bound[B2, N32]](
    self: List[T],
    Range[B1, B2](start, end),
  ) -> List[T] {
    // Underflow does not matter, still correct
    let end_index = self.len() - 1;
    let i = 0;
    let slice = [];

    while !start.left_of(&i) and self.pop_front() is Some(_) {
      i += 1;
    }
    if end.right_of(&end_index) {
      return self;
    }
    while end.right_of(&i) and self.pop_front() is Some(value) {
      slice.push_back(value);
      i += 1;
    }
    slice
  }

  pub fn .split_at[T](self: List[T], i: N32) -> (List[T], List[T]) {
    if i >= self.len() {
      return (self, []);
    }
    let prefix = [];
    while i != 0 and self.pop_front() is Some(value) {
      prefix.push_back(value);
      i -= 1;
    }
    (prefix, self)
  }

  pub fn .map[T, U, F*; fn F(T) -> U](List[T](l, buf, _end), f: F) -> List[U] {
    unsafe::erase(_end);
    let len = l;
    let cur;
    let result = ~cur;
    for _ in 0..l {
      let Buf(head, tail) = buf;
      buf = tail;
      let next;
      ~cur = Buf(f(head), ~next);
      ~next = ~cur;
    }
    unsafe::erase(buf);
    List(len, result, cur)
  }

  pub fn .filter[T?, F*; fn F(&T) -> Bool](self: List[T], pred: F) -> List[T] {
    let result = [];
    for value in self {
      if pred(&value) {
        result.push_back(value);
      }
    }
    result
  }

  pub fn .pop_front[T](&List[T](len, buf, _)) -> Option[T] {
    if len != 0 {
      len -= 1;
      let Buf(head, tail) = buf;
      buf = tail;
      Some(head)
    } else {
      None()
    }
  }

  pub fn .head_tail[T](List[T](len, buf, end)) -> Option[(T, List[T])] {
    if len != 0 {
      let Buf(head, tail) = buf;
      Some(head, List(len - 1, tail, end))
    } else {
      unsafe::erase((buf, end));
      None()
    }
  }

  pub impl concat[T]: Concat[List[T], List[T], List[T]] {
    fn concat(a: List[T], b: List[T]) -> List[T] {
      let List(a_len, a_buf, ~a_end) = a;
      let List(b_len, b_buf, ~b_end) = b;
      a_end = b_buf;
      List(a_len + b_len, a_buf, ~b_end)
    }
  }

  /// Append a value to the end of the list. `O(1)`
  /// ```vi
  /// let list = [1, 2, 3];
  /// list.push_back(4);
  /// list // [1, 2, 3, 4]
  /// ```
  pub fn .push_back[T](&list: &List[T], el: T) {
    list ++= [el];
  }

  /// Append a value to the beginning of the list. `O(1)`
  /// ```vi
  /// let list = [1, 2, 3];
  /// list.push_front(0);
  /// list // [0, 1, 2, 3]
  /// ```
  pub fn .push_front[T](&list: &List[T], el: T) {
    list = [el] ++ list;
  }

  /// Insert an element at position `i` in the list.
  /// ```vi
  /// let list = ["foo", "bar", "qux"]
  /// list.insert(2, "bar");
  /// list // ["foo", "bar", "baz", "qux"]
  /// ```
  /// If `i` is greater than the length of the list, the element will be added
  /// to the end.
  pub fn .insert[T](&list: &List[T], i: N32, el: T) {
    assert i < list.len() else {
      list.push_back(el);
    }
    let front = [];
    for _ in 0..i {
      front.push_back(list.pop_front().assume());
    }
    list = front ++ [el] ++ list;
  }

  pub fn .find[T, F*; fn F(&T) -> Bool](&self: &List[T], pred: F) -> Option[&T] {
    for &value in &self {
      if pred(&value) {
        break Some(&value);
      }
    } else {
      None()
    }
  }

  pub fn .contains[T; Eq[T]](&self: &List[T], &el: &T) -> Bool {
    List::find(&self, fn* (&e: &T) { e == el }) is Some(&_)
  }

  pub fn .join[T; Cast[T, String]](list: List[T], sep: String) -> String {
    if list.head_tail() is Some(head, tail) {
      let str = "{head}";
      for val in tail {
        str ++= "{sep}{val}";
      }
      str
    } else {
      ""
    }
  }

  /// Remove items from the beginning of the list as long as the predicate returns `true`.
  /// ```vi
  /// let list = [0, 1, 3, 5, 0, 6, 0, 2];
  /// list.drop_while(fn* (value: N32) { value <= 3 });
  /// list // [5, 0, 6, 0, 2]
  /// ```
  pub fn .drop_while[T?, F*; fn F(&T) -> Bool](&List[T](len, buf, _), pred: F) {
    while len != 0 {
      let Buf(head, tail) = buf;
      if !pred(&head) {
        // Assign buffer again to prevent cloning in the else case
        buf = Buf(head, tail);
        break;
      }
      buf = tail;
      len -= 1;
    }
  }

  /// Remove items from the beginning of the list as long as the predicate returns `true`.
  /// ```vi
  /// let list = [0, 1, 3, 5, 0, 6, 0, 2];
  /// list.trim_back_where(fn* (value: N32) { value <= 3 });
  /// list // [0, 1, 3, 5, 0, 6]
  /// ```
  pub fn .trim_back_where[T?, F*; fn F(&T) -> Bool](&self: &List[T], pred: F) {
    let trimmed = [];
    let ~trimming = true;
    for elem in self {
      let matches = pred(&elem);
      if !~trimming {
        trimmed.push_back(elem);
      }
      if !matches {
        ~trimming = false;
      }
    }
    self = trimmed;
  }

  pub impl show[T; Show[T]]: Show[List[T]] {
    fn show(&self: &List[T]) -> Show {
      let entries = [];
      for &value in &self {
        entries.push_back(value.show());
      }
      Show::List(entries)
    }
  }

  /// Stably sort the list in ascending order. `O(n log n)`
  /// ```vi
  /// let list = [3, 1, 6, 4, 7];
  /// list.sort();
  /// list // [1, 3, 4, 6, 7]
  /// ```
  pub fn .sort[T; Ord[T]](&list: &List[T]) {
    if list.len() > 1 {
      let len = list.len();
      let sorted = list.sort_prefix(len);
      unsafe::erase(list);
      list = sorted;
    }
  }

  fn .sort_prefix[T; Ord[T]](&list: &List[T], n: N32) -> List[T] {
    if n == 1 {
      [list.pop_front().assume()]
    } else {
      merge(sort_prefix(&list, n / 2), sort_prefix(&list, (n + 1) / 2))
    }
  }

  fn merge[T; Ord[T]](a: List[T], b: List[T]) -> List[T] {
    if a.len() == 0 or b.len() == 0 {
      return a ++ b;
    }
    let out = [];
    let x = a.pop_front().assume();
    let y = b.pop_front().assume();

    loop {
      if y < x {
        out.push_back(y);
        if b.head_tail() is Some(y_, b_) {
          y = y_;
          b = b_;
          continue;
        } else {
          out ++ [x] ++ a
        }
      } else {
        out.push_back(x);
        if a.head_tail() is Some(x_, a_) {
          x = x_;
          a = a_;
          continue;
        } else {
          out ++ [y] ++ b
        }
      }
    }
  }

  /// Checks whether the list is sorted in ascending order.
  /// ```vi
  /// [3, 1, 6, 4, 7].is_sorted() // false
  /// [1, 3, 4, 6, 7].is_sorted() // true
  /// ```
  pub fn .is_sorted[T; Ord[T]](&list: &List[T]) -> Bool {
    let iter_ref = list.iter_ref();
    assert iter_ref.advance() is Some(prev, iter_ref) else {
      return true;
    }
    for next in iter_ref {
      if prev > next {
        return false;
      }
      prev = next;
    }
    true
  }

  /// Iterate over the elements of the list.
  /// ```vi
  /// let list = [1, 0, 4, 6];
  /// for value in list {
  ///   io.println("{list}");
  /// }
  /// ```
  /// ```
  /// 1
  /// 0
  /// 4
  /// 6
  /// ```
  pub impl iter[T]: Cast[List[T], Iter[T]] {
    fn cast(self: List[T]) -> Iter[T] {
      Iter(self)
    }
  }

  pub struct* Iter[T](List[T]);

  pub mod Iter {
    pub impl iterator[T]: Iterator[Iter[T], T] {
      fn advance(Iter[T](List(len, buf, end))) -> Option[(T, Iter[T])] {
        if len != 0 {
          let Buf(head, tail) = buf;
          Some(head, Iter(List(len - 1, tail, end)))
        } else {
          unsafe::erase((buf, end));
          None()
        }
      }
    }

    /// Convert the remaining elements in this iterator back into a list. `O(1)`
    pub impl to_list[T]: Cast[Iter[T], List[T]] {
      fn cast(Iter[T](list)) -> List[T] {
        list
      }
    }
  }

  /// Iterate over the elements of the list by reference.
  /// ```vi
  /// let list = [0, 5, 3, 5];
  /// for &value in &list {
  ///   value += 1;
  /// }
  /// list // [1. 6. 4. 6]
  /// ```
  pub impl iter_ref[T]: Cast[&List[T], IterRef[T]] {
    fn cast(&List[T](len, buf, end)) -> IterRef[T] {
      IterRef(len, &buf, &(len, end))
    }
  }

  pub struct IterRef[T]((N32, &Buf[T], &(N32, ~Buf[T])));

  pub mod IterRef {
    pub impl iterator[T]: Iterator[IterRef[T], &T] {
      fn advance(IterRef[T](len, &buf, &full)) -> Option[(&T, IterRef[T])] {
        if len != 0 {
          let &Buf(head, tail) = &buf;
          Some(&head, IterRef(len - 1, &tail, &full))
        } else {
          None()
        }
      }
    }

    pub impl fork[T]: Fork[IterRef[T]];
    pub impl drop[T]: Drop[IterRef[T]];

    /// Convert this iterator into a reference to the remaining tail of the
    /// list. `O(1)`
    pub fn .tail[T](&IterRef[T](len, &buf, &(full_len, end))) -> &List[T] {
      full_len -= len;
      let ref = &List(len, buf, end);
      full_len += len;
      ref
    }
  }

  /// Collect the items of an iterator into a list.
  /// ```vi
  /// (0..6).collect[List, _, _]() // [0, 1, 2, 3, 4, 5]
  /// ```
  pub impl collect[T]: Collect[List[T], T] {
    fn collect[I; Iterator[I, T]](iter_ref: I) -> List[T] {
      let list = [];
      for value in iter_ref {
        list.push_back(value);
      }
      list
    }
  }

  /// Construct a list with the elements reversed.
  /// ```vi
  /// let list = [1, 2, 3, 4];
  /// list.reversed() // [4, 3, 2, 1]
  /// ```
  pub fn .reversed[T](self: List[T]) -> List[T] {
    let reversed = [];
    for value in self {
      reversed.push_front(value);
    }
    reversed
  }

  /// Reverse the elements of the list.
  /// ```vi
  /// let list = [1, 2, 3, 4];
  /// list.reverse();
  /// list // [4, 3, 2, 1]
  /// ```
  pub fn .reverse[T](&self: &List[T]) {
    self = self.reversed();
  }

  pub impl eq[T; Eq[T]]: Eq[List[T]] {
    fn eq(&a: &List[T], &b: &List[T]) -> Bool {
      if a.len() != b.len() {
        return false;
      }
      let a_iter = a.iter_ref();
      let b_iter = b.iter_ref();
      for &a in a_iter {
        let (&b, _b_iter) = b_iter.advance().assume();
        b_iter = _b_iter;
        if a != b {
          break false;
        }
      } else {
        true
      }
    }

    fn ne(&a: &List[T], &b: &List[T]) -> Bool {
      !(a == b)
    }
  }

  pub impl ord[T; Ord[T]]: Ord[List[T]] {
    fn cmp(&a: &List[T], &b: &List[T]) -> Ord {
      let a_iter = a.iter_ref();
      let b_iter = b.iter_ref();
      let ord = loop {
        match (a_iter.advance(), b_iter.advance()) {
          (None(), None()) { Ord::Eq() }
          (None(), Some(_)) { Ord::Lt() }
          (Some(_), None()) { Ord::Gt() }
          (Some(&a, _a_iter), Some(&b, _b_iter)) {
            (a_iter, b_iter) = (_a_iter, _b_iter);
            match a.cmp(&b) {
              Ord::Lt() { Ord::Lt() }
              Ord::Eq() {
                continue;
              }
              Ord::Gt() { Ord::Gt() }
            }
          }
        }
      };
      ord
    }

    fn lt(a: &List[T], b: &List[T]) -> Bool {
      Ord::lt_from_cmp(a, b)
    }

    fn le(a: &List[T], b: &List[T]) -> Bool {
      Ord::le_from_cmp(a, b)
    }
  }

  #[become(unsafe::duplicate)]
  pub impl fork[T+]: Fork[List[T]] {
    fn fork(&self: &List[T]) -> List[T] {
      let out = [];
      for &value in &self {
        out.push_back(value);
      }
      out
    }
  }

  #[become(unsafe::erase)]
  pub impl drop[T?]: Drop[List[T]] {
    fn drop(self: List[T]) {
      for _ in self {}
    }
  }
}
