
use data::Iterator::{Iterator, Collect};
use ops::{Cast, Concat, comparison::{Eq, Ord}, range::{Bound, Range}};

#[builtin = "List"]
pub struct List[T](pub.root N32, Buf[T], ~Buf[T]);

pub.root struct Buf[T](pub.root T, Buf[T]);

pub mod List {
  pub const empty[T]: List[T] = [];

  pub fn .len[T](&self: &List[T]) -> N32 {
    self.0
  }

  pub fn new[T*](len: N32, value: T) -> List[T] {
    let list = [];
    for _ in 0..len {
      list.push_back(value);
    }
    list
  }

  pub fn from_fn[T, F*; fn F() -> T](len: N32, f: F) -> List[T] {
    let list = [];
    for _ in 0..len {
      list.push_back(f());
    }
    list
  }

  pub fn .at[T](&List[T](len, *buf, _), i: N32) -> Option[&T] {
    if i >= len {
      let &_ = buf;
      return None();
    }
    for _ in 0..i {
      let &Buf(_, *tail) = buf;
      buf = tail;
    }
    let &Buf(*head, _) = buf;
    Some(head)
  }

  pub fn .get[T+](&self: &List[T], i: N32) -> Option[T] {
    self.at(i).as_fork()
  }

  pub fn .slice[T?, B1?, B2?; Bound[B1, N32], Bound[B2, N32]](
    self: List[T],
    Range[B1, B2](start, end),
  ) -> List[T] {
    // Underflow does not matter, still correct
    let end_index = self.len() - 1;
    let i = 0;
    let slice = [];

    while !start.left_of(&i) and self.pop_front() is Some(_) {
      i += 1;
    }
    if end.right_of(&end_index) {
      return self;
    }
    while end.right_of(&i) and self.pop_front() is Some(value) {
      slice.push_back(value);
      i += 1;
    }
    slice
  }

  pub fn .split_at[T](self: List[T], i: N32) -> (List[T], List[T]) {
    if i >= self.len() {
      return (self, []);
    }
    let prefix = [];
    while i != 0 and self.pop_front() is Some(value) {
      prefix.push_back(value);
      i -= 1;
    }
    (prefix, self)
  }

  pub fn .map[T, U, F*; fn F(T) -> U](List[T](l, buf, _end), f: F) -> List[U] {
    unsafe::erase(_end);
    let len = l;
    let cur;
    let result = ~cur;
    for _ in 0..l {
      let Buf(head, tail) = buf;
      buf = tail;
      let next;
      ~cur = Buf(f(head), ~next);
      ~next = ~cur;
    }
    unsafe::erase(buf);
    List(len, result, cur)
  }

  pub fn .filter[T?, F*; fn F(&T) -> Bool](self: List[T], pred: F) -> List[T] {
    let result = [];
    for value in self.iter() {
      if pred(&value) {
        result.push_back(value);
      }
    }
    result
  }

  pub fn .pop_front[T](&List[T](len, buf, _)) -> Option[T] {
    if len != 0 {
      len -= 1;
      let Buf(head, tail) = buf;
      buf = tail;
      Some(head)
    } else {
      None()
    }
  }

  pub fn .head_tail[T](List[T](len, buf, end)) -> Option[(T, List[T])] {
    if len != 0 {
      let Buf(head, tail) = buf;
      Some(head, List(len - 1, tail, end))
    } else {
      unsafe::erase((buf, end));
      None()
    }
  }

  pub impl concat[T]: Concat[List[T], List[T], List[T]] {
    fn concat(a: List[T], b: List[T]) -> List[T] {
      let List(a_len, a_buf, ~a_end) = a;
      let List(b_len, b_buf, ~b_end) = b;
      a_end = b_buf;
      List(a_len + b_len, a_buf, ~b_end)
    }
  }

  pub fn .push_back[T](&list: &List[T], el: T) {
    list ++= [el];
  }

  pub fn .push_front[T](&list: &List[T], el: T) {
    list = [el] ++ list;
  }

  pub fn .insert[T](&List[T](len, *buf, _), i: N32, el: T) {
    len += 1;
    for _ in 0..i {
      let &Buf(_, *tail) = buf;
      buf = tail;
    }
    let &buf = buf;
    buf = Buf(el, buf);
  }

  pub fn .find[T, F*; fn F(&T) -> Bool](&self: &List[T], pred: F) -> Option[&T] {
    for &value in self.iter_ref() {
      if pred(&value) {
        break Some(&value);
      }
    } else {
      None()
    }
  }

  pub fn .contains[T; Eq[T]](&self: &List[T], &el: &T) -> Bool {
    List::find(&self, fn* (&e: &T) { e == el }) is Some(&_)
  }

  pub fn .join[T; Cast[T, String]](list: List[T], sep: String) -> String {
    if list.head_tail() is Some(head, tail) {
      let str = "{head}";
      for val in tail.iter() {
        str ++= "{sep}{val}";
      }
      str
    } else {
      ""
    }
  }

  pub fn .drop_while[T?, F*; fn F(&T) -> Bool](&List[T](len, buf, _), pred: F) {
    while len != 0 {
      let Buf(head, tail) = buf;
      if !pred(&head) {
        // Assign buffer again to prevent cloning in the else case
        buf = Buf(head, tail);
        break;
      }
      buf = tail;
      len -= 1;
    }
  }

  pub fn .trim_back_where[T?, F*; fn F(&T) -> Bool](&self: &List[T], pred: F) {
    let trimmed = [];
    let ~trimming = true;
    for elem in self.iter() {
      let matches = pred(&elem);
      if !~trimming {
        trimmed.push_back(elem);
      }
      if !matches {
        ~trimming = false;
      }
    }
    self = trimmed;
  }

  pub impl show[T; Show[T]]: Show[List[T]] {
    fn show(&self: &List[T]) -> Show {
      let entries = [];
      for &value in self.iter_ref() {
        entries.push_back(value.show());
      }
      Show::List(entries)
    }
  }

  pub fn .sort[T; Ord[T]](&list: &List[T]) {
    if list.len() > 1 {
      let len = list.len();
      let sorted = list.sort_prefix(len);
      unsafe::erase(list);
      list = sorted;
    }
  }

  fn .sort_prefix[T; Ord[T]](&list: &List[T], n: N32) -> List[T] {
    if n == 1 {
      [list.pop_front().assume()]
    } else {
      merge(sort_prefix(&list, n / 2), sort_prefix(&list, (n + 1) / 2))
    }
  }

  fn merge[T; Ord[T]](a: List[T], b: List[T]) -> List[T] {
    if a.len() == 0 or b.len() == 0 {
      return a ++ b;
    }
    let out = [];
    let x = a.pop_front().assume();
    let y = b.pop_front().assume();

    loop {
      if y < x {
        out.push_back(y);
        if b.head_tail() is Some(y_, b_) {
          y = y_;
          b = b_;
          continue;
        } else {
          out ++ [x] ++ a
        }
      } else {
        out.push_back(x);
        if a.head_tail() is Some(x_, a_) {
          x = x_;
          a = a_;
          continue;
        } else {
          out ++ [y] ++ b
        }
      }
    }
  }

  pub fn .is_sorted[T; Ord[T]](&list: &List[T]) -> Bool {
    let iter_ref = list.iter_ref();
    let Some(prev, iter_ref) = iter_ref.advance() else {
      return true;
    };
    for next in iter_ref {
      if prev > next {
        return false;
      }
      prev = next;
    }
    true
  }
  pub struct IterRef[T]((N32, &Buf[T], &(N32, ~Buf[T])));

  pub fn .iter_ref[T](&List[T](len, buf, end)) -> IterRef[T] {
    IterRef(len, &buf, &(len, end))
  }

  pub mod IterRef {
    pub impl iterator[T]: Iterator[IterRef[T], &T] {
      fn advance(IterRef[T](len, &buf, &full)) -> Option[(&T, IterRef[T])] {
        if len != 0 {
          let &Buf(head, tail) = &buf;
          Some(&head, IterRef(len - 1, &tail, &full))
        } else {
          None()
        }
      }
    }

    pub impl fork[T]: Fork[IterRef[T]];
    pub impl drop[T]: Drop[IterRef[T]];

    pub fn .tail[T](&IterRef[T](len, &buf, &(full_len, end))) -> &List[T] {
      full_len -= len;
      let ref = &List(len, buf, end);
      full_len += len;
      ref
    }
  }

  pub struct* Iter[T](List[T]);

  pub fn .iter[T](self: List[T]) -> Iter[T] {
    Iter(self)
  }

  pub mod Iter {
    pub impl iterator[T]: Iterator[Iter[T], T] {
      fn advance(Iter[T](List(len, buf, end))) -> Option[(T, Iter[T])] {
        if len != 0 {
          let Buf(head, tail) = buf;
          Some(head, Iter(List(len - 1, tail, end)))
        } else {
          unsafe::erase((buf, end));
          None()
        }
      }
    }

    pub impl to_list[T]: Cast[Iter[T], List[T]] {
      fn cast(Iter[T](list)) -> List[T] {
        list
      }
    }
  }

  pub impl collect[T]: Collect[List[T], T] {
    fn collect[I; Iterator[I, T]](iter_ref: I) -> List[T] {
      let list = [];
      for value in iter_ref {
        list.push_back(value);
      }
      list
    }
  }

  pub fn .reversed[T](self: List[T]) -> List[T] {
    let reversed = [];
    for value in self.iter() {
      reversed.push_front(value);
    }
    reversed
  }

  pub fn .reverse[T](&self: &List[T]) {
    self = self.reversed();
  }

  pub impl eq[T; Eq[T]]: Eq[List[T]] {
    fn eq(&a: &List[T], &b: &List[T]) -> Bool {
      if a.len() != b.len() {
        return false;
      }
      let a_iter = a.iter_ref();
      let b_iter = b.iter_ref();
      for &a in a_iter {
        let (&b, _b_iter) = b_iter.advance().assume();
        b_iter = _b_iter;
        if a != b {
          break false;
        }
      } else {
        true
      }
    }

    fn ne(&a: &List[T], &b: &List[T]) -> Bool {
      !(a == b)
    }
  }

  pub impl ord[T; Ord[T]]: Ord[List[T]] {
    fn cmp(&a: &List[T], &b: &List[T]) -> Ord {
      let a_iter = a.iter_ref();
      let b_iter = b.iter_ref();
      let ord = loop {
        match (a_iter.advance(), b_iter.advance()) {
          (None(), None()) { Ord::Eq() }
          (None(), Some(_)) { Ord::Lt() }
          (Some(_), None()) { Ord::Gt() }
          (Some(&a, _a_iter), Some(&b, _b_iter)) {
            (a_iter, b_iter) = (_a_iter, _b_iter);
            match a.cmp(&b) {
              Ord::Lt() { Ord::Lt() }
              Ord::Eq() {
                continue;
              }
              Ord::Gt() { Ord::Gt() }
            }
          }
        }
      };
      ord
    }

    fn lt(a: &List[T], b: &List[T]) -> Bool {
      Ord::lt_from_cmp(a, b)
    }

    fn le(a: &List[T], b: &List[T]) -> Bool {
      Ord::le_from_cmp(a, b)
    }
  }

  #[become(unsafe::duplicate)]
  pub impl fork[T+]: Fork[List[T]] {
    fn fork(&self: &List[T]) -> List[T] {
      let out = [];
      for &value in self.iter_ref() {
        out.push_back(value);
      }
      out
    }
  }

  #[become(unsafe::erase)]
  pub impl drop[T?]: Drop[List[T]] {
    fn drop(self: List[T]) {
      for _ in self.iter() {}
    }
  }
}
