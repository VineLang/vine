
use data::Iterator;
use ops::{Cast, comparison::Ord};

pub struct* Map[K, V](Set[(K, V)]);

impl ord_entry[K, V; Ord[K]]: Ord[(K, V)] {
  fn cmp(&(a: K, _: V), &(b: K, _: V)) -> Ord {
    a.cmp(&b)
  }

  fn le(&(a: K, _: V), &(b: K, _: V)) -> Bool {
    a <= b
  }

  fn lt(&(a: K, _: V), &(b: K, _: V)) -> Bool {
    a < b
  }
}

pub mod Map[K, V; Ord[K]] {
  pub const empty[K, V]: Map[K, V] = Map(Set::empty);

  pub impl from_list[... K?, V?]: Cast[List[(K, V)], Map[K, V]] {
    fn cast(entries: List[(K, V)]) -> Map[K, V] {
      Map(entries as Set)
    }
  }

  pub fn .clear[... K?, V?](&self: &Map[K, V]) {
    self!.clear();
  }

  pub fn .len[K, V](&self: &Map[K, V]) -> N32 {
    self!.len()
  }

  pub fn .insert[... K?](&self: &Map[K, V], key: K, value: V) -> Option[V] {
    Option::map(self!.insert((key, value)), fn? ((_, v)) { v })
  }

  pub fn .has[...](&self: &Map[K, V], &key: &K) -> Bool {
    self!.has(&(key, *unsafe::eraser))
  }

  pub fn .at[...](&self: &Map[K, V], &key: &K) -> Option[&V] {
    Option::map(self!.at_eq(&(key, *unsafe::eraser)), fn? (&(_, v)) { &v })
  }

  pub fn .get[... V+](&self: &Map[K, V], &key: &K) -> Option[V] {
    Option::map(self!.at_eq(&(key, *unsafe::eraser)), fn? (&(_, v)) { v })
  }

  pub fn .at_or_insert[... K?, V?](&self: &Map[K, V], key: K, value: V) -> &V {
    let ~insert;
    let old = self.insert(key, ~insert);
    let value = old.or_use(value);
    let ref = &value;
    ~insert = value;
    ref
  }

  pub fn .get_or_insert[... K?, V*](&self: &Map[K, V], key: K, value: V) -> V {
    self.at_or_insert(key, value).*
  }

  pub fn .at_le[...](&self: &Map[K, V], &key: &K) -> Option[&(K, V)] {
    self!.at_le(&(key, *unsafe::eraser))
  }

  pub fn .get_le[... K+, V+](&self: &Map[K, V], &key: &K) -> Option[(K, V)] {
    self!.get_le(&(key, *unsafe::eraser))
  }

  pub fn .at_ge[...](&self: &Map[K, V], &key: &K) -> Option[&(K, V)] {
    self!.at_ge(&(key, *unsafe::eraser))
  }

  pub fn .get_ge[... K+, V+](&self: &Map[K, V], &key: &K) -> Option[(K, V)] {
    self!.get_ge(&(key, *unsafe::eraser))
  }

  pub fn .remove[... K?](&self: &Map[K, V], &key: &K) -> Option[V] {
    Option::map(self!.remove(&(key, *unsafe::eraser)), fn? ((_, v)) { v })
  }

  pub fn .remove_min[...](&self: &Map[K, V]) -> Option[(K, V)] {
    self!.remove_min()
  }

  pub fn .remove_max[...](&self: &Map[K, V]) -> Option[(K, V)] {
    self!.remove_max()
  }

  pub fn .iter[...](&self: &Map[K, V]) -> Iter[K, V] {
    Iter(self!.iter())
  }

  pub struct Iter[K, V](Set::Iter[(K, V)]);

  pub mod Iter[K, V] {
    pub impl iterator[...]: Iterator[Iter[K, V], &(K, V)] {
      fn advance(self: Iter[K, V]) -> Option[(&(K, V), Iter[K, V])] {
        unsafe::transmute(self!.advance())
      }
    }

    pub impl fork[...]: Fork[Iter[K, V]];
    pub impl drop[...]: Drop[Iter[K, V]];
  }

  pub fn .into_iter[...](self: Map[K, V]) -> IntoIter[K, V] {
    IntoIter(self!.into_iter())
  }

  pub struct* IntoIter[K, V](Set::IntoIter[(K, V)]);

  pub mod IntoIter[K, V] {
    pub impl iterator[...]: Iterator[IntoIter[K, V], (K, V)] {
      fn advance(self: IntoIter[K, V]) -> Option[((K, V), IntoIter[K, V])] {
        unsafe::transmute(self!.advance())
      }
    }
  }

  pub impl to_list[...]: Cast[Map[K, V], List[(K, V)]] {
    fn cast(self: Map[K, V]) -> List[(K, V)] {
      self! as List
    }
  }

  pub impl show[... ; Show[K], Show[V]]: Show[Map[K, V]] {
    fn show(&self: &Map[K, V]) -> Show {
      let entries = [];
      for &(key, value) in self.iter() {
        entries.push_back((key.show(), value.show()));
      }
      Show::Constructor("Map", Show::Object(entries))
    }
  }

  // TODO(#118): make private once tests can be written inline
  pub fn .balanced[...](&self: &Map[K, V]) -> Bool {
    self!.balanced()
  }
}
