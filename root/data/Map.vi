
use data::Iterator::{Iterator, Collect, Iterate};
use ops::{Cast, Concat, Index::{Index, IndexPlace, IndexSpace, IndexValue}, comparison::Ord};
use util::{eraser, transmute};

pub struct* Map[K, V](Set[(K, V)]);

impl ord_entry[K, V; Ord[K]]: Ord[(K, V)] {
  fn cmp(&(a: K, _: V), &(b: K, _: V)) -> Ord {
    a.cmp(&b)
  }

  fn le(&(a: K, _: V), &(b: K, _: V)) -> Bool {
    a <= b
  }

  fn lt(&(a: K, _: V), &(b: K, _: V)) -> Bool {
    a < b
  }
}

pub mod Map[K, V; Ord[K]] {
  pub const empty[K, V]: Map[K, V] = Map(Set::empty);

  pub impl from_list[... K?, V?]: Cast[List[(K, V)], Map[K, V]] {
    fn cast(entries: List[(K, V)]) -> Map[K, V] {
      Map(entries as Set)
    }
  }

  pub fn .clear[... K?, V?](&self: &Map[K, V]) {
    self!.clear();
  }

  pub fn .len[K, V](&self: &Map[K, V]) -> N32 {
    self!.len()
  }

  pub fn .insert[... K?](&self: &Map[K, V], key: K, value: V) -> Option[V] {
    Option::map(self!.insert((key, value)), fn? ((_, v)) { v })
  }

  pub impl [... K?, V?]: Concat[Map[K, V], Map[K, V], Map[K, V]] {
    fn concat(self: Map[K, V], other: Map[K, V]) -> Map[K, V] {
      Map(self! ++ other!)
    }
  }

  pub fn .has[...](&self: &Map[K, V], &key: &K) -> Bool {
    self!.has(&(key, *safe eraser))
  }

  pub fn .at[...](&self: &Map[K, V], &key: &K) -> Option[&V] {
    Option::map(self!.at_eq(&(key, *safe eraser)), fn? (&(_, v)) { &v })
  }

  pub fn .get[... V+](&self: &Map[K, V], &key: &K) -> Option[V] {
    Option::map(self!.at_eq(&(key, *safe eraser)), fn? (&(_, v)) { v })
  }

  pub fn .at_or_insert[... K?, V?](&self: &Map[K, V], key: K, value: V) -> &V {
    let loop insert;
    let old = self.insert(key, insert);
    let value = old.or_use(value);
    let ref = &value;
    insert = value;
    ref
  }

  pub fn .get_or_insert[... K?, V*](&self: &Map[K, V], key: K, value: V) -> V {
    self.at_or_insert(key, value).*
  }

  pub fn .at_le[...](&self: &Map[K, V], &key: &K) -> Option[&(K, V)] {
    self!.at_le(&(key, *safe eraser))
  }

  pub fn .get_le[... K+, V+](&self: &Map[K, V], &key: &K) -> Option[(K, V)] {
    self!.get_le(&(key, *safe eraser))
  }

  pub fn .at_ge[...](&self: &Map[K, V], &key: &K) -> Option[&(K, V)] {
    self!.at_ge(&(key, *safe eraser))
  }

  pub fn .get_ge[... K+, V+](&self: &Map[K, V], &key: &K) -> Option[(K, V)] {
    self!.get_ge(&(key, *safe eraser))
  }

  pub fn .remove[... K?](&self: &Map[K, V], &key: &K) -> Option[V] {
    Option::map(self!.remove(&(key, *safe eraser)), fn? ((_, v)) { v })
  }

  pub fn .remove_min[...](&self: &Map[K, V]) -> Option[(K, V)] {
    self!.remove_min()
  }

  pub fn .remove_max[...](&self: &Map[K, V]) -> Option[(K, V)] {
    self!.remove_max()
  }

  pub fn .map_values[... U, F*; fn F(&K, V) -> U](self: Map[K, V], f: F) -> Map[K, U] {
    Map(Set::map(
      self!,
      fn* ((k, v)) {
        let new_val = f(&k, v);
        (k, new_val)
      },
    ))
  }

  pub impl index[K, V]: Index[Map[K, V], K, V] {}

  pub impl index_value[K?, V+; Ord[K]]: IndexValue[Map[K, V], K, V];

  pub impl index_place[K?, V; Ord[K]]: IndexPlace[Map[K, V], K, V] {
    fn assume_at(&self: &Map[K, V], key: K) -> &V {
      self.at(&key).assume()
    }
  }

  pub impl index_space[K?, V?; Ord[K]]: IndexSpace[Map[K, V], K, V] {
    fn assume_set(&self: &Map[K, V], key: K, value: V) {
      self.insert(key, value);
    }
  }

  pub impl index_ref[K, V]: Index[Map[K, V], &K, V] {}

  pub impl index_value_ref[K+, V+; Ord[K]]: IndexValue[Map[K, V], &K, V];

  pub impl index_place_ref[K, V; Ord[K]]: IndexPlace[Map[K, V], &K, V] {
    fn assume_at(&self: &Map[K, V], &key: &K) -> &V {
      self.at(&key).assume()
    }
  }

  pub impl iter_ref[...]: Iterate[&Map[K, V], IterRef[K, V], &(K, V)] {
    fn iter(&self: &Map[K, V]) -> IterRef[K, V] {
      IterRef(self!.iter_ref())
    }
  }

  pub struct IterRef[K, V](Set::IterRef[(K, V)]);

  pub mod IterRef[K, V] {
    pub impl [...]: Iterator[IterRef[K, V], &(K, V)] {
      fn advance(self: IterRef[K, V]) -> Option[(&(K, V), IterRef[K, V])] {
        safe transmute(self!.advance())
      }
    }

    pub impl [...]: Fork[IterRef[K, V]];
    pub impl [...]: Drop[IterRef[K, V]];
  }

  pub impl iter[...]: Iterate[Map[K, V], Iter[K, V], (K, V)] {
    fn iter(self: Map[K, V]) -> Iter[K, V] {
      Iter(self!.iter())
    }
  }

  pub struct* Iter[K, V](Set::Iter[(K, V)]);

  pub mod Iter[K, V] {
    pub impl [...]: Iterator[Iter[K, V], (K, V)] {
      fn advance(self: Iter[K, V]) -> Option[((K, V), Iter[K, V])] {
        safe transmute(self!.advance())
      }
    }
  }

  pub fn .keys[...](&self: &Map[K, V]) -> Iterator::Map[IterRef[K, V], Key] {
    self.iter_ref().map(Key())
  }

  pub struct* Key();

  pub mod Key {
    pub impl [K, V]: fn Key(&(K, V)) -> &K {
      fn call(Key(), (&(key: K, _: V),)) -> &K {
        &key
      }
    }
  }

  pub fn .values[...](&self: &Map[K, V]) -> Iterator::Map[IterRef[K, V], Value] {
    self.iter_ref().map(Value())
  }

  pub struct* Value();

  pub mod Value {
    pub impl [K, V]: fn Value(&(K, V)) -> &V {
      fn call(Value(), (&(_: K, value: V),)) -> &V {
        &value
      }
    }
  }

  pub impl [K?, V?; Ord[K]]: Collect[Map[K, V], (K, V)] {
    fn collect[I; Iterator[I, (K, V)]](iter: I) -> Map[K, V] {
      Map(iter.collect[Set, (K, V), _]())
    }
  }

  pub impl to_list[...]: Cast[Map[K, V], List[(K, V)]] {
    fn cast(self: Map[K, V]) -> List[(K, V)] {
      self! as List
    }
  }

  pub impl [... ; Show[K], Show[V]]: Show[Map[K, V]] {
    fn show(&self: &Map[K, V]) -> Show {
      let entries = [];
      for &(key, value) in &self {
        entries.push_back((key.show(), value.show()));
      }
      Show::Constructor("Map", Show::Object(entries))
    }
  }

  // TODO(#118): make private once tests can be written inline
  pub fn .balanced[...](&self: &Map[K, V]) -> Bool {
    self!.balanced()
  }
}
