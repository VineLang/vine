
use #root::{derive::Tuple, ops::Cast, unsafe::transmute};

/// An extrinsic value logically representing a Vine value of type `T`.
/// The author of `T` is allowed to decide the representation of this type.
pub type Ext[T];

/// Conversion between `T` and `Ext[T]`.
pub trait Ext[T] {
  fn encode(value: T) -> Ext[T];
  fn .decode(value: Ext[T]) -> T;
}

pub mod Ext {
  #[manual]
  pub impl identity[T]: Ext[T] {
    fn encode(value: T) -> Ext[T] {
      transmute(value)
    }

    fn decode(value: Ext[T]) -> T {
      transmute(value)
    }
  }

  pub impl encode[T; Ext[T]]: Cast[T, Ext[T]] {
    fn cast(value: T) -> Ext[T] {
      Ext::encode(value)
    }
  }

  pub impl decode[T; Ext[T]]: Cast[Ext[T], T] {
    fn cast(value: Ext[T]) -> T {
      Ext::decode(value)
    }
  }

  pub impl n32: Ext[N32] = Ext::identity;
  pub impl f32: Ext[F32] = Ext::identity;
  pub impl f64: Ext[F64] = Ext::identity;
  pub impl io: Ext[IO] = Ext::identity;

  pub impl nil: Ext[()] {
    fn encode((): ()) -> Ext[()] {
      transmute(Ext::new_list())
    }

    fn decode(tup: Ext[()]) -> () {
      Ext::drop_list(transmute(tup))
    }
  }

  pub impl tuple[T, I, R; Tuple[T, I, R], Ext[I], Ext[R]]: Ext[T] {
    fn encode(tuple: T) -> Ext[T] {
      let (init, rest) = tuple as (I, R);
      let init = init as Ext;
      let rest = transmute[_, Ext[List[Ext[I]]]](rest as Ext);
      rest.push(init);

      transmute(rest)
    }

    fn decode(tuple: Ext[T]) -> T {
      let rest = transmute[_, Ext[List[Ext[I]]]](tuple);
      let init = rest.pop();

      (init as I, transmute[_, Ext[R]](rest) as R) as T
    }
  }

  pub impl string: Ext[String] {
    fn encode(s: String) -> Ext[String] {
      let ext = Ext::new_string();
      for c in s! {
        ext.push_char(c);
      }

      ext
    }

    fn decode(ext: Ext[String]) -> String {
      let str = "";
      for _ in 0..ext.len_str() {
        str!.push_front(ext.pop_char());
      }
      Ext::drop_str(ext)

      str
    }
  }

  pub fn new_string() -> Ext[String] {
    inline_ivy! () -> Ext[String] {
      str
      0 = @list_new(_ str)
    }
  }

  pub fn new_list[T]() -> Ext[List[T]] {
    inline_ivy! () -> Ext[List[T]] {
      list
      0 = @list_new(_ list)
    }
  }

  // TODO: mark unsafe
  pub fn drop_list[T](list: Ext[List[T]]) {
    inline_ivy! (list <- list) -> () {
      _
      list = @list_drop(_ _)
    }
  }

  // TODO: mark unsafe
  pub fn drop_str(str: Ext[String]) {
    inline_ivy! (str <- str) -> () {
      _
      str = @list_drop(_ _)
    }
  }

  pub fn .len_str(&self: &Ext[String]) -> N32 {
    inline_ivy! (str0 <- self, str1 -> self) -> N32 {
      len
      str0 = @list_len(len str1)
    }
  }

  pub fn .len_list[T](&self: &Ext[List[T]]) -> N32 {
    inline_ivy! (str0 <- self, str1 -> self) -> N32 {
      len
      str0 = @list_len(len str1)
    }
  }

  // TODO: mark unsafe
  pub fn .push_char(&self: &Ext[String], char: Char) {
    inline_ivy! (str0 <- self, char <- char, str1 -> self) -> () {
      _
      str0 = @list_push(char str1)
    };
  }

  // TODO: mark unsafe
  pub fn .pop_char(&self: &Ext[String]) -> Char {
    inline_ivy! (str0 <- self, str1 -> self) -> Char {
      char
      str0 = @list_pop(char str1)
    }
  }

  // TODO: mark unsafe
  pub fn .push[T](&self: &Ext[List[T]], t: T) {
    inline_ivy! (list0 <- self, t <- t, list1 -> self) -> () {
      _
      list0 = @list_push(t list1)
    };
  }

  // TODO: mark unsafe
  pub fn .pop[T](&self: &Ext[List[T]]) -> T {
    inline_ivy! (list0 <- self, list1 -> self) -> T {
      t
      list0 = @list_pop(t list1)
    }
  }
}
