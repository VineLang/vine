
use derive::{Composite, Struct};
use ops::Cast;
use util::transmute;

/// An extrinsic value logically representing a Vine value of type `T`.
/// The author of `T` is allowed to decide the representation of this type.
pub type Ext[T];

/// Conversion between `T` and `Ext[T]`.
#[builtin = "Ext"]
pub trait Ext[T] {
  fn encode(value: T) -> Ext[T];
  fn .decode(value: Ext[T]) -> T;
}

pub mod Ext {
  #[manual]
  pub unsafe impl identity[T]: Ext[T] {
    unsafe fn encode(value: T) -> Ext[T] {
      transmute(value)
    }

    unsafe fn decode(value: Ext[T]) -> T {
      transmute(value)
    }
  }

  pub impl encode[T; Ext[T]]: Cast[T, Ext[T]] {
    fn cast(value: T) -> Ext[T] {
      Ext::encode(value)
    }
  }

  pub impl decode[T; Ext[T]]: Cast[Ext[T], T] {
    fn cast(value: Ext[T]) -> T {
      Ext::decode(value)
    }
  }

  pub impl show[T; Ext[T], Show[T]]: Show[Ext[T]] {
    fn show(&self: &Ext[T]) -> Show {
      let t = self as T;
      let s = t.show();
      self = t as Ext;
      s
    }
  }

  pub impl n32: Ext[N32] = safe Ext::identity;
  pub impl f32: Ext[F32] = safe Ext::identity;
  pub impl f64: Ext[F64] = safe Ext::identity;
  pub impl char: Ext[Char] = safe Ext::identity;
  pub impl io: Ext[IO] = safe Ext::identity;

  pub impl nil: Ext[()] {
    fn encode(()) -> Ext[()] {
      safe transmute(Ext::new_list())
    }

    fn decode(tup: Ext[()]) -> () {
      safe Ext::drop_list(transmute(tup))
    }
  }

  pub impl empty: Ext[{}] {
    fn encode({}) -> Ext[{}] {
      safe transmute(Ext::new_list())
    }

    fn decode(obj: Ext[{}]) -> {} {
      safe Ext::drop_list(transmute(obj));
      {}
    }
  }

  pub impl composite[C, K, I, R; Composite[C, K, I, R], Ext[I], Ext[R]]: Ext[C] {
    fn encode(composite: C) -> Ext[C] {
      let (init, rest) = composite as (I, R);
      let init = init as Ext;
      let rest = safe transmute[Ext[R], Ext[List[I]]](rest as Ext);
      rest.push(init);

      safe transmute(rest)
    }

    fn decode(composite: Ext[C]) -> C {
      let rest = safe transmute[Ext[C], Ext[List[I]]](composite);
      let init = safe rest.pop();

      (init as I, safe transmute[Ext[List[I]], Ext[R]](rest) as R) as C
    }
  }

  pub impl list[T; Ext[T]]: Ext[List[T]] {
    fn encode(list: List[T]) -> Ext[List[T]] {
      let ext = Ext::new_list();

      for value in list {
        ext.push(value as Ext);
      }

      ext
    }

    fn decode(ext: Ext[List[T]]) -> List[T] {
      let list = [];

      for _ in 0..ext.len() {
        list.push_front(safe ext.pop() as T);
      }

      safe drop_list(ext);

      list
    }
  }

  #[basic]
  pub impl struct_[S, C; Struct[S, C], Ext[C]]: Ext[S] {
    fn encode(s: S) -> Ext[S] {
      safe transmute[Ext[C], Ext[S]](s as C as Ext)
    }

    fn decode(ext: Ext[S]) -> S {
      safe transmute[Ext[S], Ext[C]](ext) as C as S
    }
  }

  pub impl string: Ext[String];

  pub impl ref[T; Ext[T]]: Ext[&T] {
    fn encode(&ref: &T) -> Ext[&T] {
      let (v, s) = (ref as Ext, ~ref);
      safe inline_ivy! (v <- v, s <- s) -> Ext[&T] {
        out
        v = @encode_ref(s out)
      }
    }

    fn decode(ext: Ext[&T]) -> &T {
      let (v, s) = safe inline_ivy! (ext <- ext) -> (Ext[T], ~T) {
        tup(v s)
        ext = @decode_ref(v s)
      };
      &(v as T; s)
    }
  }

  fn new_list[T]() -> Ext[List[T]] {
    safe inline_ivy! () -> Ext[List[T]] {
      list
      0 = @list_new(_ list)
    }
  }

  fn .len[T](&list: &Ext[List[T]]) -> N32 {
    safe inline_ivy! (list0 <- list, list1 -> list) -> N32 {
      len
      list0 = @list_len(len list1)
    }
  }

  unsafe fn drop_list[T](list: Ext[List[T]]) {
    inline_ivy! (list <- list) -> () {
      _
      list = @list_drop(_ _)
    }
  }

  fn .push[T](&self: &Ext[List[T]], t: Ext[T]) {
    safe inline_ivy! (list0 <- self, t <- t, list1 -> self) -> () {
      _
      list0 = @list_push(t list1)
    };
  }

  unsafe fn .pop[T](&self: &Ext[List[T]]) -> Ext[T] {
    inline_ivy! (list0 <- self, list1 -> self) -> Ext[T] {
      t
      list0 = @list_pop(t list1)
    }
  }
}
