
use #root::{derive::{Composite, Struct}, ops::Cast, unsafe::transmute};

/// An extrinsic value logically representing a Vine value of type `T`.
/// The author of `T` is allowed to decide the representation of this type.
pub type Ext[T];

/// Conversion between `T` and `Ext[T]`.
pub trait Ext[T] {
  fn encode(value: T) -> Ext[T];
  fn .decode(value: Ext[T]) -> T;
}

pub mod Ext {
  #[manual]
  pub impl identity[T]: Ext[T] {
    fn encode(value: T) -> Ext[T] {
      transmute(value)
    }

    fn decode(value: Ext[T]) -> T {
      transmute(value)
    }
  }

  pub impl encode[T; Ext[T]]: Cast[T, Ext[T]] {
    fn cast(value: T) -> Ext[T] {
      Ext::encode(value)
    }
  }

  pub impl decode[T; Ext[T]]: Cast[Ext[T], T] {
    fn cast(value: Ext[T]) -> T {
      Ext::decode(value)
    }
  }

  pub impl bool: Ext[Bool] = Ext::identity;
  pub impl n32: Ext[N32] = Ext::identity;
  pub impl f32: Ext[F32] = Ext::identity;
  pub impl f64: Ext[F64] = Ext::identity;
  pub impl char: Ext[Char] = Ext::identity;
  pub impl io: Ext[IO] = Ext::identity;
  pub impl ext[T]: Ext[Ext[T]] = Ext::identity;

  pub impl nil: Ext[()] {
    fn encode((): ()) -> Ext[()] {
      transmute(Ext::new_list())
    }

    fn decode(tup: Ext[()]) -> () {
      Ext::drop_list(transmute(tup))
    }
  }

  pub impl composite[C, K, I, R; Composite[C, K, I, R], Ext[I], Ext[R]]: Ext[C] {
    fn encode(composite: C) -> Ext[C] {
      let (init, rest) = composite as (I, R);
      let init = init as Ext;
      let rest = transmute[Ext[R], Ext[List[I]]](rest as Ext);
      rest.push(init);

      transmute(rest)
    }

    fn decode(composite: Ext[C]) -> C {
      let rest = transmute[Ext[C], Ext[List[I]]](composite);
      let init = rest.pop();

      (init as I, transmute[Ext[List[I]], Ext[R]](rest) as R) as C
    }
  }

  pub impl list[T; Ext[T]]: Ext[List[T]] {
    fn encode(list: List[T]) -> Ext[List[T]] {
      let ext = Ext::new_list();

      for value in list {
        ext.push(value as Ext);
      }

      ext
    }

    fn decode(ext: Ext[List[T]]) -> List[T] {
      let list = [];

      for _ in 0..ext.len() {
        list.push_front(ext.pop() as T);
      }

      drop_list(ext);

      list
    }
  }

  #[basic]
  pub impl struct_[S, C; Struct[S, C], Ext[C]]: Ext[S] {
    fn encode(s: S) -> Ext[S] {
      transmute[Ext[C], Ext[S]](s as C as Ext)
    }

    fn decode(ext: Ext[S]) -> S {
      transmute[Ext[S], Ext[C]](ext) as C as S
    }
  }

  pub impl string: Ext[String];

  pub fn new_list[T]() -> Ext[List[T]] {
    inline_ivy! () -> Ext[List[T]] {
      list
      0 = @list_new(_ list)
    }
  }

  pub fn .len[T](&list: &Ext[List[T]]) -> N32 {
    inline_ivy! (list0 <- list, list1 -> list) -> N32 {
      len
      list0 = @list_len(len list1)
    }
  }

  // TODO: mark unsafe
  pub fn drop_list[T](list: Ext[List[T]]) {
    inline_ivy! (list <- list) -> () {
      _
      list = @list_drop(_ _)
    }
  }

  pub fn .push[T](&self: &Ext[List[T]], t: Ext[T]) {
    inline_ivy! (list0 <- self, t <- t, list1 -> self) -> () {
      _
      list0 = @list_push(t list1)
    };
  }

  // TODO: mark unsafe
  pub fn .pop[T](&self: &Ext[List[T]]) -> Ext[T] {
    inline_ivy! (list0 <- self, list1 -> self) -> Ext[T] {
      t
      list0 = @list_pop(t list1)
    }
  }

  /// Used to mark extrinsic values of an unknown type.
  pub type Unknown;

  /// Interprets `self` to an `Ext[N32]`, returning `Err(self)` on failure.
  pub fn .as_n32(self: Ext[Unknown]) -> Result[N32, Ext[Unknown]] {
    let is_n32 = inline_ivy! (ref0 <- self, ref1 -> self) -> Bool {
      is_n32
      ref0 = @is_n32(is_n32 ref1)
    };

    if is_n32 {
      Ok(transmute[Ext[Unknown], Ext[N32]](self) as N32)
    } else {
      Err(self)
    }
  }
}
