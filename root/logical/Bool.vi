
use ops::{Cast, bitwise::{BitAnd, BitOr, BitXor, Not}, comparison::{Eq, Ord}};

#[builtin = "Bool"]
pub type Bool;

pub mod Bool {
  pub impl : Fork[Bool] = unsafe::duplicate;
  pub impl : Drop[Bool] = unsafe::erase;

  pub impl : BitAnd[Bool, Bool, Bool] {
    fn bit_and(a: Bool, b: Bool) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @n32_and(b out) }
    }
  }

  pub impl : BitOr[Bool, Bool, Bool] {
    fn bit_or(a: Bool, b: Bool) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @n32_or(b out) }
    }
  }

  pub impl : BitXor[Bool, Bool, Bool] {
    fn bit_xor(a: Bool, b: Bool) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @n32_xor(b out) }
    }
  }

  #[builtin = "bool_not"]
  pub impl : Not[Bool, Bool] {
    fn not(a: Bool) -> Bool {
      inline_ivy! (a <- a) -> Bool { out a = @n32_eq(0 out) }
    }
  }

  pub impl : Eq[Bool] {
    fn eq(&a: &Bool, &b: &Bool) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @n32_eq(b out) }
    }

    fn ne(&a: &Bool, &b: &Bool) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @n32_ne(b out) }
    }
  }

  pub impl : Ord[Bool] {
    fn lt(&a: &Bool, &b: &Bool) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @n32_lt(b out) }
    }

    fn le(&a: &Bool, &b: &Bool) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @n32_le(b out) }
    }

    fn cmp(a: &Bool, b: &Bool) -> Ord {
      Ord::cmp_from_lt(a, b)
    }
  }

  pub impl to_string: Cast[Bool, String] {
    fn cast(self: Bool) -> String {
      if self {
        "true"
      } else {
        "false"
      }
    }
  }

  pub impl : Show[Bool] {
    fn show(&self: &Bool) -> Show {
      Show::Literal("{self}")
    }
  }

  pub impl to_n32: Cast[Bool, N32] = unsafe::transmute;
}
