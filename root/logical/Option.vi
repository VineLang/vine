
use ops::comparison::Eq;

#[builtin = "Option"]
pub enum* Option[T] {
  Some(T),
  None(),
}

pub mod Option {
  pub fn .map[T, U, F?; fn F(T) -> U](self: Option[T], f: F) -> Option[U] {
    match self {
      Some(val) { Some(f(val)) }
      None() { None() }
    }
  }

  pub fn .as_ref[T](&self: &Option[T]) -> Option[&T] {
    match &self {
      &Some(val) { Some(&val) }
      &None() { None() }
    }
  }

  pub fn .as_fork[T+](self: Option[&T]) -> Option[T] {
    match self {
      Some(&val) { Some(val) }
      None() { None() }
    }
  }

  pub fn .flatten[T](self: Option[Option[T]]) -> Option[T] {
    match self {
      Some(Some(val)) { Some(val) }
      _ { None() }
    }
  }

  pub fn .flat_map[T, U, F?; fn F(T) -> Option[U]](self: Option[T], f: F) -> Option[U] {
    self.map(f).flatten()
  }

  pub fn .or_option[T?](self: Option[T], default: Option[T]) -> Option[T] {
    match self {
      None() { default }
      x { x }
    }
  }

  pub fn .or_use[T?](self: Option[T], default: T) -> T {
    match self {
      Some(val) { val }
      None() { default }
    }
  }

  pub fn .assume[T](self: Option[T]) -> T {
    match self {
      Some(val) { val }
      None() { debug::error("`Option::assume` called on `None()`") }
    }
  }

  pub fn .take[T](&self: &Option[T]) -> Option[T] {
    let result = self;
    self = None();
    result
  }

  pub impl [T; Eq[T]]: Eq[Option[T]] {
    fn eq(a: &Option[T], b: &Option[T]) -> Bool {
      match (a, b) {
        (&None(), &None()) { true }
        (&Some(a), &Some(b)) { a == b }
        _ { false }
      }
    }

    fn ne(a: &Option[T], b: &Option[T]) -> Bool {
      !(a == b)
    }
  }

  pub impl [T; Show[T]]: Show[Option[T]];
}
