
use ops::Cast;

/// Swap the values in two references.
/// ```vi
/// let a = 1;
/// let b = 2;
/// swap(&a, &b);
/// a // 2
/// b // 1
/// ```
pub fn swap[T](&a: &T, &b: &T) {
  (a, b) = (b, a);
}

/// Update the value in a reference and return the old value.
/// ```vi
/// let data = 123;
/// let old = replace(&data, 456);
/// old // 123
/// data // 456
/// ```
pub fn replace[T](&a: &T, b: T) -> T {
  swap(&a, &b);
  b
}

pub fn black_box[T](value: T) -> T {
  inline_ivy! (value <- value) -> T { #[value] }
}

pub unsafe fn duplicate[T](&value: &T) -> T {
  inline_ivy! (x <- value, x1 -> value) -> T {
    x2
    x = dup(x1 x2)
  }
}

#[manual]
#[builtin = "duplicate"]
pub unsafe impl duplicate[T]: Fork[T] {
  unsafe fn fork(&self: &T) -> T {
    duplicate(&self)
  }
}

pub unsafe const eraser[T]: T = inline_ivy! () -> T { _ };

pub unsafe fn erase[T](value: T) {
  ~eraser = value;
}

#[manual]
#[builtin = "erase"]
pub unsafe impl erase[T]: Drop[T] {
  unsafe fn drop(self: T) {
    erase(self)
  }
}

pub unsafe fn move[T](&value: &T) -> T {
  replace(&value, eraser)
}

pub unsafe fn transmute[C, T](value: C) -> T {
  inline_ivy! (value <- value) -> T { value }
}

#[manual]
pub unsafe impl transmute[C, T]: Cast[C, T] {
  unsafe fn cast(value: C) -> T {
    transmute(value)
  }
}
