
/// Debugging-related utilities.
mod;

use ops::{Cast, Fn};
use util::{duplicate, erase, eraser};

pub mod Show;

/// Whether debug mode is enabled.
pub const enabled: Bool = debug_state() is Some(_);

#[frameless]
pub fn log[T; Cast[T, String]](msg: T) {
  let msg = msg as String;
  if debug_state() is Some(&state) {
    let &frame = state.stack.top().assume();
    state.io.print("[{frame.file}:{frame.line}:{frame.col}] {msg}\n")
  }
}

#[frameless]
pub fn backtrace() -> Option[&Stack] {
  if debug_state() is Some(&state) {
    Some(&state.stack)
  } else {
    None()
  }
}

#[frameless]
pub fn error[M, T; Cast[M, String]](msg: M) -> T {
  let msg = msg as String;
  if debug_state() is Some(&state) {
    state.io.print("ERROR: {msg}\n");
    for frame in state.stack {
      state.io.print("  @ {frame}\n");
    }
    safe erase(&state.io);
  }
  safe eraser
}

#[frameless]
pub fn error_with[M, T, U; Cast[M, String]](msg: M, ctx: T) -> U {
  safe erase(ctx);
  debug::error(msg)
}

#[frameless]
pub fn .dbg[T; Show[T]](value: T) -> T {
  if enabled {
    log(value.show())
  }
  value
}

#[frameless]
pub fn .dbg_msg[T; Show[T]](value: T, msg: String) -> T {
  if enabled {
    log("{msg} {value.show()}");
  }
  value
}

pub fn with_state[F](f: F) -> WithState[F] {
  WithState(if const debug::enabled {
    (debug_state().assume(), f)
  } else {
    f
  })
}

pub struct* WithState[F](if const debug::enabled { (&DebugState, F) } else { F });

pub mod WithState {
  pub impl [F, P, R; Fn[F, P, R]]: Fn[WithState[F], P, R] {
    fn call(WithState[F](inner), params: P) -> R {
      let ret;
      ~inner = if const debug::enabled {
        let inner: ~(&DebugState, F);
        let (state, f) = ~inner;
        swap(debug_state().assume(), state);
        ret = f.call(params);
        swap(debug_state().assume(), state);
        inner
      } else {
        let inner: ~F;
        let f = ~inner;
        ret = f.call(params);
        inner
      };
      ret
    }
  }
}

struct DebugState({ io: IO, stack: Stack });

#[builtin = "debug_state"]
fn debug_state() -> Option[&DebugState] {
  safe eraser
}

pub struct Stack((Bool, Frame), Stack);

pub mod Stack {
  pub impl : Fork[Stack] = safe duplicate;
  pub impl : Drop[Stack] = safe erase;

  use #root::data::Iterator;

  pub fn .top(&Stack((present, frame), _)) -> Option[&Frame] {
    if present {
      Some(&frame)
    } else {
      None()
    }
  }

  pub impl : Iterator[Stack, Frame] {
    fn advance(Stack((present, frame), rest)) -> Option[(Frame, Stack)] {
      if present {
        Some(frame, rest)
      } else {
        None()
      }
    }
  }
}

pub struct Frame(pub { path: List[String], file: String, line: N32, col: N32 });

pub mod Frame {
  pub impl : Fork[Frame] = safe duplicate;
  pub impl : Drop[Frame] = safe erase;

  pub impl to_string: Cast[Frame, String] {
    fn cast(Frame({ path, file, line, col })) -> String {
      "#{path.join("::")} ({file}:{line}:{col})"
    }
  }
}
