
/// Debugging-related utilities.
mod;

use ops::{Cast, Fn};

pub mod Show;

/// Whether debug mode is enabled.
pub const enabled: Bool = debug_state() is Some(_);

#[frameless]
pub fn log[T; Cast[T, String]](msg: T) {
  let msg = msg as String;
  if debug_state() is Some(&state) {
    let &frame = state.stack.top().assume();
    state.io.print("[{frame.file}:{frame.line}:{frame.col}] {msg}\n")
  }
}

#[frameless]
pub fn backtrace() -> Option[&Stack] {
  if debug_state() is Some(&state) {
    Some(&state.stack)
  } else {
    None()
  }
}

#[frameless]
pub fn error[M, T; Cast[M, String]](msg: M) -> T {
  let msg = msg as String;
  if debug_state() is Some(&state) {
    state.io.print("ERROR: {msg}\n");
    for frame in state.stack {
      state.io.print("  @ {frame}\n");
    }
  }
  unsafe::eraser
}

#[frameless]
pub fn error_with[M, T, U; Cast[M, String]](msg: M, ctx: T) -> U {
  unsafe::erase(ctx);
  debug::error(msg)
}

#[frameless]
pub fn .dbg[T; Show[T]](value: T) -> T {
  if enabled {
    log(value.show())
  }
  value
}

#[frameless]
pub fn .dbg_msg[T; Show[T]](value: T, msg: String) -> T {
  if enabled {
    log("{msg} {value.show()}");
  }
  value
}

#[cfg(!debug)]
pub mod debug {
  pub fn with_state[F](f: F) -> WithState[F] {
    WithState(f)
  }

  pub struct* WithState[F](F);

  pub mod WithState {
    pub impl call[F, P, R; Fn[F, P, R]]: Fn[WithState[F], P, R] {
      fn call(WithState[F](f), params: P) -> R {
        f.call(params)
      }
    }
  }
}

#[cfg(debug)]
pub mod debug {
  #[frameless]
  pub fn with_state[F](f: F) -> WithState[F] {
    WithState(debug_state().assume(), f)
  }

  pub struct* WithState[F]((&DebugState, F));

  pub mod WithState {
    pub impl call[F, P, R; Fn[F, P, R]]: Fn[WithState[F], P, R] {
      #[frameless]
      fn call(WithState[F](state, f), params: P) -> R {
        swap(debug_state().assume(), state);
        let ret = f.call(params);
        swap(debug_state().assume(), state);
        ret
      }
    }
  }
}

struct DebugState({ io: IO, stack: Stack });

#[builtin = "debug_state"]
fn debug_state() -> Option[&DebugState] {
  unsafe::eraser
}

pub struct Stack((Bool, Frame), Stack);

pub mod Stack {
  pub impl fork: Fork[Stack] = unsafe::duplicate;
  pub impl drop: Drop[Stack] = unsafe::erase;

  use #root::data::Iterator;

  pub fn .top(&Stack((present, frame), _)) -> Option[&Frame] {
    if present {
      Some(&frame)
    } else {
      None()
    }
  }

  pub impl iter: Iterator[Stack, Frame] {
    fn advance(Stack((present, frame), rest)) -> Option[(Frame, Stack)] {
      if present {
        Some(frame, rest)
      } else {
        None()
      }
    }
  }
}

pub struct Frame(pub { path: List[String], file: String, line: N32, col: N32 });

pub mod Frame {
  pub impl fork: Fork[Frame] = unsafe::duplicate;
  pub impl drop: Drop[Frame] = unsafe::erase;

  pub impl to_string: Cast[Frame, String] {
    fn cast(Frame({ path, file, line, col })) -> String {
      "#{path.join("::")} ({file}:{line}:{col})"
    }
  }
}
