
use comparison::Ord;
use data::Iterator;

pub trait Bound[B, T] {
  fn .left_of(self: &B, value: &T) -> Bool;
  fn .right_of(self: &B, value: &T) -> Bool;
}

pub mod Bound {
  #[builtin = "BoundUnbounded"]
  pub struct* Unbounded(pub);
  #[builtin = "BoundInclusive"]
  pub struct* Inclusive[T](pub T);
  #[builtin = "BoundExclusive"]
  pub struct* Exclusive[T](pub T);

  pub mod Unbounded {
    pub impl bound[T]: Bound[Unbounded, T] {
      fn left_of(&Unbounded(), _: &T) -> Bool {
        true
      }
      fn right_of(&Unbounded(), _: &T) -> Bool {
        true
      }
    }
  }

  pub mod Inclusive {
    pub impl bound[T; Ord[T]]: Bound[Inclusive[T], T] {
      fn left_of(&Inclusive[T](bound), &value: &T) -> Bool {
        bound <= value
      }
      fn right_of(&Inclusive[T](bound), &value: &T) -> Bool {
        value <= bound
      }
    }
  }

  pub mod Exclusive {
    pub impl bound[T; Ord[T]]: Bound[Exclusive[T], T] {
      fn left_of(&Exclusive[T](bound), &value: &T) -> Bool {
        bound < value
      }
      fn right_of(&Exclusive[T](bound), &value: &T) -> Bool {
        value < bound
      }
    }
  }
}

#[builtin = "Range"]
pub struct* Range[B1, B2](pub B1, B2);

pub mod Range {
  pub fn .contains[B1, B2, T; Bound[B1, T], Bound[B2, T]](&Range[B1, B2](start, end), &value: &T) -> Bool {
    start.left_of(&value) and end.right_of(&value)
  }

  use Bound::{Exclusive, Inclusive};

  pub trait Step[T] {
    fn .step(x: T) -> T;
  }

  pub mod Step {
    pub impl n32: Step[N32] {
      fn step(x: N32) -> N32 {
        x + 1
      }
    }

    pub impl i32: Step[I32] {
      fn step(x: I32) -> I32 {
        x + +1
      }
    }

    pub impl n64: Step[N64] {
      fn step(x: N64) -> N64 {
        x + 1[N64]
      }
    }
  }

  pub impl exclusive_iter[T*; Ord[T], Step[T]]: Iterator[Range[Inclusive[T], Exclusive[T]], T] {
    fn advance(Range[Inclusive[T], Exclusive[T]](Inclusive[T](start), end)) -> Option[
      (T, Range[Inclusive[T], Exclusive[T]]);
    ] {
      if end.right_of(&start) {
        Some(start, Range(Inclusive(start.step()), end))
      } else {
        None()
      }
    }
  }

  pub impl inclusive_iter[T*; Ord[T], Step[T]]: Cast[
    Range[Inclusive[T], Inclusive[T]], InclusiveIter[T];
  ] {
    fn cast(Range[Inclusive[T], Inclusive[T]](Inclusive(start), Inclusive(end))) -> InclusiveIter[T] {
      InclusiveIter(Some(start, end))
    }
  }

  pub struct InclusiveIter[T](Option[(T, T)]);

  pub mod InclusiveIter {
    pub impl iter[T*; Ord[T], Step[T]]: Iterator[InclusiveIter[T], T] {
      fn advance(InclusiveIter[T](state)) -> Option[(T, InclusiveIter[T])] {
        match state {
          None() { None() }
          Some(start, end) {
            if start < end {
              Some(start, InclusiveIter(Some(start.step(), end)))
            } else {
              Some(start, InclusiveIter(None()))
            }
          }
        }
      }
    }
  }
}
