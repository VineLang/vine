
use derive::Tuple;
use ops::arithmetic::Neg;

pub trait[T] Eq {
  #[builtin = "eq"]
  fn eq(a: &T, b: &T) -> Bool;

  #[builtin = "ne"]
  fn ne(a: &T, b: &T) -> Bool;
}

pub mod Eq {
  pub impl unary[T; Eq[T]]: Eq[(T,)] {
    fn eq(&(a: T,), &(b: T,)) -> Bool {
      a == b
    }

    fn ne(&(a: T,), &(b: T,)) -> Bool {
      a != b
    }
  }

  pub impl tuple[T, I, R; Tuple[T, I, R], Eq[I], Eq[R]]: Eq[T] {
    fn eq(&a: &T, &b: &T) -> Bool {
      let &(ai, ar) = &a as &(I, R);
      let &(bi, br) = &b as &(I, R);
      ai == bi and ar == br
    }

    fn ne(&a: &T, &b: &T) -> Bool {
      let &(ai, ar) = &a as &(I, R);
      let &(bi, br) = &b as &(I, R);
      ai != bi or ar != br
    }
  }

  pub impl ref[T; Eq[T]]: Eq[&T] {
    fn eq(&&a: &&T, &&b: &&T) -> Bool {
      a == b
    }

    fn ne(&&a: &&T, &&b: &&T) -> Bool {
      a != b
    }
  }
}

pub trait[T] Ord {
  fn .cmp(a: &T, b: &T) -> Ord;
  fn lt(a: &T, b: &T) -> Bool;
  fn le(a: &T, b: &T) -> Bool;
}

#[impl(Show)]
pub enum* Ord {
  Lt(),
  Eq(),
  Gt(),
}

pub mod Ord {
  pub impl : Neg[Ord, Ord] {
    fn neg(a: Ord) -> Ord {
      match a {
        Ord::Lt() { Ord::Gt() }
        Ord::Eq() { Ord::Eq() }
        Ord::Gt() { Ord::Lt() }
      }
    }
  }

  pub impl unary[T; Ord[T]]: Ord[(T,)] {
    fn cmp(&(a: T,), &(b: T,)) -> Ord {
      Ord::cmp(&a, &b)
    }

    fn lt(&(a: T,), &(b: T,)) -> Bool {
      a < b
    }

    fn le(&(a: T,), &(b: T,)) -> Bool {
      a <= b
    }
  }

  pub impl tuple[T, I, R; Tuple[T, I, R], Ord[I], Ord[R]]: Ord[T] {
    fn cmp(&a: &T, &b: &T) -> Ord {
      let &(ai, ar) = &a as &(I, R);
      let &(bi, br) = &b as &(I, R);
      match ai.cmp(&bi) {
        Ord::Lt() { Ord::Lt() }
        Ord::Gt() { Ord::Gt() }
        Ord::Eq() { ar.cmp(&br) }
      }
    }

    fn lt(a: &T, b: &T) -> Bool {
      Ord::lt_from_cmp(a, b)
    }

    fn le(a: &T, b: &T) -> Bool {
      Ord::le_from_cmp(a, b)
    }
  }

  pub impl ref[T; Ord[T]]: Ord[&T] {
    fn cmp(&&a: &&T, &&b: &&T) -> Ord {
      Ord::cmp(&a, &b)
    }

    fn lt(&&a: &&T, &&b: &&T) -> Bool {
      a < b
    }

    fn le(&&a: &&T, &&b: &&T) -> Bool {
      a <= b
    }
  }

  pub fn gt[T; Ord[T]](&a: &T, &b: &T) -> Bool {
    b < a
  }

  pub fn ge[T; Ord[T]](&a: &T, &b: &T) -> Bool {
    b <= a
  }

  pub fn lt_from_cmp[T; Ord[T]](&a: &T, &b: &T) -> Bool {
    a.cmp(&b) is Ord::Lt()
  }

  pub fn le_from_cmp[T; Ord[T]](&a: &T, &b: &T) -> Bool {
    !(a.cmp(&b) is Ord::Gt())
  }

  pub fn cmp_from_lt[T; Ord[T]](&a: &T, &b: &T) -> Ord {
    when {
      a < b { Ord::Lt() }
      a > b { Ord::Gt() }
      _ { Ord::Eq() }
    }
  }
}

pub trait[T] Lt {
  #[builtin = "lt"]
  fn .lt(a: &T, b: &T) -> Bool;
}

pub mod Lt {
  pub impl from_ord[T; Ord[T]]: Lt[T] {
    fn lt(a: &T, b: &T) -> Bool {
      Ord::lt(a, b)
    }
  }

  #[builtin = "gt"]
  pub fn .gt[T; Lt[T]](&a: &T, &b: &T) -> Bool {
    b < a
  }
}

pub trait[T] Le {
  #[builtin = "le"]
  fn .le(a: &T, b: &T) -> Bool;
}

pub mod Le {
  pub impl from_ord[T; Ord[T]]: Le[T] {
    fn le(a: &T, b: &T) -> Bool {
      Ord::le(a, b)
    }
  }

  #[builtin = "ge"]
  pub fn .ge[T; Le[T]](&a: &T, &b: &T) -> Bool {
    b <= a
  }
}
