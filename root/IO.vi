
use #root::ops::Cast;

/// A special primitive type used to interact with the outside world.
/// Values of this type cannot be explicitly constructed; instead,
/// an IO handle is passed in to `main` at the start of the program.
#[builtin = "IO"]
pub type IO;

pub mod IO {
  const eof: Char = N32::maximum as Char;

  /// Prints the given string to stdout with a trailing newline.
  pub fn .println(&io: &IO, str: String) {
    io.print(str);
    io.print_char('\n');
  }

  /// Prints the given string to stdout without a trailing newline.
  pub fn .print(&io: &IO, str: String) {
    for char in str {
      io.print_char(char);
    }
  }

  /// Prints the given character to stdout.
  pub fn .print_char(&io: &IO, char: Char) {
    inline_ivy! (io0 <- io, io1 -> io, char <- char) -> () { _
      io0 = @io_print_char(char io1)
    }
  }

  pub fn .print_bytes(&io: &IO, bytes: List[N32]) {
    for byte in bytes {
      io.print_byte(byte);
    }
  }

  pub fn .print_byte(&io: &IO, byte: N32) {
    inline_ivy! (io0 <- io, io1 -> io, byte <- byte) -> () { _
      io0 = @io_print_byte(byte io1)
    }
  }

  /// Flushes any buffered output to stdout.
  pub fn .flush(&io: &IO) {
    inline_ivy! (io0 <- io, io1 -> io) -> () { _
      io0 = @io_flush(_ io1)
    }
  }

  /// Prints a supplied prompt and then waits for a line of input in response.
  pub fn .prompt(&io: &IO, msg: String) -> Option[String] {
    io.print(msg);
    io.flush();
    io.read_line()
  }

  /// Reads a line from stdin.
  pub fn .read_line(&io: &IO) -> Option[String] {
    if io._read_char() is char and char != eof {
      Some(if char == '\n' {
        ""
      } else {
        let chars = [char];
        loop {
          char = io._read_char();
          if char != '\n' and char != eof {
            chars ++= [char];
            continue;
          }
        }
        String(chars)
      })
    } else {
      None()
    }
  }

  /// Reads all of the input from stdin as a string.
  pub fn .full_input(&io: &IO) -> String {
    let chars = [];
    loop {
      if io._read_char() is char and char != eof {
        chars ++= [char];
        continue;
      } else {
        String(chars)
      }
    }
  }

  /// Reads a UTF-8 code point from stdin, returning `None()` if nothing was
  /// read. If an invalid UTF-8 char is encountered, `Some(U+FFFD)` is returned.
  pub fn .read_char(&io: &IO) -> Option[Char] {
    if io._read_char() is char and char != eof {
      Some(char)
    } else {
      None()
    }
  }

  /// Reads a UTF-8 code point from stdin, returning `eof` if nothing was
  /// read. If an invalid UTF-8 char is encountered, `U+FFFD` is returned.
  fn ._read_char(&io: &IO) -> Char {
    inline_ivy! (io0 <- io, io1 -> io) -> Char {
      char
      io0 = @io_read_char(char io1)
    }
  }

  /// Reads a byte from stdin, returning `None()` if nothing was read.
  pub fn .read_byte(&io: &IO) -> Option[Char] {
    if io._read_byte() is byte and byte != eof {
      Some(byte)
    } else {
      None()
    }
  }

  /// Reads a byte from stdin, returning `eof` if nothing was read.
  fn ._read_byte(&io: &IO) -> Char {
    inline_ivy! (io0 <- io, io1 -> io) -> Char {
      byte
      io0 = @io_read_byte(byte io1)
    }
  }

  /// Waits for pending IO operations to complete and then returns `true`.
  /// This is useful for creating infinite IO loops.
  /// ```vi
  /// while io.forever() {
  ///   io.println("hi!");
  /// }
  /// ```
  pub fn .forever(&io: &IO) -> Bool {
    inline_ivy! (io0 <- io, io1 -> io) -> Bool {
      signal
      io0 = @io_ready(signal io1)
    }
  }

  type Args;

  mod Args {
    pub fn new(&io: &IO) -> Args {
      inline_ivy! (io0 <- io, io1 -> io) -> Args {
        args
        io0 = @io_args(args io1)
      }
    }

    pub fn .len(&self: &Args) -> N32 {
      inline_ivy! (args0 <- self, args1 -> self) -> N32 {
        len
        args0 = @args_len(len args1)
      }
    }

    pub fn .next(&self: &Args) -> String {
      inline_ivy! (args0 <- self, args1 -> self) -> ExtString {
        str
        args0 = @args_next(str args1)
      } as String
    }

    pub impl drop: Drop[Args] {
      fn drop(self: Args) {
        inline_ivy! (args <- self) -> () {
          _
          args = @args_drop(_ _)
        }
      }
    }
  }

  type ExtString;

  mod ExtString {
    pub fn .len(&self: &ExtString) -> N32 {
      inline_ivy! (str0 <- self, str1 -> self) -> N32 {
        len
        str0 = @str_len(len str1)
      }
    }

    pub fn .next(&self: &ExtString) -> Char {
      inline_ivy! (str0 <- self, str1 -> self) -> Char {
        char
        str0 = @str_next(char str1)
      }
    }

    pub impl drop: Drop[ExtString] {
      fn drop(self: ExtString) {
        inline_ivy! (str <- self) -> () {
          _
          str = @str_drop(_ _)
        }
      }
    }

    pub impl to_string: Cast[ExtString, String] {
      fn cast(self: ExtString) -> String {
        String(List::from_fn(self.len(), fn* () { self.next() }))
      }
    }
  }

  /// Returns the command-line arguments that vine was executed with.
  ///
  /// Unlike most other programming languages, the first argument _is not_ a
  /// path to the binary being executed, it is the first argument provided to
  /// the vine binary.
  /// ```vi
  /// // example.vi
  /// pub fn main(&io: &IO) {
  ///   let args = io.args();
  ///   io.println("args: {args.show()}");
  /// }
  ///
  /// // > vine run example.vi -- some cli args
  /// // ["some", "cli", "args"]
  /// ```
  pub fn .args(&io: &IO) -> List[String] {
    let args = Args::new(&io);
    List::from_fn(args.len(), fn* () { args.next() })
  }
}
