
use ops::{
  Cast,
  arithmetic::{Add, Div, Mul, Pow, Rem, Sub},
  bitwise::{BitAnd, BitOr, BitXor, Shl, Shr},
  comparison::{Eq, Ord},
};

/// Arbitrary-precision natural numbers.
/// ```vi
/// let x = 12[Nat] + 34[Nat];
/// x // 46
/// ```
#[builtin = "Nat"]
pub struct* Nat(List[N32]);

pub mod Nat {
  pub mod div_rem;

  pub fn from_parts(parts: List[N32]) -> Nat {
    parts.trim_back_where(fn* (&n: &N32) { n == 0 });
    Nat(parts)
  }

  pub fn .to_parts(Nat(parts)) -> List[N32] {
    parts
  }

  pub fn .is_zero(&Nat(parts)) -> Bool {
    parts.len() == 0
  }

  pub impl add_n32: Add[Nat, N32, Nat] {
    fn add(Nat(a), n: N32) -> Nat {
      let carry = n;
      for &a_num in a.iter_ref() {
        let new_carry = N32::add_high(a_num, carry) as N32;
        a_num += carry;
        carry = new_carry;
        if new_carry == 0 {
          break;
        }
      }
      if carry != 0 {
        a.push_back(carry);
      }
      Nat(a)
    }
  }

  pub impl add: Add[Nat, Nat, Nat] {
    fn add(Nat(a), Nat(b)) -> Nat {
      if a.len() < b.len() {
        swap(&a, &b);
      }

      let result = [];
      let carry = false;
      for b in b.iter() {
        let a = a.pop_front().assume();
        let ab = a + b;
        result.push_back(ab + carry as N32);
        carry = N32::add_high(a, b) | N32::add_high(ab, carry as N32);
      }
      while carry {
        let a = a.pop_front().or_use(0);
        result.push_back(a + 1);
        carry = a == N32::maximum;
      }

      Nat(result ++ a)
    }
  }

  pub impl sub: Sub[Nat, Nat, Nat] {
    fn sub(Nat(a), Nat(b)) -> Nat {
      if a.len() < b.len() {
        // underflow
        return 0[Nat];
      }

      let result = [];
      let ~trim = true;
      let fn push(n: N32) {
        if !~trim {
          result.push_back(n);
        }
        if n != 0 {
          ~trim = false;
        }
      }

      let borrow = false;
      for b in b.iter() {
        let a = a.pop_front().assume();
        let ab = a - b;
        push(ab - borrow as N32);
        borrow = (a < b) | (ab < borrow as N32);
      }
      while borrow {
        assert a.pop_front() is Some(a) else {
          // underflow
          return 0[Nat];
        }
        push(a - 1);
        borrow = a == 0;
      }

      if a.len() != 0 {
        ~trim = false;
      }

      Nat(result ++ a)
    }
  }

  pub impl mul_n32: Mul[Nat, N32, Nat] {
    fn mul(Nat(a), n: N32) -> Nat {
      if n == 0 {
        return 0[Nat];
      }
      let carry = 0;
      let result = [];
      for num in a.iter() {
        let N64(lo, hi) = N64::mul_n32_n32(num, n);
        hi += N32::add_high(lo, carry) as N32;
        lo += carry;
        result.push_back(lo);
        carry = hi;
      }
      if carry != 0 {
        result.push_back(carry);
      }
      Nat(result)
    }
  }

  pub impl mul: Mul[Nat, Nat, Nat] {
    fn mul(a: Nat, b: Nat) -> Nat {
      if a.is_zero() or b.is_zero() {
        return 0[Nat];
      }
      if a!.len() > b!.len() {
        swap(&a, &b);
      }
      let leading = [];
      let current = 0[Nat];
      for a_num in a!.iter() {
        let prod = b * a_num;
        current += prod;
        leading.push_back(current!.pop_front().or_use(0));
      }
      Nat(leading ++ current!)
    }
  }

  pub impl pow_n32: Pow[Nat, N32, Nat] {
    fn pow(base: Nat, exp: N32) -> Nat {
      Pow::pow_by_squaring(base, exp)
    }
  }

  pub impl div_n32: Div[Nat, N32, Nat] {
    fn div(a: Nat, d: N32) -> Nat {
      a.div_rem_n32(d).0
    }
  }

  pub impl rem_n32: Rem[Nat, N32, N32] {
    fn rem(a: Nat, d: N32) -> N32 {
      a.div_rem_n32(d).1
    }
  }

  pub fn .div_rem_n32(a: Nat, d: N32) -> (Nat, N32) {
    if d == 0 {
      return debug::error("Division by zero");
    }

    let nums = a!.reversed();

    assert nums.pop_front() is Some(leading_num) else {
      return (0[Nat], 0);
    }
    let q = [];
    let (qi, rem) = leading_num.div_rem(d);
    if qi != 0 {
      q.push_front(qi);
    }

    for a_num in nums.iter() {
      let cur = N64(a_num, rem);

      let (qi, ri) = N64::div_rem_n32(cur, d);

      q.push_front(qi as N32);
      rem = ri;
    }

    (Nat(q), rem)
  }

  pub impl div: Div[Nat, Nat, Nat] {
    fn div(a: Nat, d: Nat) -> Nat {
      a.div_rem(d).0
    }
  }

  pub impl rem: Rem[Nat, Nat, Nat] {
    fn rem(a: Nat, d: Nat) -> Nat {
      a.div_rem(d).1
    }
  }

  pub impl bit_and: BitAnd[Nat, Nat, Nat] {
    fn bit_and(a: Nat, b: Nat) -> Nat {
      let ~trim = true;
      let result = [];
      for (a, b) in a!.iter().zip(b!.iter()) {
        let num = a & b;
        if !~trim {
          result.push_back(num);
        }
        if num != 0 {
          ~trim = false;
        }
      }
      Nat(result)
    }
  }

  pub impl bit_or: BitOr[Nat, Nat, Nat] {
    fn bit_or(Nat(a), Nat(b)) -> Nat {
      let result = [];
      while a.len() != 0 and b.len() != 0 {
        result.push_back(a.pop_front().assume() | b.pop_front().assume());
      }
      Nat(result ++ a ++ b)
    }
  }

  pub impl bit_xor: BitXor[Nat, Nat, Nat] {
    fn bit_xor(Nat(a), Nat(b)) -> Nat {
      let ~trim = true;
      let result = [];
      while a.len() != 0 and b.len() != 0 {
        let num = a.pop_front().assume() ^ b.pop_front().assume();
        if !~trim {
          result.push_back(num);
        }
        if num != 0 {
          ~trim = false;
        }
      }
      if a.len() != 0 or b.len() != 0 {
        ~trim = false;
      }
      Nat(result ++ a ++ b)
    }
  }

  pub impl shl: Shl[Nat, N32, Nat] {
    fn shl(Nat(a), b: N32) -> Nat {
      let (leading_zeros, rem) = b.div_rem(32);
      if rem != 0 {
        let carry = 0;
        for &num in a.iter_ref() {
          let new_carry = num >> (32 - rem);
          num = num << rem | carry;
          carry = new_carry;
        }
        if carry != 0 {
          a.push_back(carry);
        }
      }
      Nat(List::new(leading_zeros, 0) ++ a)
    }
  }

  pub impl shr: Shr[Nat, N32, Nat] {
    fn shr(Nat(a), b: N32) -> Nat {
      let (trim_parts, rem) = b.div_rem(32);
      while trim_parts > 0 and a.pop_front() is Some(_) {
        trim_parts -= 1;
      }

      if rem != 0 and a.pop_front() is Some(carry) {
        carry = carry >> rem;
        for &num in a.iter_ref() {
          let new_carry = num >> rem;
          num = num << (32 - rem) | carry;
          carry = new_carry;
        }
        if carry != 0 {
          a.push_back(carry);
        }
      }
      Nat(a)
    }
  }

  pub impl from_n32: Cast[N32, Nat] {
    fn cast(n: N32) -> Nat {
      if n == 0 {
        Nat([])
      } else {
        Nat([n])
      }
    }
  }

  pub impl to_n32: Cast[Nat, N32] {
    fn cast(Nat(parts)) -> N32 {
      parts.pop_front().or_use(0)
    }
  }

  pub impl from_n64: Cast[N64, Nat] {
    fn cast(N64(lo, hi)) -> Nat {
      when {
        lo == 0 and hi == 0 { Nat([]) }
        hi == 0 { Nat([lo]) }
        _ { Nat([lo, hi]) }
      }
    }
  }

  pub impl to_n64: Cast[Nat, N64] {
    fn cast(Nat(parts)) -> N64 {
      let lo = parts.pop_front().or_use(0);
      let hi = parts.pop_front().or_use(0);
      N64(lo, hi)
    }
  }

  pub impl eq: Eq[Nat] {
    fn eq(&Nat(a), &Nat(b)) -> Bool {
      a == b
    }

    fn ne(&Nat(a), &Nat(b)) -> Bool {
      a != b
    }
  }

  pub impl ord: Ord[Nat] {
    fn cmp(&Nat(a), &Nat(b)) -> Ord {
      when {
        a.len() < b.len() { Ord::Lt() }
        a.len() > b.len() { Ord::Gt() }
        _ {
          let ord = Ord::Eq();
          for (x, y) in a.iter().zip(b.iter()) {
            ord = match x.cmp(&y) {
              Ord::Lt() { Ord::Lt() }
              Ord::Eq() { ord }
              Ord::Gt() { Ord::Gt() }
            }
          }
          ord
        }
      }
    }

    fn lt(&a: &Nat, &b: &Nat) -> Bool {
      a.cmp(&b) is Ord::Lt()
    }

    fn le(&a: &Nat, &b: &Nat) -> Bool {
      !(a.cmp(&b) is Ord::Gt())
    }
  }

  pub fn parse(str: String) -> Option[Nat] {
    if str.len() == 0 {
      return None();
    }
    let num = 0[Nat];
    for digit in str.iter() {
      if digit == '_' {
        continue;
      }
      if !('0' <= digit <= '9') {
        return None();
      }
      num *= 10;
      num += (digit - '0') as Nat;
    }
    Some(num)
  }

  pub impl to_string: Cast[Nat, String] {
    fn cast(n: Nat) -> String {
      if n.is_zero() {
        return "0";
      }
      let str = "";
      while !n.is_zero() {
        let (q, r) = n.div_rem_n32(10);
        str = ('0' + r) as String ++ str;
        n = q;
      }
      str
    }
  }

  pub impl show: Show[Nat] {
    fn show(&self: &Nat) -> Show {
      Show::Literal("{self}")
    }
  }

  pub fn .trailing_zeros(&Nat(parts)) -> N32 {
    let zeros = 0;
    for &part in parts.iter_ref() {
      zeros += N32::trailing_zeros(part);
      if part != 0 {
        break;
      }
    }
    zeros
  }

  pub fn .gcd(a: Nat, b: Nat) -> Nat {
    if a.is_zero() {
      return b;
    }
    if b.is_zero() {
      return a;
    }
    let a_zeros = a.trailing_zeros();
    a >>= a_zeros;
    let b_zeros = b.trailing_zeros();
    b >>= b_zeros;
    let common_zeros = N32::min(a_zeros, b_zeros);

    loop {
      if a > b {
        swap(&a, &b);
      }
      b -= a;
      if !b.is_zero() {
        b >>= b.trailing_zeros();
        continue;
      }
    }
    a << common_zeros
  }
}
