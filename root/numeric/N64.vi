
use ops::{
  Cast,
  arithmetic::{Add, Div, Mul, Pow, Rem, Sub},
  bitwise::{BitAnd, BitOr, BitXor, Shl, Shr},
  comparison::{Eq, Ord},
};

/// Natural numbers represented with 64 bits of precision.
/// ```vi
/// let x = 123456789[N64] + 9876543210[N64];
/// x // 9999999999
/// ```
/// `N64` values are always in the range `[0, 2^64) = [0, 18_446_744_073_709_551_616)`.
pub struct N64(pub N32, N32);

pub mod N64 {
  pub const maximum: N64 = N64(N32::maximum, N32::maximum);

  pub impl : Fork[N64] = unsafe::duplicate;
  pub impl : Drop[N64] = unsafe::erase;

  pub impl from_n32: Cast[N32, N64] {
    fn cast(val: N32) -> N64 {
      N64(val, 0)
    }
  }

  pub impl to_n32: Cast[N64, N32] {
    fn cast(N64(lo, _)) -> N32 {
      lo
    }
  }

  pub.numeric fn .hi(N64(_, hi)) -> N32 {
    hi
  }

  pub fn .is_zero(&N64(lo, hi)) -> Bool {
    lo | hi == 0
  }

  pub impl : Add[N64, N64, N64] {
    fn add(N64(a_lo, a_hi), N64(b_lo, b_hi)) -> N64 {
      let lo = a_lo + b_lo;
      let carry = N32::add_high(a_lo, b_lo) as N32;
      let hi = a_hi + b_hi + carry;
      N64(lo, hi)
    }
  }

  pub impl add_n32: Add[N64, N32, N64] {
    fn add(N64(a_lo, a_hi), b: N32) -> N64 {
      let lo = a_lo + b;
      let carry = N32::add_high(a_lo, b) as N32;
      let hi = a_hi + carry;
      N64(lo, hi)
    }
  }

  pub impl : Sub[N64, N64, N64] {
    fn sub(N64(a_lo, a_hi), N64(b_lo, b_hi)) -> N64 {
      let lo = a_lo - b_lo;
      let borrow = (a_lo < b_lo) as N32;
      let hi = a_hi - b_hi - borrow;
      N64(lo, hi)
    }
  }

  pub impl sub_n32: Sub[N64, N32, N64] {
    fn sub(N64(a_lo, a_hi), b: N32) -> N64 {
      let lo = a_lo - b;
      let borrow = (a_lo < b) as N32;
      let hi = a_hi - borrow;
      N64(lo, hi)
    }
  }

  pub impl : Mul[N64, N64, N64] {
    fn mul(N64(a_lo, a_hi), N64(b_lo, b_hi)) -> N64 {
      let lo = a_lo * b_lo;
      let ll = N32::mul_high(a_lo, b_lo);
      let lh = a_lo * b_hi;
      let hl = a_hi * b_lo;
      let hi = ll + lh + hl;
      N64(lo, hi)
    }
  }

  pub impl mul_n32: Mul[N64, N32, N64] {
    fn mul(N64(a_lo, a_hi), b: N32) -> N64 {
      N64(a_lo * b, N32::mul_high(a_lo, b) + a_hi * b)
    }
  }

  pub fn .mul_n32_n32(a: N32, b: N32) -> N64 {
    N64(a * b, N32::mul_high(a, b))
  }

  pub impl div_n32: Div[N64, N32, N64] {
    fn div(a: N64, b: N32) -> N64 {
      a.div_rem_n32(b).0
    }
  }

  pub impl rem_n32: Rem[N64, N32, N32] {
    fn rem(a: N64, b: N32) -> N32 {
      a.div_rem_n32(b).1
    }
  }

  pub fn .div_rem_n32(N64(al, ah), d: N32) -> (N64, N32) {
    let qh = ah / d;
    ah %= d;
    let ql = 0;
    while ah != 0 {
      let m = (N32::maximum / d) * ah;
      ql += m;
      N64(al, ah) -= N64::mul_n32_n32(m, d);
    }
    ql += al / d;
    al %= d;
    (N64(ql, qh), al)
  }

  pub impl : Div[N64, N64, N64] {
    fn div(a: N64, d: N64) -> N64 {
      a.div_rem(d).0
    }
  }

  pub impl : Rem[N64, N64, N64] {
    fn rem(a: N64, d: N64) -> N64 {
      a.div_rem(d).1
    }
  }

  // Division by Knuth style long division.
  pub fn .div_rem(a: N64, d: N64) -> (N64, N64) {
    if d.is_zero() {
      return debug::error("Division by zero");
    }
    if a < d {
      return (0[N64], a);
    }

    if d.hi() == 0 {
      let (q, r32) = a.div_rem_n32(d as N32);
      return (q, r32 as N64);
    }

    let shift = d.hi().leading_zeros();

    let d_norm = d << shift;
    let N64(d_norm_lo, d_norm_hi) = d_norm;

    let N64(a_norm_lo, a_norm_mid) = a << shift;
    let a_norm_hi = a.hi() >> (31 - shift) >> 1;

    let top = N64(a_norm_mid, a_norm_hi);
    let (quot, rem) = top.div_rem_n32(d_norm_hi);

    while quot.hi() != 0 or quot * d_norm_lo > N64(a_norm_lo, rem) {
      quot -= 1;
      if N32::add_high(rem, d_norm_hi) {
        break;
      }
      rem += d_norm_hi;
    }

    let rem_norm = N64(a_norm_lo, a_norm_mid) - d_norm * quot as N32;
    let rem = rem_norm >> shift;
    (quot, rem)
  }

  pub impl : BitAnd[N64, N64, N64] {
    fn bit_and(N64(al, ah), N64(bl, bh)) -> N64 {
      N64(al & bl, ah & bh)
    }
  }

  pub impl : BitOr[N64, N64, N64] {
    fn bit_or(N64(al, ah), N64(bl, bh)) -> N64 {
      N64(al | bl, ah | bh)
    }
  }

  pub impl : BitXor[N64, N64, N64] {
    fn bit_xor(N64(al, ah), N64(bl, bh)) -> N64 {
      N64(al ^ bl, ah ^ bh)
    }
  }

  pub impl : Shl[N64, N32, N64] {
    fn shl(N64(al, ah), bits: N32) -> N64 {
      if bits & 32 != 0 {
        N64(0, al << bits)
      } else {
        N64(al << bits, ah << bits | al >> (31 - bits) >> 1)
      }
    }
  }

  pub impl : Shr[N64, N32, N64] {
    fn shr(N64(al, ah), bits: N32) -> N64 {
      if bits & 32 != 0 {
        N64(ah >> bits, 0)
      } else {
        N64(al >> bits | ah << (31 - bits) << 1, ah >> bits)
      }
    }
  }

  pub impl : Eq[N64] {
    fn eq(&N64(al, ah), &N64(bl, bh)) -> Bool {
      al == bl and ah == bh
    }

    fn ne(&N64(al, ah), &N64(bl, bh)) -> Bool {
      al != bl or ah != bh
    }
  }

  pub impl : Ord[N64] {
    fn lt(&N64(al, ah), &N64(bl, bh)) -> Bool {
      ah < bh or ah == bh and al < bl
    }

    fn le(&N64(al, ah), &N64(bl, bh)) -> Bool {
      ah < bh or ah == bh and al <= bl
    }

    fn cmp(a: &N64, b: &N64) -> Ord {
      Ord::cmp_from_lt(a, b)
    }
  }

  pub fn .min(a: N64, b: N64) -> N64 {
    if a < b {
      a
    } else {
      b
    }
  }

  pub fn .max(a: N64, b: N64) -> N64 {
    if a > b {
      a
    } else {
      b
    }
  }

  pub fn parse(str: String) -> Option[N64] {
    if str.len() == 0 {
      return None();
    }
    let num = 0[N64];
    for digit in str {
      if digit == '_' {
        continue;
      }
      if !('0' <= digit <= '9') {
        return None();
      }
      num *= 10[N64];
      num += (digit - '0') as N64;
    }
    Some(num)
  }

  pub impl to_string: Cast[N64, String] {
    fn cast(n: N64) -> String {
      if !n.is_zero() {
        let str = "";
        while !n.is_zero() {
          let (q, r) = N64::div_rem_n32(n, 10);
          str = ['0' + r] as String ++ str;
          n = q;
        }
        str
      } else {
        "0"
      }
    }
  }

  pub impl : Show[N64] {
    fn show(&n: &N64) -> Show {
      Show::Literal("{n}")
    }
  }

  pub impl : Pow[N64, N32, N64] {
    fn pow(base: N64, exp: N32) -> N64 {
      Pow::pow_by_squaring(base, exp)
    }
  }

  pub fn .log_n32(n: N64, b: N32) -> N32 {
    let l = 0;
    while b as N64 <= n {
      l += 1;
      let (d, _) = n.div_rem_n32(b);
      n = d;
    }
    l
  }

  pub fn diff(a: N64, b: N64) -> N64 {
    if a > b {
      a - b
    } else {
      b - a
    }
  }

  pub impl to_n64: Cast[Bool, N64] {
    fn cast(b: Bool) -> N64 {
      N64(unsafe::transmute(b), 0)
    }
  }
}
