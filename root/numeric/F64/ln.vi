
use common::{ln2_hi, ln2_lo};

// Adapted from https://go.dev/src/math/log.go.
//
// ====================================================
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// ====================================================

// The original C code, the long comment, and the constants
// below are from FreeBSD's /usr/src/lib/msun/src/e_log.c
// and came with this notice. The go code is a simpler
// version of the original C.
//
// ====================================================
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================
//
// __ieee754_log(x)
// Return the logarithm of x
//
// Method :
//   1. Argument Reduction: find k and f such that
//			x = 2**k * (1+f),
//	   where  sqrt(2)/2 < 1+f < sqrt(2) .
//
//   2. Approximation of log(1+f).
//	Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
//		 = 2s + 2/3 s**3 + 2/5 s**5 + .....,
//	     	 = 2s + s*R
//      We use a special Remex algorithm on [0,0.1716] to generate
//	a polynomial of degree 14 to approximate R.  The maximum error
//	of this polynomial approximation is bounded by 2**-58.45. In
//	other words,
//		        2      4      6      8      10      12      14
//	    R(z) ~ L1*s +L2*s +L3*s +L4*s +L5*s  +L6*s  +L7*s
//	(the values of L1 to L7 are listed in the program) and
//	    |      2          14          |     -58.45
//	    | L1*s +...+L7*s    -  R(z) | <= 2
//	    |                             |
//	Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
//	In order to guarantee error in log below 1ulp, we compute log by
//		log(1+f) = f - s*(f - R)		(if f is not too large)
//		log(1+f) = f - (hfsq - s*(hfsq+R)).	(better accuracy)
//
//	3. Finally,  log(x) = k*Ln2 + log(1+f).
//			    = k*Ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*Ln2_lo)))
//	   Here Ln2 is split into two floating point number:
//			Ln2_hi + Ln2_lo,
//	   where n*Ln2_hi is always exact for |n| < 2000.
//
// Special cases:
//	log(x) is NaN with signal if x < 0 (including -INF) ;
//	log(+INF) is +INF; log(0) is -INF with signal;
//	log(NaN) is that NaN with no signal.
//
// Constants:
// The hexadecimal values are the intended ones for the following
// constants. The decimal values may be used, provided that the
// compiler will convert from decimal to binary accurately enough
// to produce the hexadecimal values shown.

const sqrt2: F64 = 1.41421356237309504[F64];

/// Ln returns the natural logarithm.
///
/// Special cases are:
///
///	ln(+Inf) = +Inf
///	ln(0) = -Inf
///	ln(x < 0) = NaN
///	ln(NaN) = NaN
///
/// Accuracy:
///	  according to an error analysis, the error is always less than
///	  1 ulp (unit in the last place).
pub fn .ln(x: F64) -> F64 {
  const l1: F64 = 6.666666666666735130e-01[F64];
  const l2: F64 = 3.999999999940941908e-01[F64];
  const l3: F64 = 2.857142874366239149e-01[F64];
  const l4: F64 = 2.222219843214978396e-01[F64];
  const l5: F64 = 1.818357216161805012e-01[F64];
  const l6: F64 = 1.531383769920937332e-01[F64];
  const l7: F64 = 1.479819860511658591e-01[F64];

  when {
    x.is_nan() or x == F64::inf { x }
    x < 0.0[F64] { F64::nan }
    x == 0.0[F64] { F64::neg_inf }
    _ {
      let { frac, exp } = common::fraction_exponent(x);
      if frac < sqrt2 / 2.0[F64] {
        frac *= 2.0[F64]
        exp -= +1
      }
      let f = frac - 1.0[F64];
      let k = exp as F64;

      // compute
      let s = f / (2.0[F64] + f);
      let s2 = s * s;
      let s4 = s2 * s2;
      let t1 = s2 * (l1 + s4 * (l3 + s4 * (l5 + s4 * l7)));
      let t2 = s4 * (l2 + s4 * (l4 + s4 * l6));
      let R = t1 + t2;
      let half_f_squared = 0.5[F64] * f * f;
      k * ln2_hi - ((half_f_squared - (s * (half_f_squared + R) + k * ln2_lo)) - f)
    }
  }
}
