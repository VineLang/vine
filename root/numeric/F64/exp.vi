
// Adapted from https://go.dev/src/math/exp.go.
//
// ====================================================
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// ====================================================

// The original C code, the long comment, and the constants
// below are from FreeBSD's /usr/src/lib/msun/src/e_exp.c
// and came with this notice.
//
// ====================================================
// Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
//
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================
//
//
// exp(x)
// Returns the exponential of x.
//
// Method
//   1. Argument reduction:
//      Reduce x to an r so that |r| <= 0.5*ln2 ~ 0.34658.
//      Given x, find r and integer k such that
//
//               x = k*ln2 + r,  |r| <= 0.5*ln2.
//
//      Here r will be represented as r = hi-lo for better
//      accuracy.
//
//   2. Approximation of exp(r) by a special rational function on
//      the interval [0,0.34658]:
//      Write
//          R(r**2) = r*(exp(r)+1)/(exp(r)-1) = 2 + r*r/6 - r**4/360 + ...
//      We use a special Remez algorithm on [0,0.34658] to generate
//      a polynomial of degree 5 to approximate R. The maximum error
//      of this polynomial approximation is bounded by 2**-59. In
//      other words,
//          R(z) ~ 2.0 + P1*z + P2*z**2 + P3*z**3 + P4*z**4 + P5*z**5
//      (where z=r*r, and the values of P1 to P5 are listed below)
//      and
//          |                  5          |     -59
//          | 2.0+P1*z+...+P5*z   -  R(z) | <= 2
//          |                             |
//      The computation of exp(r) thus becomes
//                             2*r
//              exp(r) = 1 + -------
//                            R - r
//                                 r*R1(r)
//                     = 1 + r + ----------- (for better accuracy)
//                                2 - R1(r)
//      where
//                               2       4             10
//              R1(r) = r - (P1*r  + P2*r  + ... + P5*r   ).
//
//   3. Scale back to obtain exp(x):
//      From step 1, we have
//         exp(x) = 2**k * exp(r)
//
//
// Misc. info.
//      For IEEE double
//          if x >  7.09782712893383973096e+02 then exp(x) overflow
//          if x < -7.45133219101941108420e+02 then exp(x) underflow

const overflow: F64 = 7.09782712893383973096e+02[F64];
const underflow: F64 = -7.45133219101941108420e+02[F64];
const near_zero: F64 = 1.0[F64] / (1 << 28) as F64;

use common::{ln2_hi, ln2_lo, log2e};

/// Computes the exponential of a floating-point number.
///
/// Special cases:
///      exp(INF) is INF, exp(NaN) is NaN;
///      exp(-INF) is 0, and
///      for finite argument, only exp(0)=1 is exact.
///
/// Accuracy:
///      The error is always less than 1 ulp (unit of least precision).
pub fn .exp(f: F64) -> F64 {
  when {
    f.is_nan() { f }
    f > overflow { F64::inf }
    f < underflow { 0.0[F64] }
    -near_zero < f < near_zero { 1.0[F64] + f }
    _ {
      // argument reduction; x = r×lg(e) + k with |r| ≤ ln(2)/2.
      // computed as r = hi - lo for extra precision.
      let k = if f < 0.0[F64] {
        (log2e * f - 0.5[F64]) as I32
      } else {
        (log2e * f + 0.5[F64]) as I32
      };
      let hi = f - k as F64 * ln2_hi;
      let lo = k as F64 * ln2_lo;

      exp_poly_approximation(hi, lo, k)
    }
  }
}

const p1: F64 = 1.66666666666666657415e-01[F64];
const p2: F64 = -2.77777777770155933842e-03[F64];
const p3: F64 = 6.61375632143793436117e-05[F64];
const p4: F64 = -1.65339022054652515390e-06[F64];
const p5: F64 = 4.13813679705723846039e-08[F64];

fn exp_poly_approximation(hi: F64, lo: F64, k: I32) -> F64 {
  let r = hi - lo;
  let t = r * r;
  let c = r - t * (p1 + t * (p2 + t * (p3 + t * (p4 + t * p5))));
  let y = 1.0[F64] - ((lo - (r * c) / (2.0[F64] - c)) - hi);
  return common::apply_exponent(y, k);
}
