
use ops::{
  Cast,
  arithmetic::{Add, Div, Mul, Neg, Pos, Pow, Rem, Sub},
  bitwise::{BitAnd, BitOr, BitXor, Not, Shl, Shr},
  comparison::{Eq, Ord},
};
use util::{duplicate, erase, transmute};

#[builtin = "I32"]
pub type I32;

pub mod I32 {
  pub const maximum: I32 = +0x7fffffff;
  pub const minimum: I32 = -0x7fffffff;

  pub impl : Fork[I32] = safe duplicate;
  pub impl : Drop[I32] = safe erase;

  pub impl : Default[I32] {
    const default: I32 = +0;
  }

  pub impl : Add[I32, I32, I32] {
    fn add(a: I32, b: I32) -> I32 {
      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @n32_add(b out) }
    }
  }

  pub impl : Sub[I32, I32, I32] {
    fn sub(a: I32, b: I32) -> I32 {
      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @n32_sub(b out) }
    }
  }

  pub impl : Mul[I32, I32, I32] {
    fn mul(a: I32, b: I32) -> I32 {
      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @n32_mul(b out) }
    }
  }

  pub impl : Pow[I32, N32, I32] {
    fn pow(base: I32, exp: N32) -> I32 {
      Pow::pow_by_squaring(base, exp)
    }
  }

  pub impl : Div[I32, I32, I32] {
    fn div(a: I32, b: I32) -> I32 {
      if debug::enabled and b == +0 {
        return debug::error("division by zero");
      }

      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @i32_div(b out) }
    }
  }

  pub impl : Rem[I32, I32, I32] {
    fn rem(a: I32, b: I32) -> I32 {
      if debug::enabled and b == +0 {
        return debug::error("division by zero");
      }

      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @i32_rem(b out) }
    }
  }

  pub impl : Pos[I32, I32] {
    fn pos(a: I32) -> I32 {
      a
    }
  }

  pub impl : Neg[I32, I32] {
    fn neg(a: I32) -> I32 {
      +0 - a
    }
  }

  pub impl : BitAnd[I32, I32, I32] {
    fn bit_and(a: I32, b: I32) -> I32 {
      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @n32_and(b out) }
    }
  }

  pub impl : BitOr[I32, I32, I32] {
    fn bit_or(a: I32, b: I32) -> I32 {
      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @n32_or(b out) }
    }
  }

  pub impl : BitXor[I32, I32, I32] {
    fn bit_xor(a: I32, b: I32) -> I32 {
      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @n32_xor(b out) }
    }
  }

  pub impl : Shl[I32, N32, I32] {
    fn shl(a: I32, b: N32) -> I32 {
      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @n32_shl(b out) }
    }
  }

  pub impl : Shr[I32, N32, I32] {
    fn shr(a: I32, b: N32) -> I32 {
      safe inline_ivy! (a <- a, b <- b) -> I32 { out a = @i32_shr(b out) }
    }
  }

  pub impl : Not[I32, I32] {
    fn not(a: I32) -> I32 {
      safe inline_ivy! (a <- a) -> I32 { out a = @n32_xor(0xffffffff out) }
    }
  }

  pub fn .abs(a: I32) -> I32 {
    if a < +0 {
      -a
    } else {
      a
    }
  }

  pub impl from_n32: Cast[N32, I32] = safe transmute;
  pub impl to_n32: Cast[I32, N32] = safe transmute;

  pub impl to_string: Cast[I32, String] {
    fn cast(n: I32) -> String {
      if n >= +0 {
        "{n as N32}"
      } else {
        "-{-n as N32}"
      }
    }
  }

  pub impl : Show[I32] {
    fn show(&self: &I32) -> Show {
      if self > +0 {
        Show::Literal("+{self}")
      } else {
        Show::Literal("{self}")
      }
    }
  }

  pub fn parse(str: String) -> Option[I32] {
    if str!.pop_front() is Some(prefix) {
      if prefix == '-' {
        N32::parse(str).map(fn? (x: N32) { -x as I32 })
      } else {
        if prefix != '+' {
          str!.push_front(prefix);
        }
        N32::parse(str).map(fn? (x: N32) { x as I32 })
      }
    } else {
      None()
    }
  }

  pub impl : Ord[I32] {
    fn lt(&a: &I32, &b: &I32) -> Bool {
      safe inline_ivy! (a <- a, b <- b) -> Bool { out a = @i32_lt(b out) }
    }

    fn le(&a: &I32, &b: &I32) -> Bool {
      safe inline_ivy! (a <- a, b <- b) -> Bool { out a = @i32_le(b out) }
    }

    fn cmp(a: &I32, b: &I32) -> Ord {
      Ord::cmp_from_lt(a, b)
    }
  }

  pub impl : Eq[I32] {
    fn eq(&a: &I32, &b: &I32) -> Bool {
      safe inline_ivy! (a <- a, b <- b) -> Bool { out a = @n32_eq(b out) }
    }

    fn ne(&a: &I32, &b: &I32) -> Bool {
      safe inline_ivy! (a <- a, b <- b) -> Bool { out a = @n32_ne(b out) }
    }
  }

  pub fn .min(a: I32, b: I32) -> I32 {
    if a < b {
      a
    } else {
      b
    }
  }

  pub fn .max(a: I32, b: I32) -> I32 {
    if a > b {
      a
    } else {
      b
    }
  }
}
