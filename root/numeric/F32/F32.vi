
use ops::{Cast, arithmetic::{Add, Div, Mul, Neg, Pos, Pow, Rem, Sub}, comparison::{Eq, Le, Lt}};
use util::{duplicate, erase};

#[builtin = "F32"]
pub type F32;

pub mod F32 {
  pub mod parse;
  pub mod to_string;

  pub const nan: F32 = safe inline_ivy! () -> F32 { +NaN };
  pub const inf: F32 = safe inline_ivy! () -> F32 { +inf };
  pub const neg_inf: F32 = safe inline_ivy! () -> F32 { -inf };

  pub impl : Fork[F32] = safe duplicate;
  pub impl : Drop[F32] = safe erase;

  pub impl : Default[F32] {
    const default: F32 = 0.0[F32];
  }

  pub impl : Add[F32, F32, F32] {
    fn add(a: F32, b: F32) -> F32 {
      safe inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_add(b out) }
    }
  }

  pub impl : Sub[F32, F32, F32] {
    fn sub(a: F32, b: F32) -> F32 {
      safe inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_sub(b out) }
    }
  }

  pub impl : Mul[F32, F32, F32] {
    fn mul(a: F32, b: F32) -> F32 {
      safe inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_mul(b out) }
    }
  }

  pub mod op {
    pub use pow_n32 as _;
    pub use pow_i32 as _;
  }

  pub impl pow_n32: Pow[F32, N32, F32] {
    fn pow(base: F32, exp: N32) -> F32 {
      Pow::pow_by_squaring(base, exp)
    }
  }

  pub impl pow_i32: Pow[F32, I32, F32] {
    fn pow(base: F32, exp: I32) -> F32 {
      if exp < +0 {
        1.0 / (base ** (-exp as N32))
      } else {
        base ** (exp as N32)
      }
    }
  }

  pub impl : Div[F32, F32, F32] {
    fn div(a: F32, b: F32) -> F32 {
      safe inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_div(b out) }
    }
  }

  pub impl : Rem[F32, F32, F32] {
    fn rem(a: F32, b: F32) -> F32 {
      safe inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_rem(b out) }
    }
  }

  pub impl : Pos[F32, F32] {
    fn pos(a: F32) -> F32 {
      a
    }
  }

  pub impl : Neg[F32, F32] {
    fn neg(a: F32) -> F32 {
      safe inline_ivy! (a <- a) -> F32 { out a = @f32_sub$(-0.0 out) }
    }
  }

  pub impl : Eq[F32] {
    fn eq(&a: &F32, &b: &F32) -> Bool {
      safe inline_ivy! (a <- a, b <- b) -> Bool { out a = @f32_eq(b out) }
    }

    fn ne(&a: &F32, &b: &F32) -> Bool {
      safe inline_ivy! (a <- a, b <- b) -> Bool { out a = @f32_ne(b out) }
    }
  }

  pub impl : Lt[F32] {
    fn lt(&a: &F32, &b: &F32) -> Bool {
      safe inline_ivy! (a <- a, b <- b) -> Bool { out a = @f32_lt(b out) }
    }
  }

  pub impl : Le[F32] {
    fn le(&a: &F32, &b: &F32) -> Bool {
      safe inline_ivy! (a <- a, b <- b) -> Bool { out a = @f32_le(b out) }
    }
  }

  pub impl from_n32: Cast[N32, F32] {
    fn cast(n: N32) -> F32 {
      safe inline_ivy! (n <- n) -> F32 { out n = @n32_to_f32(_ out) }
    }
  }

  pub impl to_n32: Cast[F32, N32] {
    fn cast(n: F32) -> N32 {
      safe inline_ivy! (n <- n) -> N32 { out n = @f32_to_n32(_ out) }
    }
  }

  pub fn .to_bits(n: F32) -> N32 {
    safe inline_ivy! (n <- n) -> N32 { out n = @f32_to_bits(_ out) }
  }

  pub fn from_bits(n: N32) -> F32 {
    safe inline_ivy! (n <- n) -> F32 { out n = @f32_from_bits(_ out) }
  }

  pub fn from_parts(negative: Bool, raw_exp: N32, mantissa: N32) -> F32 {
    F32::from_bits(negative as N32 << 31 | raw_exp << 23 | mantissa)
  }

  pub fn .to_parts(f: F32) -> { negative: Bool, raw_exp: N32, mantissa: N32 } {
    let bits = f.to_bits();
    let negative = (bits >> 31) == 1;
    let raw_exp = (bits >> 23) & 0xff;
    let mantissa = bits & 0x7FFFFF;
    { negative, raw_exp, mantissa }
  }

  pub fn .is_nan(f: F32) -> Bool {
    f != f
  }

  pub fn .abs(f: F32) -> F32 {
    if f < 0.0 {
      -f
    } else {
      f
    }
  }

  pub impl : Show[F32] {
    fn show(&self: &F32) -> Show {
      Show::Literal("{self}")
    }
  }
}
