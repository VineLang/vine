
use std::data::Array;
use std::debug::Show;
use std::ops::Cast;
use std::ops::comparison::Ord;

// Smooth sort is a sorting algorithm by Dijkstra.
// It is O(n) for mostly-sorted data, and O(n log n) in the worst case.
// This implementation is based on Keith Schwartz's at
// https://www.keithschwarz.com/smoothsort/

pub fn sort[T; Ord[T], Fork[T], Drop[T]](&data: &Array[T]) {
  // compute all the Leonardo numbers that can fit in 32 bits
  let prev_idx: N32 = 0;
  let prev_two = Array::new[N32](2, 1);
  let leonardo_numbers = Array::new[N32](2, 1);
  let index = 0;
  while index < 44 {
    let next = prev_two.get(0).unwrap() + prev_two.get(1).unwrap() + 1;
    prev_idx = 1 - prev_idx;
    *prev_two.at(prev_idx).unwrap() = next;
    leonardo_numbers.push_back(next);
    index += 1;
  }

  // convert the array into an implicit forest of Leonardo heaps
  let trees0: N32 = 0;
  // bitset of which trees are present
  let trees1: N32 = 0;
  // enough for 46 trees
  let smallestTree: N32 = 0;
  // index of the smallest tree

  let i: N32 = 0;
  while i < data.len() {
    add_to_heap(&data, i, &trees0, &trees1, &smallestTree, &leonardo_numbers)
    i += 1;
  }

  // dequeue in reverse order
  i = data.len();
  while i > 0 {
    remove_from_heap(&data, i, &trees0, &trees1, &smallestTree, &leonardo_numbers);
    i -= 1;
  }
}

fn is_set(trees0: N32, trees1: N32, index: N32) -> Bool {
  if index < 32 {
    (trees0 & (1 << index)) != 0
  } else {
    (trees1 & (1 << (index - 32))) != 0
  }
}

fn shift_left(&trees0: &N32, &trees1: &N32, n: N32) {
  trees1 = trees1 << n;
  trees1 = trees1 | (trees0 >> (32 - n));
  trees0 = trees0 << n;
}

fn shift_right(&trees0: &N32, &trees1: &N32, n: N32) {
  trees0 = trees0 >> n;
  trees0 = trees0 | (trees1 << (32 - n))
  trees1 = trees1 >> n;
}

fn add_to_heap[T; Ord[T], Fork[T], Drop[T]](
  &data: &Array[T],
  i: N32,
  &trees0: &N32,
  &trees1: &N32,
  &smallestTree: &N32,
  &ln: &Array[N32],
) {
  if !is_set(trees0, trees1, 0) {
    // case 0: there are no elements in the heap; add a tree of order 1
    trees0 = trees0 | 1;
    smallestTree = 1;
  } else {
    // case 1: the last two heaps have sizes that differ by one; merge them
    if is_set(trees0, trees1, 0) && is_set(trees0, trees1, 1) {
      shift_right(&trees0, &trees1, 2);
      trees0 = trees0 | 1;
      smallestTree = smallestTree + 2;
    } else {
      // case 2: the last heap is of order 1; add a heap of order 0
      if smallestTree == 1 {
        shift_left(&trees0, &trees1, 1);
        trees0 = trees0 | 1;
        smallestTree = 0;
      } else {
        // case 3: add a heap of order 1
        shift_left(&trees0, &trees1, smallestTree - 1);
        trees0 = trees0 | 1;
        smallestTree = 1;
      }
    }
  }

  // check if the new tree is in its final position
  let isLast = false;
  if smallestTree == 0 {
    if (i + 1) == data.len() {
      isLast = true
    }
  } else {
    if smallestTree == 1 {
      if (i + 1) == data.len() || ((i + 2) == data.len() && is_set(trees0, trees1, 1)) {
        isLast = true
      }
    } else {
      // the heap is final if there's no room for another leonardo tree
      if (data.len() - (i + 1)) < (ln.get(smallestTree - 1).unwrap() + 1) {
        isLast = true
      }
    }
  }

  // if it's final, rectify the whole forest, otherwise just re-balance the heap
  if isLast {
    // copies of the bitset and smallest tree are on purpose here
    rectify(&data, i + 1, trees0, trees1, smallestTree, &ln);
  } else {
    rebalance(&data, i, smallestTree, &ln);
  }
}

fn rectify[T; Ord[T], Fork[T], Drop[T]](
  &data: &Array[T],
  len: N32,
  trees0: N32,
  trees1: N32,
  smallestTree: N32,
  &ln: &Array[N32],
) {
  let i = len - 1;
  let lastHeapSize: N32;

  while true {
    lastHeapSize = smallestTree;

    // if this is the first heap in the forest, we're done
    if i == (ln.get(lastHeapSize).unwrap() - 1) {
      break;
    }

    // if we aren't order 0 or 1, we have two children; find the largest
    let toCompare = i;

    if smallestTree > 1 {
      let largerChild = larger_child(&data, i, smallestTree, &ln);
      if &data.at(toCompare).unwrap() < &data.at(largerChild).unwrap() {
        toCompare = largerChild;
      }
    }

    // get the index of the prior heap by backing up the size of the current
    let priorHeap = i - ln.get(lastHeapSize).unwrap();

    // if we've run out of trees, or the new tree's root is smaller,
    // the new node is in the right heap
    if !(&data.at(toCompare).unwrap() < &data.at(priorHeap).unwrap()) {
      break;
    }

    // otherwise, swap values and change to the prior heap
    (*data.at(i).unwrap(), *data.at(priorHeap).unwrap()) = (
      data.get(priorHeap).unwrap(),
      data.get(i).unwrap(),
    )
    i = priorHeap

    // adjust the bitmap
    while true {
      shift_right(&trees0, &trees1, 1);
      smallestTree += 1;

      if (trees0 & 1) == 1 {
        break;
      }
    }
  }

  rebalance(&data, i, lastHeapSize, &ln);
}

fn rebalance[T; Ord[T], Fork[T], Drop[T]](&data: &Array[T], i: N32, size: N32, &ln: &Array[N32]) {
  while size > 1 {
    let first = first_child(i, size, &ln);
    let second = second_child(i);

    let largerChild: N32;
    let childSize: N32;
    if &data.at(first).unwrap() < &data.at(second).unwrap() {
      largerChild = second;
      childSize = size - 2;
    } else {
      largerChild = first;
      childSize = size - 1;
    }

    if &data.at(largerChild).unwrap() < &data.at(i).unwrap() {
      // we're done
      return;
    }

    (*data.at(i).unwrap(), *data.at(largerChild).unwrap()) = (
      data.get(largerChild).unwrap(),
      data.get(i).unwrap(),
    )
    i = largerChild
    size = childSize
  }
}

fn remove_from_heap[T; Ord[T], Fork[T], Drop[T]](
  &data: &Array[T],
  len: N32,
  &trees0: &N32,
  &trees1: &N32,
  &smallestTree: &N32,
  &ln: &Array[N32],
) {
  // if the last heap is of order zero or one, it's already in place
  if smallestTree <= 1 {
    // look for the next tree
    while true {
      shift_right(&trees0, &trees1, 1);
      smallestTree += 1;

      if ((trees0 == 0) && (trees1 == 0)) || (trees0 & 1) == 1 {
        return;
      }
    }
  }

  // otherwise, make two sub-heaps of order k-2 and k-1
  let heapOrder = smallestTree;
  trees0 = trees0 & 0xfffffffe;
  shift_left(&trees0, &trees1, 2);
  trees0 = trees0 | 0b11;
  smallestTree -= 2;

  let leftHeap = first_child(len - 1, heapOrder, &ln);
  let rightHeap = second_child(len - 1);

  let allButLastTrees0 = trees0;
  let allButLastTrees1 = trees1;
  shift_right(&allButLastTrees0, &allButLastTrees1, 1);
  let allButLastSmallest = smallestTree + 1;

  rectify(&data, leftHeap + 1, allButLastTrees0, allButLastTrees1, allButLastSmallest, &ln);
  rectify(&data, rightHeap + 1, trees0, trees1, smallestTree, &ln);
}

fn first_child(i: N32, size: N32, &ln: &Array[N32]) -> N32 {
  second_child(i) - ln.get(size - 2).unwrap()
}

fn second_child(i: N32) -> N32 {
  i - 1
}

fn larger_child[T; Ord[T]](&data: &Array[T], i: N32, size: N32, &ln: &Array[N32]) -> N32 {
  let first = first_child(i, size, &ln);
  let second = second_child(i);
  if &data.at(first).unwrap() < &data.at(second).unwrap() {
    second
  } else {
    first
  }
}
