
use debug::Show;

pub enum Option[T] {
  Some(T),
  None,
}

pub mod Option {
  pub fn .map[T, U](self: Option[T], f: fn(T) -> U) -> Option[U] {
    match self {
      Some(val) { Some(f(val)) }
      None { None }
    }
  }

  pub fn .as_ref[T](&self: &Option[T]) -> Option[&T] {
    match &self {
      &Some(val) { Some(&val) }
      &None { None }
    }
  }

  pub fn .flatten[T](self: Option[Option[T]]) -> Option[T] {
    match self {
      Some(Some(val)) { Some(val) }
      _ { None }
    }
  }

  pub fn .and_then[T, U](self: Option[T], f: fn(T) -> Option[U]) -> Option[U] {
    self.map(f).flatten()
  }

  pub fn .or[T](self: Option[T], default: Option[T]) -> Option[T] {
    match self {
      None { default }
      x { x }
    }
  }

  pub fn .unwrap_or[T](self: Option[T], default: T) -> T {
    match self {
      Some(val) { val }
      None { default }
    }
  }

  pub fn .unwrap[T](self: Option[T]) -> T {
    match self {
      Some(val) { val }
    }
  }

  pub impl show[T; Show[T]]: Show[Option[T]] {
    fn show(&self: &Option[T]) -> Show {
      match &self {
        &Some(value) { Show::Constructor("Some", value.show()) }
        &None { Show::Literal("None") }
      }
    }
  }

  pub impl fork[T+]: Fork[Option[T]] {
    fn fork(&self: &Option[T]) -> Option[T] {
      match &self {
        &Some(value) { Some(value.fork()) }
        &None { None }
      }
    }
  }

  pub impl drop[T?]: Drop[Option[T]] {
    fn drop(self: Option[T]) {
      match self {
        Some(value) { value.drop() }
        None {}
      }
    }
  }
}
