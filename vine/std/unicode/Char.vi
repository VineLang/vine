
use ops::{Cast, arithmetic::{Add, Sub}, comparison::{Eq, Ord}};

#[builtin = "Char"]
pub mod Char {
  pub impl from_n32: Cast[N32, Char] {
    fn .cast(n: N32) -> Char {
      inline_ivy! (n <- n) -> Char { n }
    }
  }

  pub impl to_n32: Cast[Char, N32] {
    fn .cast(c: Char) -> N32 {
      inline_ivy! (c <- c) -> N32 { c }
    }
  }

  pub impl eq: Eq[Char] {
    fn .eq(&a: &Char, &b: &Char) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @eq(b out) }
    }

    fn .ne(&a: &Char, &b: &Char) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @ne(b out) }
    }
  }

  pub impl ord: Ord[Char] {
    fn .lt(&a: &Char, &b: &Char) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @lt(b out) }
    }

    fn .le(&a: &Char, &b: &Char) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @le(b out) }
    }

    const cmp: fn(&Char, &Char) -> Ord = Ord::cmp_from_lt[Char];
  }

  pub fn .is_whitespace(char: Char) -> Bool {
    (char == ' ') | (char == '\t') | (char == '\n')
  }

  pub fn .is_alphanumeric(char: Char) -> Bool {
    ('a' <= char <= 'z') | ('A' <= char <= 'Z') | ('0' <= char <= '9')
  }

  pub impl to_string: ToString[Char] {
    fn .to_string(self: Char) -> String {
      [self] as String
    }
  }

  pub impl add_n32: Add[Char, N32, Char] {
    fn .add(a: Char, b: N32) -> Char {
      inline_ivy! (a <- a, b <- b) -> Char { out a = @add(b out) }
    }
  }

  pub impl sub_n32: Sub[Char, N32, Char] {
    fn .sub(a: Char, b: N32) -> Char {
      inline_ivy! (a <- a, b <- b) -> Char { out a = @sub(b out) }
    }
  }

  pub impl sub_char: Sub[Char, Char, N32] {
    fn .sub(a: Char, b: Char) -> N32 {
      inline_ivy! (a <- a, b <- b) -> N32 { out a = @sub(b out) }
    }
  }
}
