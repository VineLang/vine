
// origin: FreeBSD /usr/src/lib/msun/src/e_powf.c
//
// Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
//
// ====================================================
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================
//
// Ported to Vine by Nils Cremer, 2025/07.

use std::ops::comparison::Ord;

const BP: List[F32] = [1.0, 1.5];
// 0x3f15c000
const DP_H: List[F32] = [0.0, 5.84960938e-01];
// 0x35d1cfdc
const DP_L: List[F32] = [0.0, 1.56322085e-06];
// 0x4b800000
const TWO24: F32 = 16777216.0;
const HUGE: F32 = 1.0e30;
const TINY: F32 = 1.0e-30;
// 0x3f19999a
const L1: F32 = 6.0000002384e-01;
// 0x3edb6db7
const L2: F32 = 4.2857143283e-01;
// 0x3eaaaaab
const L3: F32 = 3.3333334327e-01;
// 0x3e8ba305
const L4: F32 = 2.7272811532e-01;
// 0x3e6c3255
const L5: F32 = 2.3066075146e-01;
// 0x3e53f142
const L6: F32 = 2.0697501302e-01;
// 0x3e2aaaab
const P1: F32 = 1.6666667163e-01;
// 0xbb360b61
const P2: F32 = -2.7777778450e-03;
// 0x388ab355
const P3: F32 = 6.6137559770e-05;
// 0xb5ddea0e
const P4: F32 = -1.6533901999e-06;
// 0x3331bb4c
const P5: F32 = 4.1381369442e-08;
// 0x3f317218
const LG2: F32 = 6.9314718246e-01;
// 0x3f317200
const LG2_H: F32 = 6.93145752e-01;
// 0x35bfbe8c
const LG2_L: F32 = 1.42860654e-06;
// -(128-log2(ovfl+.5ulp))
const OVT: F32 = 4.2995665694e-08;
// 0x3f76384f =2/(3ln2)
const CP: F32 = 9.6179670095e-01;
// 0x3f764000 =12b cp
const CP_H: F32 = 9.6191406250e-01;
// 0xb8f623c6 =tail of cp_h
const CP_L: F32 = -1.1736857402e-04;
const IVLN2: F32 = 1.4426950216e+00;
const IVLN2_H: F32 = 1.4426879883e+00;
const IVLN2_L: F32 = 7.0526075433e-06;

pub impl pow_f32: Pow[F32, F32, F32] {
  fn pow(x: F32, y: F32) -> F32 {
    let z: F32;
    let ax: F32;
    let z_h: F32;
    let z_l: F32;
    let p_h: F32;
    let p_l: F32;
    let y1: F32;
    let t1: F32;
    let t2: F32;
    let r: F32;
    let s: F32;
    let sn: F32;
    let t: F32;
    let u: F32;
    let v: F32;
    let w: F32;
    let i: I32;
    let j: I32;
    let k: I32;
    let yisint: I32;
    let n: I32;
    let hx: I32;
    let hy: I32;
    let ix: I32;
    let iy: I32;
    let is_: I32;

    hx = x.to_bits() as I32;
    hy = y.to_bits() as I32;

    ix = hx & +0x7fffffff;
    iy = hy & +0x7fffffff;

    // x**0 = 1, even if x is NaN
    if iy == +0 {
      return 1.0;
    }

    // 1**y = 1, even if y is NaN
    if hx == +0x3f800000 {
      return 1.0;
    }

    // NaN if either arg is NaN
    if ix > +0x7f800000 || iy > +0x7f800000 {
      return x + y;
    }

    // determine if y is an odd int when x < 0
    // yisint = 0       ... y is not an integer
    // yisint = 1       ... y is an odd int
    // yisint = 2       ... y is an even int
    yisint = +0;
    if hx < +0 {
      when {
        iy >= +0x4b800000 {
          // even integer y
          yisint = +2;
        }
        iy >= +0x3f800000 {
          // exponent
          k = (iy >> 23) - +0x7f;
          j = iy >> (+23 - k) as N32;
          if (j << (+23 - k) as N32) == iy {
            yisint = +2 - (j & +1);
          }
        }
      }
    }

    // special value of y
    if iy == +0x7f800000 {
      // y is +-inf
      match ix.cmp(&+0x3f800000) {
        Ord::Eq {
          return 1.0;
        }
        Ord::Gt {
          return if hy >= +0 {
            y
          } else {
            0.0
          };
        }
        Ord::Lt {
          return if hy >= +0 {
            0.0
          } else {
            -y
          };
        }
      }
    }
    if iy == +0x3f800000 {
      // y is +-1
      return if hy >= +0 {
        x
      } else {
        1.0 / x
      };
    }

    if hy == +0x40000000 {
      // y is 2
      return x * x;
    }

    if hy == +0x3f000000 && hx >= +0 {
      // x >= +0
      return x.sqrt();
    }

    ax = x.abs();
    // special value of x
    if ix == +0x7f800000 || ix == +0 || ix == +0x3f800000 {
      // x is +-0,+-inf,+-1
      z = ax;
      if hy < +0 {
        // z = (1/|x|)
        z = 1.0 / z;
      }

      if hx < +0 {
        when {
          ((ix - +0x3f800000) | yisint) == +0 {
            // (-1)**non-int is NaN
            z = (z - z) / (z - z);
          }
          yisint == +1 {
            // (x<0)**odd = -(|x|**odd)
            z = -z;
          }
        }
      }
      return z;
    }

    // sign of result
    sn = 1.0;
    if hx < +0 {
      if yisint == +0 {
        // (x<0)**(non-int) is NaN
        return (x - x) / (x - x);
      }

      if yisint == +1 {
        // (x<0)**(odd int)
        sn = -1.0;
      }
    }

    // |y| is HUGE
    if iy > +0x4d000000 {
      // if |y| > 2**27
      // over/underflow if x is not close to one
      if ix < +0x3f7ffff8 {
        return if hy < +0 {
          sn * HUGE * HUGE
        } else {
          sn * TINY * TINY
        };
      }

      if ix > +0x3f800007 {
        return if hy > +0 {
          sn * HUGE * HUGE
        } else {
          sn * TINY * TINY
        };
      }

      // now |1-x| is TINY <= 2**-20, suffice to compute
      // log(x) by x-x^2/2+x^3/3-x^4/4
      // t has 20 trailing zeros
      t = ax - 1.0;
      w = (t * t) * (0.5 - t * (0.333333333333 - t * 0.25));
      // IVLN2_H has 16 sig. bits
      u = IVLN2_H * t;
      v = t * IVLN2_L - w * IVLN2;
      t1 = u + v;
      is_ = t1.to_bits() as I32;
      t1 = F32::from_bits(is_ as N32 & 0xfffff000);
      t2 = v - (t1 - u);
    } else {
      let s2: F32;
      let s_h: F32;
      let s_l: F32;
      let t_h: F32;
      let t_l: F32;

      n = +0;
      // take care subnormal number
      if ix < +0x00800000 {
        ax *= TWO24;
        n -= +24;
        ix = ax.to_bits() as I32;
      }
      n += ((ix) >> 23) - +0x7f;
      j = ix & +0x007fffff;
      // determine interval
      // normalize ix
      ix = j | +0x3f800000;
      when {
        j <= +0x1cc471 {
          // |x|<sqrt(3/2)
          k = +0;
        }
        j < +0x5db3d7 {
          // |x|<sqrt(3)
          k = +1;
        }
        _ {
          k = +0;
          n += +1;
          ix -= +0x00800000;
        }
      }
      ax = F32::from_bits(ix as N32);

      // compute s = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5)
      // bp[0]=1.0, bp[1]=1.5
      u = ax - BP.get(k as N32).unwrap();
      v = 1.0 / (ax + BP.get(k as N32).unwrap());
      s = u * v;
      s_h = s;
      is_ = s_h.to_bits() as I32;
      s_h = F32::from_bits(is_ as N32 & 0xfffff000);
      // t_h=ax+bp[k] High
      is_ = (((ix as N32 >> 1) & 0xfffff000) | 0x20000000) as I32;
      t_h = F32::from_bits(is_ as N32 + 0x00400000 + ((k as N32) << 21));
      t_l = ax - (t_h - BP.get(k as N32).unwrap());
      s_l = v * ((u - s_h * t_h) - s_h * t_l);
      // compute log(ax)
      s2 = s * s;
      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));
      r += s_l * (s_h + s);
      s2 = s_h * s_h;
      t_h = 3.0 + s2 + r;
      is_ = t_h.to_bits() as I32;
      t_h = F32::from_bits(is_ as N32 & 0xfffff000);
      t_l = r - ((t_h - 3.0) - s2);
      // u+v = s*(1+...)
      u = s_h * t_h;
      v = s_l * t_h + t_l * s;
      // 2/(3log2)*(s+...)
      p_h = u + v;
      is_ = p_h.to_bits() as I32;
      p_h = F32::from_bits(is_ as N32 & 0xfffff000);
      p_l = v - (p_h - u);
      // cp_h+cp_l = 2/(3*log2)
      z_h = CP_H * p_h;
      z_l = CP_L * p_h + p_l * CP + DP_L.get(k as N32).unwrap();
      // log2(ax) = (s+..)*2/(3*log2) = n + dp_h + z_h + z_l
      t = n as F32;
      t1 = ((z_h + z_l) + DP_H.get(k as N32).unwrap()) + t;
      is_ = t1.to_bits() as I32;
      t1 = F32::from_bits(is_ as N32 & 0xfffff000);
      t2 = z_l - (((t1 - t) - DP_H.get(k as N32).unwrap()) - z_h);
    };

    // split up y into y1+y2 and compute (y1+y2)*(t1+t2)
    is_ = y.to_bits() as I32;
    y1 = F32::from_bits(is_ as N32 & 0xfffff000);
    p_l = (y - y1) * t1 + y * t2;
    p_h = y1 * t1;
    z = p_l + p_h;
    j = z.to_bits() as I32;
    when {
      j > +0x43000000 {
        // if z > 128
        // overflow
        return sn * HUGE * HUGE;
      }
      j == +0x43000000 {
        if p_l + OVT > z - p_h {
          // overflow
          return sn * HUGE * HUGE;
        }
      }
      (j & +0x7fffffff) > +0x43160000 {
        // z < -150
        // FIXME: check should be  (uint32_t)j > 0xc3160000
        // underflow
        return sn * TINY * TINY;
      }
      j as N32 == 0xc3160000 && p_l <= z - p_h {
        // underflow
        return sn * TINY * TINY;
      }
    }

    // compute 2**(p_h+p_l)
    i = j & +0x7fffffff;
    k = (i >> 23) - +0x7f;
    n = +0;
    if i > +0x3f000000 {
      // if |z| > 0.5, set n = [z+0.5]
      n = j + (+0x00800000 >> (k + +1) as N32);
      // new k for n
      k = ((n & +0x7fffffff) >> 23) - +0x7f;
      t = F32::from_bits(n as N32 & !(0x007fffff >> k as N32));
      n = ((n & +0x007fffff) | +0x00800000) >> (+23 - k) as N32;
      if j < +0 {
        n = -n;
      }
      p_h -= t;
    }
    t = p_l + p_h;
    is_ = t.to_bits() as I32;
    t = F32::from_bits(is_ as N32 & 0xffff8000);
    u = t * LG2_H;
    v = (p_l - (t - p_h)) * LG2 + t * LG2_L;
    z = u + v;
    w = v - (z - u);
    t = z * z;
    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
    r = (z * t1) / (t1 - 2.0) - (w + z * w);
    z = 1.0 - (r - z);
    j = z.to_bits() as I32;
    j += n << 23;
    if (j >> 23) <= +0 {
      // subnormal output
      z = common::scalbn(z, n);
    } else {
      z = F32::from_bits(j as N32);
    }
    sn * z
  }
}
