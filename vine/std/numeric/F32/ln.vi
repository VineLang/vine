
// origin: FreeBSD /usr/src/lib/msun/src/e_logf.c
// Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
//
// ====================================================
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
//
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this
// software is freely granted, provided that this notice
// is preserved.
// ====================================================
// Additional notices:
// Derived from Rust's libm crate (src/math/logf.rs), licensed MIT OR Apache-2.0.
// Copyright (c) 2018-2025 The libm Developers.
//
// Ported to Vine by Nils Cremer, 2025/07.

// 0x3f317180
const LN2_HI: F32 = 6.9313812256e-01;
// 0x3717f7d1
const LN2_LO: F32 = 9.0580006145e-06;
// |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]).
// 0xaaaaaa.0p-24
const LG1: F32 = 0.66666662693;
// 0xccce13.0p-25
const LG2: F32 = 0.40000972152;

const LG3: F32 = 0.28498786688;
// 0xf89e26.0p-26
const LG4: F32 = 0.24279078841;

pub fn .ln(x: F32) -> F32 {
  // 0x1p25f === 2 ^ 25
  let x1p25 = F32::from_bits(0x4c000000);

  let ix = x.to_bits();
  let k = +0;

  when {
    (ix < 0x00800000) || ((ix >> 31) != 0) {
      // x < 2**-126
      if ix << 1 == 0 {
        // log(+-0)=-inf
        return -1.0 / (x * x);
      }
      if (ix >> 31) != 0 {
        // log(-#) = NaN
        return (x - x) / 0.0;
      }
      // subnormal number, scale up x
      k -= +25;
      x *= x1p25;
      ix = x.to_bits();
    }
    ix >= 0x7f800000 {
      return x;
    }
    ix == 0x3f800000 {
      return 0.0;
    }
  }

  // reduce x into [sqrt(2)/2, sqrt(2)]
  ix += 0x3f800000 - 0x3f3504f3;
  k += ((ix >> 23) as I32) - +0x7f;
  ix = (ix & 0x007fffff) + 0x3f3504f3;
  x = F32::from_bits(ix);

  let f = x - 1.0;
  let s = f / (2.0 + f);
  let z = s * s;
  let w = z * z;
  let t1 = w * (LG2 + w * LG4);
  let t2 = z * (LG1 + w * LG3);
  let r = t2 + t1;
  let hfsq = 0.5 * f * f;
  let dk = k as F32;
  s * (hfsq + r) + dk * LN2_LO - hfsq + f + dk * LN2_HI
}
