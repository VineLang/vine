
use ops::{Cast, arithmetic::{Add, Div, Mul, Neg, Pow, Rem, Sub}, comparison::{Eq, Le, Lt}};
use debug::Show;

#[builtin = "F32"]
pub type F32;

pub mod F32 {
  pub const nan: F32 = inline_ivy! () -> F32 { +NaN };
  pub const inf: F32 = inline_ivy! () -> F32 { +inf };
  pub const neg_inf: F32 = inline_ivy! () -> F32 { -inf };

  pub impl fork: Fork[F32] = unsafe::duplicate;
  pub impl drop: Drop[F32] = unsafe::erase;

  pub impl add: Add[F32, F32, F32] {
    fn add(a: F32, b: F32) -> F32 {
      inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_add(b out) }
    }
  }

  pub impl sub: Sub[F32, F32, F32] {
    fn sub(a: F32, b: F32) -> F32 {
      inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_sub(b out) }
    }
  }

  pub impl mul: Mul[F32, F32, F32] {
    fn mul(a: F32, b: F32) -> F32 {
      inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_mul(b out) }
    }
  }

  pub impl pow_n32: Pow[F32, N32, F32] {
    fn pow(base: F32, exp: N32) -> F32 {
      Pow::pow_by_squaring(base, exp)
    }
  }

  pub impl pow_i32: Pow[F32, I32, F32] {
    fn pow(base: F32, exp: I32) -> F32 {
      if exp < +0 {
        1.0 / (base ** (-exp as N32))
      } else {
        base ** (exp as N32)
      }
    }
  }

  pub impl div: Div[F32, F32, F32] {
    fn div(a: F32, b: F32) -> F32 {
      inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_div(b out) }
    }
  }

  pub impl rem: Rem[F32, F32, F32] {
    fn rem(a: F32, b: F32) -> F32 {
      inline_ivy! (a <- a, b <- b) -> F32 { out a = @f32_rem(b out) }
    }
  }

  pub impl neg: Neg[F32, F32] {
    fn neg(a: F32) -> F32 {
      inline_ivy! (a <- a) -> F32 { out a = @f32_sub$(-0.0 out) }
    }
  }

  pub impl eq: Eq[F32] {
    fn eq(&a: &F32, &b: &F32) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @f32_eq(b out) }
    }

    fn ne(&a: &F32, &b: &F32) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @f32_ne(b out) }
    }
  }

  pub impl lt: Lt[F32] {
    fn lt(&a: &F32, &b: &F32) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @f32_lt(b out) }
    }
  }

  pub impl le: Le[F32] {
    fn le(&a: &F32, &b: &F32) -> Bool {
      inline_ivy! (a <- a, b <- b) -> Bool { out a = @f32_le(b out) }
    }
  }

  pub impl from_n32: Cast[N32, F32] {
    fn cast(n: N32) -> F32 {
      inline_ivy! (n <- n) -> F32 { out n = @n32_to_f32(0 out) }
    }
  }

  pub impl to_n32: Cast[F32, N32] {
    fn cast(n: F32) -> N32 {
      inline_ivy! (n <- n) -> N32 { out n = @f32_to_n32(0 out) }
    }
  }

  pub impl from_i32: Cast[I32, F32] {
    fn cast(n: I32) -> F32 {
      when {
        n < +0 { -(-n as N32 as F32) }
        _ { n as N32 as F32 }
      }
    }
  }

  pub fn .to_bits(n: F32) -> N32 {
    inline_ivy! (n <- n) -> N32 { out n = @f32_to_bits(0 out) }
  }

  pub fn from_bits(n: N32) -> F32 {
    inline_ivy! (n <- n) -> F32 { out n = @f32_from_bits(0 out) }
  }

  pub fn .is_nan(f: F32) -> Bool {
    f != f
  }

  pub fn .abs(f: F32) -> F32 {
    if f < 0.0 {
      -f
    } else {
      f
    }
  }

  pub impl to_string: Cast[F32, String] {
    fn cast(f: F32) -> String {
      when {
        f.is_nan() { "NaN" }
        f == F32::inf { "+inf" }
        f == F32::neg_inf { "-inf" }
        f == 0.0 {
          if 1.0 / f > 0.0 {
            "+0.0"
          } else {
            "-0.0"
          }
        }
        _ {
          let sign = if f < 0.0 {
            f = -f;
            "-"
          } else {
            "+"
          };
          let exp = when {
            f > 1.0e+5 {
              let exp = 0;
              while f >= 10.0 {
                f /= 10.0;
                exp += 1;
              }
              "e+{exp}"
            }
            f < 1.0e-5 {
              let exp = 0;
              while f <= 1.0 {
                f *= 10.0;
                exp += 1;
              }
              "e-{exp}"
            }
            _ { "" }
          };
          let int = f as N32;
          f -= int as F32;
          let dec = ((f + 1.0) * 1.0e+5) as N32 as String;
          dec!.at(0).unwrap().* = '.';
          "{sign}{int}{dec}{exp}"
        }
      }
    }
  }

  pub impl show: Show[F32] {
    fn show(&self: &F32) -> Show {
      Show::Literal("{self}")
    }
  }

  // 0x3f317180
  const LN2_HI: F32 = 6.9313812256e-01;
  // 0x3717f7d1
  const LN2_LO: F32 = 9.0580006145e-06;
  // |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]).
  // 0xaaaaaa.0p-24
  const LG1: F32 = 0.66666662693;
  // 0xccce13.0p-25
  const LG2: F32 = 0.40000972152;

  const LG3: F32 = 0.28498786688;
  // 0xf89e26.0p-26
  const LG4: F32 = 0.24279078841;

  // origin: FreeBSD /usr/src/lib/msun/src/e_logf.c
  // Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  //
  // ====================================================
  // Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
  //
  // Developed at SunPro, a Sun Microsystems, Inc. business.
  // Permission to use, copy, modify, and distribute this
  // software is freely granted, provided that this notice
  // is preserved.
  // ====================================================
  // Additional notices:
  // Derived from Rust's libm crate (src/math/logf.rs), licensed MIT OR Apache-2.0.
  // Copyright (c) 2018-2025 The libm Developers.
  //
  // Ported to Vine by Nils Cremer, 2025-07-24.
  // You may distribute this file under the terms of the MIT license or the Apache License 2.0, at your option.
  pub fn .ln(x: F32) -> F32 {
    // 0x1p25f === 2 ^ 25
    let x1p25 = F32::from_bits(0x4c000000);

    let ix = x.to_bits();
    let k = +0;

    when {
      (ix < 0x00800000) || ((ix >> 31) != 0) {
        // x < 2**-126
        if ix << 1 == 0 {
          // log(+-0)=-inf
          return -1.0 / (x * x);
        }
        if (ix >> 31) != 0 {
          // log(-#) = NaN
          return (x - x) / 0.0;
        }
        // subnormal number, scale up x
        k -= +25;
        x *= x1p25;
        ix = x.to_bits();
      }
      ix >= 0x7f800000 {
        return x;
      }
      ix == 0x3f800000 {
        return 0.0;
      }
    }

    // reduce x into [sqrt(2)/2, sqrt(2)]
    ix += 0x3f800000 - 0x3f3504f3;
    k += ((ix >> 23) as I32) - +0x7f;
    ix = (ix & 0x007fffff) + 0x3f3504f3;
    x = F32::from_bits(ix);

    let f = x - 1.0;
    let s = f / (2.0 + f);
    let z = s * s;
    let w = z * z;
    let t1 = w * (LG2 + w * LG4);
    let t2 = z * (LG1 + w * LG3);
    let r = t2 + t1;
    let hfsq = 0.5 * f * f;
    let dk = k as F32;
    s * (hfsq + r) + dk * LN2_LO - hfsq + f + dk * LN2_HI
  }

  // This is not a IEEE-754 compliant parser.
  // * For large and small absolute values, the result is not necessarily the closest representable value.
  // * For strings with 10 or more significant digits, the result is likely completely wrong.
  // TODO: implement fall-back parsing with arbitrary precision
  // TODO: implement Eisel-Lemire algorithm for fast parsing of most cases
  pub fn parse(str: String) -> Option[F32] {
    let prefix = match str!.pop_front() {
      Some(char) { char }
      None {
        return None;
      }
    };
    let is_negative = when {
      prefix == '-' { true }
      prefix == '+' { false }
      _ {
        str!.push_front(prefix);
        false
      }
    };

    let value = when {
      str == "NaN" || str == "nan" { F32::nan }
      str == "inf" { F32::inf }
      _ {
        let mantissa = 0;
        let next_char = str!.pop_front();
        let num_digits = 0;
        while next_char is Some(char) && ('0' <= char <= '9') {
          mantissa = mantissa * 10 + (char - '0') as N32;
          num_digits += 1;
          next_char = str!.pop_front();
        }
        let exponent = +0;
        if next_char is Some(char) && char == '.' {
          next_char = str!.pop_front();
          while next_char is Some(char) && ('0' <= char <= '9') {
            mantissa = mantissa * 10 + (char - '0') as N32;
            num_digits += 1;
            exponent -= +1;
            next_char = str!.pop_front();
          }
        }
        if num_digits == 0 {
          return None;
        }
        if next_char is Some(char) {
          if char != 'e' && char != 'E' {
            return None;
          }
          match I32::parse(str) {
            Some(exp) {
              exponent += exp;
            }
            None {
              return None;
            }
          }
        }
        if exponent < +0 {
          mantissa as F32 / (10.0 ** (-exponent as N32))
        } else {
          mantissa as F32 * (10.0 ** exponent as N32)
        }
      }
    };

    if is_negative {
      Some(-value)
    } else {
      Some(value)
    }
  }
}
