
use std::option::Option::{Some, None};

struct List[T](u32, ListBuf[T], ~ListBuf[T]);

struct Buf[T](T, Buf[T]);

mod List {
  fn len[T](&List(len, _, _): List[T]) {
    len
  }

  fn map[T, U](&move List(l, buf, ~_): List[T], f: fn(T) -> U) -> U {
    let len = l;
    let cur;
    let result = move ~cur;
    while l {
      let Buf(head, tail) = buf;
      buf = tail;
      let next;
      ~cur = Buf(f(head), move ~next);
      ~next = move ~cur;
      l -= 1;
    };
    (len, result, move cur)
  }

  fn pop_front[T](&List(len, buf, _): List[T]) -> Option[T] {
    if len {
      len -= 1;
      let Buf(head, tail) = buf;
      buf = tail;
      Some(head)
    } else {
      None
    }
  }

  fn push_back[T](&list: List[T], el: T) {
    list ++= [el];
  }

  fn push_front[T](&list: List[T], el: T) {
    list = [el] ++ list;
  }

  fn join(&move list: List[String], sep: String) -> String {
    let it = list.into_iter();
    if it.into_iter::next() is Some(str) {
      while it.into_iter::next() is Some(val) {
        str ++= sep ++ val;
      }
      str
    } else {
      ""
    }
  }

  fn to_string[T](elem_to_string: fn(T) -> String, list: List[T]) -> String {
    "[" ++ list.map(elem_to_string).join(", ") ++ "]"
  }

  struct Iter[T](u32, &Buf[T]);

  fn iter[T](&List(len, buf, _): List[T]) -> Iter[T] {
    Iter(len, &buf)
  }

  mod iter {
    fn next(&Iter(len, buf): Iter[T]) -> Option[T] {
      if len {
        len -= 1;
        let &Buf(*head, *tail) = buf;
        buf = tail;
        Some(head)
      } else {
        let &_ = move buf;
        None
      }
    }
  }

  struct IntoIter[T](u32, Buf[T]);

  fn into_iter(&move List(len, buf, _): List[T]) -> IntoIter[T] {
    IntoIter(len, buf)
  }

  mod into_iter {
    fn next[T](&IntoIter(len, buf): IntoIter[T]) -> Option[T] {
      if len {
        len -= 1;
        let Buf(head, tail) = buf;
        buf = tail;
        Some(head)
      } else {
        None
      }
    }
  }
}
