
use ops::Ord;
use unicode::ToString;

pub struct Map[K, V](N32, MapData[K, V]);

type MapData[K, V] = (Map[K, V], (K, V), Map[K, V]);

pub mod Map {
  pub const empty[K, V]: Map[K, V] = Map(0, ~_);

  fn new[K, V](left: Map[K, V], entry: (K, V), right: Map[K, V]) -> Map[K, V] {
    Map(left.len() + right.len() + 1, (left, entry, right))
  }

  pub fn from_list[K, V; Ord[K]](entries: List[(K, V)]) -> Map[K, V] {
    let map = Map::empty[K, V];
    while entries.pop_front() is Some((key, value)) {
      map.insert(key, value);
    }
    map
  }

  pub fn .clear[K, V](&self: &Map[K, V]) {
    self = Map::empty;
  }

  pub fn .len[K, V](&Map[K, V](len, _)) -> N32 {
    len
  }

  pub fn .insert[K, V; Ord[K]](&Map[K, V](len, data), key: K, value: V) -> Option[V] {
    if len == 0 {
      len = 1;
      data = (empty, (key, value), empty);
      None
    } else {
      let &(left, (cur_key, cur_value), right) = &data;
      let old;
      match key.cmp(&cur_key) {
        Ord::Lt {
          old = left.insert(key, value);
          len = size(&data);
          balance_right(&data);
        }
        Ord::Eq {
          old = Some(cur_value);
          cur_key = key;
          cur_value = value;
        }
        Ord::Gt {
          old = right.insert(key, value);
          len = size(&data);
          balance_left(&data);
        }
      }
      old
    }
  }

  pub fn .get[K, V; Ord[K]](&Map[K, V](len, data), &key: &K) -> Option[&V] {
    if len == 0 {
      None
    } else {
      let &(left, (cur_key, cur_value), right) = &data;
      match key.cmp(&cur_key) {
        Ord::Lt { left.get(&key) }
        Ord::Eq { Some(&cur_value) }
        Ord::Gt { right.get(&key) }
      }
    }
  }

  pub fn .get_or_insert[K, V; Ord[K]](&self: &Map[K, V], key: K, value: V) -> &V {
    let ~insert;
    let old = self.insert(key, ~insert);
    let value = old.unwrap_or(value);
    let ref = &value;
    ~insert = value;
    ref
  }

  pub fn .get_le[K, V; Ord[K]](&Map[K, V](len, data), &key: &K) -> Option[&(K, V)] {
    if len == 0 {
      None
    } else {
      let &(left, (cur_key, cur_value), right) = &data;
      match key.cmp(&cur_key) {
        Ord::Lt { left.get_ge(&key) }
        Ord::Eq { Some(&(cur_key, cur_value)) }
        Ord::Gt {
          if right.get_ge(&key) is Some(entry) {
            Some(entry)
          } else {
            Some(&(cur_key, cur_value))
          }
        }
      }
    }
  }

  pub fn .get_ge[K, V; Ord[K]](&Map[K, V](len, data), &key: &K) -> Option[&(K, V)] {
    if len == 0 {
      None
    } else {
      let &(left, (cur_key, cur_value), right) = &data;
      match key.cmp(&cur_key) {
        Ord::Lt {
          if left.get_ge(&key) is Some(entry) {
            Some(entry)
          } else {
            Some(&(cur_key, cur_value))
          }
        }
        Ord::Eq { Some(&(cur_key, cur_value)) }
        Ord::Gt { right.get_ge(&key) }
      }
    }
  }

  pub fn .remove[K, V; Ord[K]](&Map[K, V](len, data), &key: &K) -> Option[V] {
    if len == 0 {
      None
    } else {
      let &(left, (cur_key, cur_value), right) = &data;
      let old;
      match key.cmp(&cur_key) {
        Ord::Lt {
          old = left.remove(&key);
          len = Map::size(&data);
          balance_left(&data);
        }
        Ord::Eq {
          old = Some(cur_value);
          len -= 1;
          data = merge_balanced(move left, move right);
        }
        Ord::Gt {
          old = right.remove(&key);
          len = Map::size(&data);
          balance_right(&data);
        }
      }
      old
    }
  }

  pub fn .remove_min[K, V; Ord[K]](&self: &Map[K, V]) -> Option[(K, V)] {
    if self.len() == 0 {
      None
    } else {
      Some(self._remove_min())
    }
  }

  pub fn .remove_max[K, V; Ord[K]](&self: &Map[K, V]) -> Option[(K, V)] {
    if self.len() == 0 {
      None
    } else {
      Some(self._remove_max())
    }
  }

  fn ._remove_min[K, V](&Map[K, V](len, data)) -> (K, V) {
    len -= 1;
    let &(left, entry, right) = &data;
    if left.len() == 0 {
      let Map(_, right) = move right;
      data = right;
      move entry
    } else {
      let min = left._remove_min();
      balance_left(&data);
      min
    }
  }

  fn ._remove_max[K, V](&Map[K, V](len, data)) -> (K, V) {
    len -= 1;
    let &(left, entry, right) = &data;
    if right.len() == 0 {
      let Map(_, left) = move left;
      data = left;
      move entry
    } else {
      let max = right._remove_max();
      balance_right(&data);
      max
    }
  }

  pub fn .iter[K, V](&self: &Map[K, V]) -> Iter[K, V] {
    Iter(&self, [])
  }

  pub struct Iter[K, V](&Map[K, V], List[&((K, V), Map[K, V])]);

  pub mod Iter {
    pub fn .next[K, V; Ord[K]](&Iter[K, V](node, stack)) -> Option[&(K, V)] {
      loop {
        let &Map(len, data) = move node;
        if len == 0 {
          break;
        }
        let &(left, entry, right) = &data;
        stack.push_front(&(entry, right));
        node = &left;
      }
      if stack.pop_front() is Some(el) {
        let &(*entry, *new_node) = el;
        node = new_node;
        Some(entry)
      } else {
        None
      }
    }

    pub fn .drop[K, V; Ord[K]](&iter: &Iter[K, V]) {
      let Iter(&_, stack) = move iter;
      while stack.pop_front() is Some(&_) {}
    }
  }

  pub fn .into_iter[K, V](self: Map[K, V]) -> IntoIter[K, V] {
    IntoIter(self, [])
  }

  pub struct IntoIter[K, V](Map[K, V], List[((K, V), Map[K, V])]);

  pub mod IntoIter {
    pub fn .next[K, V](&IntoIter[K, V](node, stack)) -> Option[(K, V)] {
      loop {
        let Map(len, data) = move node;
        if len == 0 {
          break;
        }
        let (left, entry, right) = data;
        stack.push_front((entry, right));
        node = left;
      }
      if stack.pop_front() is Some((entry, new_node)) {
        node = new_node;
        Some(entry)
      } else {
        None
      }
    }
  }

  pub fn .to_list[K, V; Ord[K]](Map[K, V](len, data)) -> List[(K, V)] {
    if len == 0 {
      []
    } else {
      let (left, entry, right) = data;
      left.to_list() ++ [entry] ++ right.to_list()
    }
  }

  pub impl to_string[K, V; ToString[K], ToString[V]]: ToString[Map[K, V]] {
    fn .to_string(map: Map[K, V]) -> String {
      let string = "";
      let iter = map.into_iter();
      let first = true;
      while iter.next() is Some((key, value)) {
        if !first {
          string ++= ", ";
        }
        first = false;
        let key = ToString::to_string[K](key);
        let value = ToString::to_string[V](value);
        string ++= "{key}: {value}";
      }
      if first {
        "\{}"
      } else {
        "\{ {string} }"
      }
    }
  }

  fn .balanced[K, V](&Map[K, V](len, data)) -> Bool {
    if len == 0 {
      true
    } else {
      let &(left, _, right) = &data;
      let x = is_balanced(&left, &right) && is_balanced(&right, &left);
      x && left.balanced() && right.balanced()
    }
  }
}

fn balance_left[K, V](&data: &MapData[K, V]) {
  let (l, e, r) = data;
  data = if is_balanced(&l, &r) {
    (l, e, r)
  } else {
    let Map(_, (rl, re, rr)) = r;
    if is_single(&rl, &rr) {
      (Map::new(l, e, rl), re, rr)
    } else {
      let Map(_, (rll, rle, rlr)) = rl;
      (Map::new(l, e, rll), rle, Map::new(rlr, re, rr))
    }
  }
}

fn balance_right[K, V](&data: &MapData[K, V]) {
  let (l, e, r) = data;
  data = if is_balanced(&r, &l) {
    (l, e, r)
  } else {
    let Map(_, (ll, le, lr)) = l;
    if is_single(&lr, &ll) {
      (ll, le, Map::new(lr, e, r))
    } else {
      let Map(_, (lrl, lre, lrr)) = lr;
      (Map::new(ll, le, lrl), lre, Map::new(lrr, e, r))
    }
  }
}

fn merge_balanced[K, V](left: Map[K, V], right: Map[K, V]) -> MapData[K, V] {
  if left.len() == 0 {
    let Map(_, data) = right;
    data
  } else if right.len() == 0 {
    let Map(_, data) = left;
    data
  } else if left.len() > right.len() {
    let entry = left._remove_max();
    (left, entry, right)
  } else {
    let entry = right._remove_min();
    (left, entry, right)
  }
}

fn is_balanced[K, V](&Map[K, V](a, _), &Map[K, V](b, _)) -> Bool {
  3 * a + 2 >= b
}

fn is_single[K, V](&Map[K, V](a, _), &Map[K, V](b, _)) -> Bool {
  a <= 2 * b
}

fn size[K, V](&(Map(l, _), _, Map(r, _)): &MapData[K, V]) -> N32 {
  l + r + 1
}
