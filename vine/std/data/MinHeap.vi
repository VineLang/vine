
use ops::{Cast, comparison::Ord};

pub struct MinHeap[T]((N32, Node[T]));

pub mod MinHeap[T; Ord[T]] {
  pub const empty[T]: MinHeap[T] = MinHeap(0, unsafe::eraser);

  pub fn .single[T](value: T) -> MinHeap[T] {
    MinHeap(1, Node::new(value))
  }

  pub fn .insert[...](&self: &MinHeap[T], value: T) {
    self = MinHeap::single(value).merge(self);
  }

  pub fn .pop[...](&MinHeap[T](rank, node)) -> Option[T] {
    if rank == 0 {
      None
    } else {
      let Node(value, left, right) = node;
      MinHeap(rank, node) = left.merge(right);
      Some(value)
    }
  }

  pub fn .peek[...](&MinHeap[T](rank, *node)) -> Option[&T] {
    if rank == 0 {
      None
    } else {
      let &Node(*value, _, _) = node;
      Some(value)
    }
  }

  fn .rank[T](&MinHeap[T](rank, _)) -> N32 {
    rank
  }

  fn .value[T](&MinHeap[T](_, Node(value, _, _))) -> &T {
    &value
  }

  fn .merge[...](self: MinHeap[T], other: MinHeap[T]) -> MinHeap[T] {
    if self.rank() == 0 {
      unsafe::erase(self);
      return other;
    }
    if other.rank() == 0 {
      unsafe::erase(other);
      return self;
    }
    if self.value() > other.value() {
      swap(&self, &other);
    }
    let MinHeap(_, Node(value, left, right)) = self;
    let merged = right.merge(other);
    let (new_left, new_right) = if left.rank() >= merged.rank() {
      (left, merged)
    } else {
      (merged, left)
    };
    MinHeap(new_right.rank() + 1, Node(value, new_left, new_right))
  }

  #[become(unsafe::duplicate)]
  pub impl fork[T+]: Fork[MinHeap[T]] {
    fn fork(&MinHeap[T](rank, node)) -> MinHeap[T] {
      if rank == 0 {
        MinHeap::empty
      } else {
        MinHeap(rank, node.fork())
      }
    }
  }

  #[become(unsafe::erase)]
  pub impl drop[T?]: Drop[MinHeap[T]] {
    fn drop(MinHeap[T](rank, node)) {
      if rank == 0 {
        unsafe::erase(node);
      } else {
        _ = node;
      }
    }
  }

  pub impl to_list[...]: Cast[MinHeap[T], List[T]] {
    fn cast(self: MinHeap[T]) -> List[T] {
      let list = [];
      while self.pop() is Some(value) {
        list.push_back(value);
      }
      unsafe::erase(self);
      list
    }
  }
}

struct Node[T]((T, MinHeap[T], MinHeap[T]));

mod Node[T; Ord[T]] {
  pub fn new[T](value: T) -> Node[T] {
    Node(value, MinHeap::empty[T], MinHeap::empty[T])
  }

  #[become(unsafe::duplicate)]
  pub impl fork[T+]: Fork[Node[T]] {
    fn fork(&Node[T](value, left, right)) -> Node[T] {
      Node(value, left.fork(), right.fork())
    }
  }

  #[become(unsafe::erase)]
  pub impl drop[T?]: Drop[Node[T]] {
    fn drop(Node[T](value, left, right)) {}
  }
}
