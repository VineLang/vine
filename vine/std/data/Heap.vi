
use ops::{Cast, comparison::Ord};

pub struct Heap[T]((N32, Node[T]));

pub mod Heap[T; Ord[T]] {
  pub const empty[T]: Heap[T] = Heap(0, unsafe::eraser);

  pub fn .single[T](value: T) -> Heap[T] {
    Heap(1, Node::new(value))
  }

  pub fn .insert[...](&self: &Heap[T], value: T) {
    self = Heap::single(value).merge(self);
  }

  pub fn .pop[...](&Heap[T](rank, node)) -> Option[T] {
    if rank == 0 {
      None
    } else {
      let Node(value, left, right) = node;
      Heap(rank, node) = left.merge(right);
      Some(value)
    }
  }

  pub fn .peek[...](&Heap[T](rank, *node)) -> Option[&T] {
    if rank == 0 {
      None
    } else {
      let &Node(*value, _, _) = node;
      Some(value)
    }
  }

  pub fn .is_empty[T](&Heap[T](rank, _)) -> Bool {
    rank == 0
  }

  fn .rank[T](&Heap[T](rank, _)) -> N32 {
    rank
  }

  fn .value[T](&Heap[T](_, Node(value, _, _))) -> &T {
    &value
  }

  fn .merge[...](self: Heap[T], other: Heap[T]) -> Heap[T] {
    if self.rank() == 0 {
      unsafe::erase(self);
      return other;
    }
    if other.rank() == 0 {
      unsafe::erase(other);
      return self;
    }
    if self.value() > other.value() {
      swap(&self, &other);
    }
    let Heap(_, Node(value, left, right)) = self;
    let merged = right.merge(other);
    let (new_left, new_right) = if left.rank() >= merged.rank() {
      (left, merged)
    } else {
      (merged, left)
    };
    Heap(new_right.rank() + 1, Node(value, new_left, new_right))
  }

  #[become(unsafe::duplicate)]
  pub impl fork[T+]: Fork[Heap[T]] {
    fn fork(&Heap[T](rank, node)) -> Heap[T] {
      if rank == 0 {
        Heap::empty
      } else {
        Heap(rank, node.fork())
      }
    }
  }

  #[become(unsafe::erase)]
  pub impl drop[T?]: Drop[Heap[T]] {
    fn drop(Heap[T](rank, node)) {
      if rank == 0 {
        unsafe::erase(node);
      } else {
        _ = node;
      }
    }
  }

  pub impl to_list[...]: Cast[Heap[T], List[T]] {
    fn cast(self: Heap[T]) -> List[T] {
      let list = [];
      while self.pop() is Some(value) {
        list.push_back(value);
      }
      unsafe::erase(self);
      list
    }
  }
}

struct Node[T]((T, Heap[T], Heap[T]));

mod Node[T; Ord[T]] {
  pub fn new[T](value: T) -> Node[T] {
    Node(value, Heap::empty[T], Heap::empty[T])
  }

  #[become(unsafe::duplicate)]
  pub impl fork[T+]: Fork[Node[T]] {
    fn fork(&Node[T](value, left, right)) -> Node[T] {
      Node(value, left.fork(), right.fork())
    }
  }

  #[become(unsafe::erase)]
  pub impl drop[T?]: Drop[Node[T]] {
    fn drop(Node[T](value, left, right)) {}
  }
}
