
pub trait Ord[T] {
  fn .cmp(a: &T, b: &T) -> Ord;

  fn .lt(a: &T, b: &T) -> Bool;

  fn .le(a: &T, b: &T) -> Bool;
}

pub enum Ord {
  Lt,
  Eq,
  Gt,
}

pub mod Ord {
  pub impl pair[A, B; Ord[A], Ord[B]]: Ord[(A, B)] {
    fn cmp(&(a0: A, b0: B), &(a1: A, b1: B)) -> Ord {
      match a0.cmp(&a1) {
        Ord::Lt { Ord::Lt }
        Ord::Gt { Ord::Gt }
        Ord::Eq { b0.cmp(&b1) }
      }
    }

    const lt: fn(&(A, B), &(A, B)) -> Bool = Ord::lt_from_cmp[(A, B)];
    const le: fn(&(A, B), &(A, B)) -> Bool = Ord::le_from_cmp[(A, B)];
  }

  pub fn .gt[T; Ord[T]](a: &T, b: &T) -> Bool {
    Ord::lt[T](b, a)
  }

  pub fn .ge[T; Ord[T]](a: &T, b: &T) -> Bool {
    Ord::le[T](b, a)
  }

  pub fn lt_from_cmp[T; Ord[T]](a: &T, b: &T) -> Bool {
    Ord::cmp[T](a, b) is Ord::Lt
  }

  pub fn le_from_cmp[T; Ord[T]](a: &T, b: &T) -> Bool {
    !(Ord::cmp[T](a, b) is Ord::Gt)
  }

  pub fn cmp_from_lt[T; Ord[T]](a: &T, b: &T) -> Ord {
    if Ord::lt[T](a, b) {
      Ord::Lt
    } else if Ord::gt[T](a, b) {
      Ord::Gt
    } else {
      Ord::Eq
    }
  }
}

pub trait Eq[T] {
  fn .eq(a: &T, b: &T) -> Bool;
}

pub mod Eq {
  pub impl pair[A, B; Eq[A], Eq[B]]: Eq[(A, B)] {
    fn eq(&(a0: A, b0: B), &(a1: A, b1: B)) -> Bool {
      a0.eq(&a1) && b0.eq(&b1)
    }
  }
}
