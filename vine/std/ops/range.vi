
use comparison::Ord;

pub trait Bound[B, T] {
  fn .left_of(self: &B, value: T) -> Bool;
  fn .right_of(self: &B, value: T) -> Bool;
}

pub mod Bound {
  #[builtin = "Unbounded"]
  pub struct Unbounded(());
  #[builtin = "BoundInclusive"]
  pub struct Inclusive[T](T);
  #[builtin = "BoundExclusive"]
  pub struct Exclusive[T](T);

  pub mod Unbounded {
    pub impl bound[T]: Bound[Unbounded, T] {
      fn .left_of(self: &Unbounded, _value: T) -> Bool {
        true
      }
      fn .right_of(self: &Unbounded, _value: T) -> Bool {
        true
      }
    }
  }

  pub mod Inclusive {
    pub impl bound[T; Ord[T]]: Bound[Inclusive[T], T] {
      fn .left_of(&Inclusive[T](bound), value: T) -> Bool {
        bound <= value
      }
      fn .right_of(&Inclusive[T](bound), value: T) -> Bool {
        value <= bound
      }
    }
  }

  pub mod Exclusive {
    pub impl bound[T; Ord[T]]: Bound[Exclusive[T], T] {
      fn .left_of(&Exclusive[T](bound), value: T) -> Bool {
        bound < value
      }
      fn .right_of(&Exclusive[T](bound), value: T) -> Bool {
        value < bound
      }
    }
  }
}

#[builtin = "Range"]
pub struct Range[B1, B2]((B1, B2));

pub mod Range {
  pub fn .contains[B1, B2, T; Bound[B1, T], Bound[B2, T]](&Range[B1, B2](start, end), value: T) -> Bool {
    start.left_of(value) && end.right_of(value)
  }
}
