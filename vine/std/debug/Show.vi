
use ops::Cast;

pub trait Show[T] {
  fn .show(self: &T) -> Show;
}

pub enum Show {
  Break,
  Literal(String),
  Dynamic({ single_line: Show, multiline: Show }),
  Indented(Show),
  Group(List[Show]),
}

pub mod Show {
  pub impl to_string: Cast[Show, String] {
    fn cast(self: Show) -> String {
      self.format(80)
    }
  }

  pub fn constructor(name: String, data: Show) -> Show {
    Show::Group([
      Show::Literal("{name}("),
      Show::Break,
      Show::Indented(data),
      Show::Break,
      Show::Literal(")"),
    ])
  }

  pub fn tuple(items: List[Show]) -> Show {
    let items = [Show::Literal("("), Show::Break];
    items ++= Show::comma_separated(items);
    items.push_back(Show::Literal(")"));
    Show::Group(items)
  }

  pub fn object(entries: List[(String, Show)]) -> Show {
    let entries = entries.map(fn((key: String, value)) {
      Show::Group([Show::Literal("{key}: "), value])
    });
    let items = [Show::Literal("\{"), Show::Break];
    items ++= Show::comma_separated(entries);
    items.push_back(Show::Literal("}"));
    Show::Group(items)
  }

  pub fn comma_separated(items: List[Show]) -> List[Show] {
    let separator = Show::Dynamic({
      single_line: Show::Literal(", "),
      multiline: Show::Literal(","),
    });
    separated(items, separator, true, true)
  }

  pub fn separated(
    items: List[Show],
    separator: Show,
    add_break: Bool,
    multiline_trailing_separator: Bool,
  ) -> List[Show] {
    let item_iter = items.into_iter();
    let items = [];
    let ~last_item;
    while item_iter.next() is Some(item) {
      items.push_back(item);
      ~last_item = false;
      if !~last_item || multiline_trailing_separator {
        items.push_back(Show::Dynamic({ single_line: Show::Literal(""), multiline: separator }));
        if add_break {
          items.push_back(Show::Break);
        }
      }
    }
    ~last_item = true;
    items
  }

  fn .single_line_width(&self: &Show) -> N32 {
    match self {
      Break { 0 }
      Literal(literal) { literal.len() }
      Dynamic({ single_line, multiline }) { single_line.single_line_width() }
      Indented(data) { data.single_line_width() }
      Group(items) {
        // FIX by making .map and .sum method on Iterator
        let width = 0;
        let iter = items.iter();
        while iter.next() is Some(&item) {
          width += item.single_line_width();
        }
        width
      }
    }
  }

  pub fn .format(self: Show, max_width: N32) -> String {
    match self._format(max_width, false) {
      Format::SingleLine(str) { str }
      Format::MultiLine(lines) { lines.join("\n") }
    }
  }

  enum Format {
    SingleLine(String),
    MultiLine(List[String]),
  }

  mod Format {
    pub fn .join(self: Format, separator: String) -> String {
      match self {
        SingleLine(str) { str }
        MultiLine(lines) { lines.join(separator) }
      }
    }
  }

  fn ._format(self: Show, max_width: N32, is_parent_multiline: Bool) -> Format {
    match self {
      Break { Format::SingleLine("") }
      Literal(literal) { Format::SingleLine(literal) }
      Dynamic({ single_line, multiline }) {
        if is_parent_multiline {
          multiline._format(max_width, true)
        } else {
          single_line._format(max_width, false)
        }
      }
      Indented(data) {
        if is_parent_multiline {
          match data._format(max_width - 2, is_parent_multiline) {
            Format::SingleLine(str) { Format::SingleLine("  {str}") }
            Format::MultiLine(lines) {
              Format::MultiLine(lines.map(fn(line: String) { "  {line}" }))
            }
          }
        } else {
          data._format(max_width, is_parent_multiline)
        }
      }
      Group(items) {
        let single_line_width = 0;
        let iter = items.iter();
        while iter.next() is Some(&item) {
          single_line_width += item.single_line_width();
        }
        if single_line_width <= max_width {
          Format::SingleLine(items.map(fn(item) { item._format(max_width, false) }).map(fn(format: Format) {
            format.join("")
          }).join(""))
        } else {
          let lines = [];
          let current_line = "";
          let iter = items.into_iter();
          while iter.next() is Some(item) {
            match item {
              Break {
                lines.push_back(current_line);
                current_line = "";
              }
              item {
                match item._format(max_width, false) {
                  Format::SingleLine(str) {
                    current_line ++= str;
                  }
                  Format::MultiLine(lines) {
                    let iter = lines.into_iter();
                    if iter.next() is Some(line) {
                      current_line ++= line;
                      lines.push_back(line);
                    }
                    let ~last;
                    while iter.next() is Some(line) {
                      ~last = false;
                      if ~last {
                        current_line = line;
                      } else {
                        lines.push_back(line);
                      }
                    }
                    ~last = true;
                  }
                }
              }
            }
          }
          lines.push_back(current_line);
          Format::MultiLine(lines)
        }
      }
    }
  }
}

pub impl show_nil: Show[()] {
  fn show(&()) -> Show {
    Show::Literal("()")
  }
}

pub impl show_singleton[A; Show[A]]: Show[(A,)] {
  fn show(&(a: A,)) -> Show {
    Show::Group([Show::Literal("("), a.show(), Show::Literal(",)")])
  }
}

pub impl show_pair[A, B; Show[A], Show[B]]: Show[(A, B)] {
  fn show(&(a: A, b: B)) -> Show {
    Show::tuple([a.show(), b.show()])
  }
}

pub impl show_triple[A, B, C; Show[A], Show[B], Show[C]]: Show[(A, B, C)] {
  fn show(&(a: A, b: B, c: C)) -> Show {
    Show::tuple([a.show(), b.show(), c.show()])
  }
}

pub impl show_quad[A, B, C, D; Show[A], Show[B], Show[C], Show[D]]: Show[(A, B, C, D)] {
  fn show(&(a: A, b: B, c: C, d: D)) -> Show {
    Show::tuple([a.show(), b.show(), c.show(), d.show()])
  }
}
