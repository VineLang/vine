
enum Result[T, E] {
  Ok(T),
  Err(E),
}

mod Result {
  fn map[T, U, E](self: Result[T, E], f: fn(T) -> U) -> Result[U, E] {
    match self {
      Ok(val) => Ok(f(val)),
      Err(err) => Err(err),
    }
  }

  fn as_ref[T, E](&self: &Result[T, E]) -> Result[&T, &E] {
    match &self {
      &Ok(val) => Ok(&val),
      &Err(err) => Err(&err),
    }
  }

  fn flatten[T, E](self: Result[Result[T, E], E]) -> Result[T, E] {
    match self {
      Ok(Ok(val)) => Ok(val),
      Ok(Err(err)) => Err(err),
      Err(err) => Err(err),
    }
  }

  fn and_then[T, U, E](self: Result[T, E], f: fn(T) -> Result[U, E]) -> Result[U, E] {
    self.map(f).flatten()
  }

  fn or[T, E](self: Result[T, E], default: Result[T, E]) -> Result[T, E] {
    match self {
      Err(_) => default,
      x => x,
    }
  }

  fn unwrap_or[T, E](self: Result[T, E], default: T) -> T {
    match self {
      Ok(val) => val,
      Err(_) => default,
    }
  }

  fn unwrap[T, E](self: Result[T, E], default: T) -> T {
    match self {
      Ok(val) => val,
    }
  }
}
