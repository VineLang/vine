
let io: IO = <IO>;
> F32::parse("0")
Some(0.0)

let io: IO = <IO>;
> F32::parse("-0")
Some(-0.0)

let io: IO = <IO>;
> F32::parse("42")
Some(42.0)

let io: IO = <IO>;
> F32::parse("3.14")
Some(3.1400001)

let io: IO = <IO>;
> F32::parse("-0.001")
Some(-0.00100000005)

let io: IO = <IO>;
> F32::parse(".5")
Some(0.5)

let io: IO = <IO>;
> F32::parse("5.")
Some(5.0)

let io: IO = <IO>;
> F32::parse("000123.4500")
Some(123.449997)

let io: IO = <IO>;
> F32::parse("-000.000")
Some(-0.0)

let io: IO = <IO>;
> F32::parse("+7.2")
Some(7.19999981)

let io: IO = <IO>;
> F32::parse("+.8")
Some(0.800000012)

let io: IO = <IO>;
> F32::parse("-.0")
Some(-0.0)

let io: IO = <IO>;
> F32::parse("1e3")
Some(1000.0)

let io: IO = <IO>;
> F32::parse("-2.5E-4")
Some(-2.50000012e-4)

let io: IO = <IO>;
> F32::parse(".1e+1")
Some(1.0)

let io: IO = <IO>;
> F32::parse("0.1").assume().to_bits().to_hex()
"0x3dcccccd"

let io: IO = <IO>;
> F32::parse("0.2").assume().to_bits().to_hex()
"0x3e4ccccd"

let io: IO = <IO>;
> F32::parse("0.3").assume().to_bits().to_hex()
"0x3e99999a"

let io: IO = <IO>;
> F32::parse("1e10").assume().to_bits().to_hex()
"0x501502f9"

let io: IO = <IO>;
> F32::parse("1e-10").assume().to_bits().to_hex()
"0x2edbe6ff"

let io: IO = <IO>;
> F32::parse("16777219")  // 2²⁴ + 3 → rounds to even 16777220
Some(16777220.0)

let io: IO = <IO>;
> F32::parse("1e39")
Some(inf)

let io: IO = <IO>;
> F32::parse("inf")
Some(inf)

let io: IO = <IO>;
> F32::parse("+inf")
Some(inf)

let io: IO = <IO>;
> F32::parse("-inf")
Some(-inf)

let io: IO = <IO>;
> F32::parse("nan")
Some(NaN)

let io: IO = <IO>;
> F32::parse("NaN")
Some(NaN)

let io: IO = <IO>;
> F32::parse("  9.81")
None()

let io: IO = <IO>;
> F32::parse("-2.0\n")
None()

let io: IO = <IO>;
> F32::parse("1,23")
None()

let io: IO = <IO>;
> F32::parse("12 345.6")
None()

let io: IO = <IO>;
> F32::parse("")
None()

let io: IO = <IO>;
> F32::parse(".")
None()

let io: IO = <IO>;
> F32::parse("1e")
None()

let io: IO = <IO>;
> F32::parse("e5")
None()

let io: IO = <IO>;
> F32::parse("-")
None()

let io: IO = <IO>;
> F32::parse("3.1.4")
None()

let io: IO = <IO>;
> F32::parse("6.0221408e23")
Some(6.02214064e23)

let io: IO = <IO>;
> F32::parse("3.4028234663852886e38") // f32::MAX
Some(3.40282347e38)

let io: IO = <IO>;
> F32::parse("1.1754943508222875e-38").assume().to_bits().to_hex()  // smallest normal
"0x800000"

let io: IO = <IO>;
> F32::parse("1.401298464324817e-45").assume().to_bits().to_hex()  // smallest subnormal
"0x1"

let io: IO = <IO>;
> F32::parse("1.1754942e-38").assume().to_bits().to_hex()  // largest subnormal
"0x7fffff"

let io: IO = <IO>;
> F32::parse("1.000000059604644775390625").assume().to_bits().to_hex()  // halfway between 1 and next float
"0x3f800000"

let io: IO = <IO>;
> F32::parse("1.000000059604644775390626").assume().to_bits().to_hex()
"0x3f800001"

let io: IO = <IO>;
> F32::parse("1e-46").assume().to_bits().to_hex()  // underflows to +0
"0x0"

let io: IO = <IO>;
> F32::parse("-1e-46").assume().to_bits().to_hex()  // underflows to -0
"0x80000000"

let io: IO = <IO>;
> F32::parse("3.5e38")  // overflows to +inf
Some(inf)

let io: IO = <IO>;
> F32::parse("123456789012345678901234567890")
Some(1.23456789e29)

let io: IO = <IO>;
> F32::parse("0.123456789012345678901234567890")
Some(0.123456791)

let io: IO = <IO>;
> F32::parse("1.2345678901234567890e+20")
Some(1.2345679e20)

let io: IO = <IO>;
> F32::parse("9.9999999999999999999e+38")  // should overflow to +∞
Some(inf)

let io: IO = <IO>;
> F32::parse("1.0000000000000000001e-45")
Some(1.40129846e-45)

let io: IO = <IO>;
> 

let io: IO = <IO>;
> F64::parse("0")
Some(0.0)

let io: IO = <IO>;
> F64::parse("-0")
Some(-0.0)

let io: IO = <IO>;
> F64::parse("42")
Some(42.0)

let io: IO = <IO>;
> F64::parse("3.14")
Some(3.140000000000000124)

let io: IO = <IO>;
> F64::parse("-0.001")
Some(-0.001000000000000000021)

let io: IO = <IO>;
> F64::parse(".5")
Some(0.5)

let io: IO = <IO>;
> F64::parse("5.")
Some(5.0)

let io: IO = <IO>;
> F64::parse("000123.4500")
Some(123.4500000000000028)

let io: IO = <IO>;
> F64::parse("-000.000")
Some(-0.0)

let io: IO = <IO>;
> F64::parse("+7.2")
Some(7.200000000000000178)

let io: IO = <IO>;
> F64::parse("+.8")
Some(0.8000000000000000444)

let io: IO = <IO>;
> F64::parse("-.0")
Some(-0.0)

let io: IO = <IO>;
> F64::parse("1e3")
Some(1000.0)

let io: IO = <IO>;
> F64::parse("-2.5E-4")
Some(-2.500000000000000052e-4)

let io: IO = <IO>;
> F64::parse(".1e+1")
Some(1.0)

let io: IO = <IO>;
> F64::parse("0.1").assume().to_bits().to_hex()
"0x3fb999999999999a"

let io: IO = <IO>;
> F64::parse("0.2").assume().to_bits().to_hex()
"0x3fc999999999999a"

let io: IO = <IO>;
> F64::parse("0.3").assume().to_bits().to_hex()
"0x3fd3333333333333"

let io: IO = <IO>;
> F64::parse("1e10").assume().to_bits().to_hex()
"0x4202a05f20000000"

let io: IO = <IO>;
> F64::parse("1e-10").assume().to_bits().to_hex()
"0x3ddb7cdfd9d7bdbb"

let io: IO = <IO>;
> F64::parse("9007199254740995")  // 2⁵³ + 3 → rounds to even 9007199254740996
Some(9.007199254740996e15)

let io: IO = <IO>;
> F64::parse("1e310")             // overflows to +inf in F64
Some(inf)

let io: IO = <IO>;
> F64::parse("inf")
Some(inf)

let io: IO = <IO>;
> F64::parse("+inf")
Some(inf)

let io: IO = <IO>;
> F64::parse("-inf")
Some(-inf)

let io: IO = <IO>;
> F64::parse("nan")
Some(NaN)

let io: IO = <IO>;
> F64::parse("NaN")
Some(NaN)

let io: IO = <IO>;
> F64::parse("  9.81")
None()

let io: IO = <IO>;
> F64::parse("-2.0\n")
None()

let io: IO = <IO>;
> F64::parse("1,23")
None()

let io: IO = <IO>;
> F64::parse("12 345.6")
None()

let io: IO = <IO>;
> F64::parse("")
None()

let io: IO = <IO>;
> F64::parse(".")
None()

let io: IO = <IO>;
> F64::parse("1e")
None()

let io: IO = <IO>;
> F64::parse("e5")
None()

let io: IO = <IO>;
> F64::parse("-")
None()

let io: IO = <IO>;
> F64::parse("3.1.4")
None()

let io: IO = <IO>;
> F64::parse("6.02214076e23")
Some(6.02214075999999987e23)

let io: IO = <IO>;
> F64::parse("1.7976931348623157e308") // F64::MAX
Some(1.797693134862315708e308)

let io: IO = <IO>;
> F64::parse("2.2250738585072014e-308").assume().to_bits().to_hex() // smallest normal
"0x10000000000000"

let io: IO = <IO>;
> F64::parse("4.9406564584124654e-324").assume().to_bits().to_hex() // smallest subnormal
"0x1"

let io: IO = <IO>;
> F64::parse("2.225073858507201e-308").assume().to_bits().to_hex()  // largest subnormal
"0xfffffffffffff"

let io: IO = <IO>;
> F64::parse("1.00000000000000011102230246251565404236316680908203125").assume().to_bits().to_hex()  // exactly halfway between 1 and next F64
"0x3ff0000000000000"

let io: IO = <IO>;
> F64::parse("1.00000000000000011102230246251565404236316680908203126").assume().to_bits().to_hex()  // pushes it over the tie-break
"0x3ff0000000000001"

let io: IO = <IO>;
> F64::parse("1e-325").assume().to_bits().to_hex()   // underflows to +0
"0x0"

let io: IO = <IO>;
> F64::parse("-1e-325").assume().to_bits().to_hex()  // underflows to -0
"0x8000000000000000"

let io: IO = <IO>;
> F64::parse("2e308")                                // overflows to +inf
Some(inf)

let io: IO = <IO>;
> F64::parse("123456789012345678901234567890")
Some(1.234567890123456779e29)

let io: IO = <IO>;
> F64::parse("0.123456789012345678901234567890")
Some(0.1234567890123456774)

let io: IO = <IO>;
> F64::parse("1.2345678901234567890e+20")
Some(1.23456789012345684e20)

let io: IO = <IO>;
> F64::parse("9.9999999999999999999e+308") // should overflow to +∞
Some(inf)

let io: IO = <IO>;
> F64::parse("1.0000000000000000001e-324")
Some(0.0)

let io: IO = <IO>;
