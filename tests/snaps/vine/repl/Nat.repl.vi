
let io: IO = <IO>;
> 

let io: IO = <IO>;
> use std::debug::Show;

let io: IO = <IO>;
> 0[Nat]
0

let io: IO = <IO>;
> 123[Nat]
123

let io: IO = <IO>;
> 

let io: IO = <IO>;
> 0 as Nat
0

let io: IO = <IO>;
> 123 as Nat
123

let io: IO = <IO>;
> Nat::parse("123456789012345678901234567890")
Some(123456789012345678901234567890)

let io: IO = <IO>;
> Nat::parse("123abc")
None

let io: IO = <IO>;
> Nat::parse("123456789_123456789")
Some(123456789123456789)

let io: IO = <IO>;
> 

let io: IO = <IO>;
> 42[Nat] + 4[Nat]
46

let io: IO = <IO>;
> 1111111111111111111111111111[Nat] + 55555555555555555555[Nat]
1111111166666666666666666666

let io: IO = <IO>;
> Nat::from_parts([N32::maximum, N32::maximum, N32::maximum, N32::maximum]) + Nat::from_parts([N32::maximum, N32::maximum])
340282366920938463481821351505477763070

let io: IO = <IO>;
> 18446744073709551615[Nat] + 18446744073709551617[Nat]
36893488147419103232

let io: IO = <IO>;
> 

let io: IO = <IO>;
> 100[Nat] - 42[Nat]
58

let io: IO = <IO>;
> 100[Nat] - 0[Nat]
100

let io: IO = <IO>;
> 0[Nat] - 100[Nat]
0

let io: IO = <IO>;
> 1111111111111111111111111111[Nat] - 1111111111111111111111111111[Nat]
0

let io: IO = <IO>;
> 6666666666666666666666666666[Nat] - 2222222222222[Nat]
6666666666666664444444444444

let io: IO = <IO>;
> 

let io: IO = <IO>;
> 0[Nat].div_rem_n32(1)
(0, 0)

let io: IO = <IO>;
> 0[Nat].div_rem_n32(123_456_789)
(0, 0)

let io: IO = <IO>;
> 5[Nat].div_rem_n32(1)
(5, 0)

let io: IO = <IO>;
> 5[Nat].div_rem_n32(2)
(2, 1)

let io: IO = <IO>;
> 5[Nat].div_rem_n32(10)
(0, 5)

let io: IO = <IO>;
> 123[Nat].div_rem_n32(10)
(12, 3)

let io: IO = <IO>;
> 123[Nat].div_rem_n32(124)
(0, 123)

let io: IO = <IO>;
> 124[Nat].div_rem_n32(124)
(1, 0)

let io: IO = <IO>;
> 1[Nat].div_rem_n32(10)
(0, 1)

let io: IO = <IO>;
> 1[Nat].div_rem_n32(4_294_967_295)
(0, 1)

let io: IO = <IO>;
> 4_294_967_296[Nat].div_rem_n32(2)
(2147483648, 0)

let io: IO = <IO>;
> 4_294_967_297[Nat].div_rem_n32(2)
(2147483648, 1)

let io: IO = <IO>;
> 4_294_967_296[Nat].div_rem_n32(4_294_967_295)
(1, 1)

let io: IO = <IO>;
> 4_294_967_301[Nat].div_rem_n32(4_294_967_295)
(1, 6)

let io: IO = <IO>;
> 18_446_744_073_709_551_615[Nat].div_rem_n32(10)
(1844674407370955161, 5)

let io: IO = <IO>;
> 18_446_744_073_709_551_615[Nat].div_rem_n32(4_294_967_295)
(4294967297, 0)

let io: IO = <IO>;
> 12_345_678_901_234_567_890[Nat].div_rem_n32(10)
(1234567890123456789, 0)

let io: IO = <IO>;
> 98_765_432_109_876_543_210[Nat].div_rem_n32(4_000_000_000)
(24691358027, 1876543210)

let io: IO = <IO>;
> 1_000_000_000_000_000_000[Nat].div_rem_n32(3)
(333333333333333333, 1)

let io: IO = <IO>;
> 

let io: IO = <IO>;
> 0[Nat].div_rem(123456789[Nat])
(0, 0)

let io: IO = <IO>;
> 42[Nat].div_rem(100[Nat])
(0, 42)

let io: IO = <IO>;
> 555555555555555555555555123456789[Nat].div_rem(1000000000[Nat]) // single limb short path
(555555555555555555555555, 123456789)

let io: IO = <IO>;
> 76350665206209593115122189013[Nat].div_rem(121036734064[Nat]) // correction used once, no add-back
(630805728497581787, 94913296645)

let io: IO = <IO>;
> (1[Nat] << 100).div_rem(1[Nat] << 63) // no normalization
(137438953472, 0)

let io: IO = <IO>;
> 3489603096812281287860038236174996985899336074804695101976560109467622092404[Nat].div_rem(5173245046327638136212214[Nat]) // correction loop is done twice
(674548192780751096705739873430228829726978313619084, 3323460435037833837800428)

let io: IO = <IO>;
> Nat::from_parts([0, 0, 1 << 31, N32::maximum >> 1]).div_rem(Nat::from_parts([1, 0, 1 << 31])) // requires add-back because prod is bigger than the remainder
(4294967294, 39614081257132168792477007874)

let io: IO = <IO>;
> 

let io: IO = <IO>;
> 1[Nat] << 1
2

let io: IO = <IO>;
> 10[Nat] << 3
80

let io: IO = <IO>;
> 123456789123456789 << 0
error input:1:1 - invalid numeric literal

let io: IO = <IO>;
> 0x80000000[Nat] << 1
4294967296

let io: IO = <IO>;
> 0xffffffff[Nat] << 1
8589934590

let io: IO = <IO>;
> (Nat::from_parts([0xffffffff, 0x80000000]) << 2).to_parts()
[4294967292, 3, 2]

let io: IO = <IO>;
> (Nat::from_parts([1, 2, 3, 4]) << 64).to_parts()
[0, 0, 1, 2, 3, 4]

let io: IO = <IO>;
> (Nat::from_parts([1, 2, 3, 4]) << 65).to_parts()
[0, 0, 2, 4, 6, 8]

let io: IO = <IO>;
> 

let io: IO = <IO>;
> 1[Nat] >> 1
0

let io: IO = <IO>;
> 2[Nat] >> 1
1

let io: IO = <IO>;
> 0x80000000[Nat] >> 3
268435456

let io: IO = <IO>;
> 123456789123456789 >> 0
error input:1:1 - invalid numeric literal

let io: IO = <IO>;
> (Nat::from_parts([0x00010000, 0xffffffff]) >> 4).to_parts()
[4026535936, 268435455]

let io: IO = <IO>;
> 18446744073709551616 >> 32
error input:1:1 - invalid numeric literal

let io: IO = <IO>;
> (Nat::from_parts([1, 2, 3, 1]) >> 63).to_parts()
[6, 2]

let io: IO = <IO>;
> (Nat::from_parts([1, 2, 3, 1]) >> 64).to_parts()
[3, 1]

let io: IO = <IO>;
> (Nat::from_parts([1, 2, 3, 1]) >> 65).to_parts()
[2147483649]

let io: IO = <IO>;
> 

let io: IO = <IO>;
> Nat::from_parts([1, 1]) * 1[Nat]
4294967297

let io: IO = <IO>;
> 4294967298[Nat] * 4294967295
18446744078004518910

let io: IO = <IO>;
> 4294967296[Nat] * 4294967296[Nat]
18446744073709551616

let io: IO = <IO>;
> 

let io: IO = <IO>;
> Nat::from_parts([2]) < Nat::from_parts([1, 2])
true

let io: IO = <IO>;
> Nat::from_parts([2]) <= Nat::from_parts([1, 2])
true

let io: IO = <IO>;
> 

let io: IO = <IO>;
> 0[Nat].gcd(123456789123456789123456789123456789[Nat])
123456789123456789123456789123456789

let io: IO = <IO>;
> 123456789123456789123456789123456789[Nat].gcd(0[Nat])
123456789123456789123456789123456789

let io: IO = <IO>;
> 42[Nat].gcd(42[Nat])
42

let io: IO = <IO>;
> 48[Nat].gcd(18[Nat])
6

let io: IO = <IO>;
> 35[Nat].gcd(64[Nat])
1

let io: IO = <IO>;
> (1[Nat] << 200).gcd(1[Nat] << 150)
1427247692705959881058285969449495136382746624

let io: IO = <IO>;
> ((1[Nat] << 200) * 45[Nat]).gcd((1[Nat] << 150) * 75[Nat])
21408715390589398215874289541742427045741199360

let io: IO = <IO>;
> ((1[Nat] << 200) + 6[Nat]).gcd((1[Nat] << 180) + 6[Nat])
2

let io: IO = <IO>;
> ((1[Nat] << 128) - 1[Nat]).gcd((1[Nat] << 64) - 1[Nat])
18446744073709551615

let io: IO = <IO>;
