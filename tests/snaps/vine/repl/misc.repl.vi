
let io: IO = <IO>;
> use #root::data::Array;

let io: IO = <IO>;
> fn _foo() {}

let io: IO = <IO>;
> 1.as[String]
"1"

let io: IO = <IO>;
> 1.0.as[String]
"1.0"

let io: IO = <IO>;
> ((1,2),(3,4)).0
(1, 2)

let io: IO = <IO>;
> ((1,2),(3,4)).0.0
1

let io: IO = <IO>;
> ((1,2),(3,4)).0.0.as[String]
"1"

let io: IO = <IO>;
> ((1,2),(3,4)).1.1.as[String]
"4"

let io: IO = <IO>;
> "abc" ++ 123
error input:1:1 - cannot find impl of trait `Concat[String, N32, ?96]`
error input:1:1 - search limit reached when finding impl of trait `Drop[?93]`

let io: IO = <IO>;
> [true, false].show().as[String]
"[true, false]"

let io: IO = <IO>;
> [1,2,3,4].split_at(2)
([1, 2], [3, 4])

let io: IO = <IO>;
> [1,2,3,4].split_at(0)
([], [1, 2, 3, 4])

let io: IO = <IO>;
> [1,2,3,4].split_at(6)
([1, 2, 3, 4], [])

let io: IO = <IO>;
> [1,2,3,4].reversed()
[4, 3, 2, 1]

let io: IO = <IO>;
> [1,2,3,4].filter(fn* (&x: &N32) { x % 2 == 0 })
[2, 4]

let io: IO = <IO>;
> ["aaa", "bbb", "ccc"].filter(fn* (&x: &String) { x.len() > 2 })
["aaa", "bbb", "ccc"]

let io: IO = <IO>;
> List::empty[Bool].filter(fn* (&x) { x })
[]

let io: IO = <IO>;
> let l = [+1,+2,-13,+4];

let io: IO = <IO>;
let l: List[I32] = [+1, +2, -13, +4];
> l.find(fn* (&x: &I32) { x == +7 })
None()

let io: IO = <IO>;
let l: List[I32] = [+1, +2, -13, +4];
> *l.find(fn* (&x: &I32) { x < +0 }).assume() -= +5;

let io: IO = <IO>;
let l: List[I32] = [+1, +2, -18, +4];
> l.contains(&+1)
true

let io: IO = <IO>;
let l: List[I32] = [+1, +2, -18, +4];
> l.contains(&+4)
true

let io: IO = <IO>;
let l: List[I32] = [+1, +2, -18, +4];
> l.contains(&+7)
false

let io: IO = <IO>;
let l: List[I32] = [+1, +2, -18, +4];
> /clear l

let io: IO = <IO>;
> let a = Array::from_fn(5, do { let x = 0; (fn* () { let n = x; x += 1; n }) });

let io: IO = <IO>;
let a: Array[N32] = Array([0, 1, 2, 3, 4]);
> a.for_each(fn* (v: N32) { io.println("{v}")})
0
1
2
3
4

let io: IO = <IO>;
let a: Array[N32] = Array([0, 1, 2, 3, 4]);
> 0 - a.fold_front(0, fn* (a: N32, b: N32) { a - b })
10

let io: IO = <IO>;
let a: Array[N32] = Array([0, 1, 2, 3, 4]);
> 0 - a.fold_back(5, fn* (a: N32, b: N32) { a - b })
5

let io: IO = <IO>;
let a: Array[N32] = Array([0, 1, 2, 3, 4]);
> a.get(3)
Some(3)

let io: IO = <IO>;
let a: Array[N32] = Array([0, 1, 2, 3, 4]);
> a.at(5)
None()

let io: IO = <IO>;
let a: Array[N32] = Array([0, 1, 2, 3, 4]);
> /clear a

let io: IO = <IO>;
> [1,2,3,4,5,6,7,8,9].as[Array].reversed().as[List]
[9, 8, 7, 6, 5, 4, 3, 2, 1]

let io: IO = <IO>;
> List::new(10, "")
["", "", "", "", "", "", "", "", "", ""]

let io: IO = <IO>;
> 2 ** 10
1024

let io: IO = <IO>;
> 4 + 4 ** 3 ** 2 / 2
131076

let io: IO = <IO>;
> 12.34 ** -5
3.49481479e-6

let io: IO = <IO>;
> 12.34 ** +0
1.0

let io: IO = <IO>;
> 12.34 ** +3
1.87908093e3

let io: IO = <IO>;
> 1024.log(2)
10

let io: IO = <IO>;
> 1000.log(2)
9

let io: IO = <IO>;
> 1025.log(2)
10

let io: IO = <IO>;
> 10.max(100)
100

let io: IO = <IO>;
> 10.min(100)
10

let io: IO = <IO>;
> 10.diff(100)
90

let io: IO = <IO>;
> 123.gcd(456)
3

let io: IO = <IO>;
> 99.sqrt()
9

let io: IO = <IO>;
> 100.sqrt()
10

let io: IO = <IO>;
> 101.sqrt()
10

let io: IO = <IO>;
> (N64::parse("1234567890123456789000").assume() + N64::parse("46").assume()) as String
"17082781258626382390"

let io: IO = <IO>;
> N64::parse("")
None()

let io: IO = <IO>;
> N64::parse("one")
None()

let io: IO = <IO>;
> N64::parse("1.0")
None()

let io: IO = <IO>;
> (3[N64] ** 33) as String
"5559060566555523"

let io: IO = <IO>;
> (3[N64] ** 33).log_n32(3)
32

let io: IO = <IO>;
> ((3[N64] ** 33) - 1[N64]).log_n32(3)
32

let io: IO = <IO>;
> ((3[N64] ** 33) + 1[N64]).log_n32(3)
32

let io: IO = <IO>;
> "1,2,3,4".split(",")
["1", "2", "3", "4"]

let io: IO = <IO>;
> "      1 2  3 4   ".split_trim(" ")
["1", "2", "", "3", "4"]

let io: IO = <IO>;
> "1,2, 3,4, 5,6".split_once(", ")
("1,2", Some("3,4, 5,6"))

let io: IO = <IO>;
> 123.show(2)
error input:1:1 - function expects 1 argument; was passed 2

let io: IO = <IO>;
> 123.to_binary()
"0b1111011"

let io: IO = <IO>;
> 123.to_hex()
"0x7b"

let io: IO = <IO>;
> let x = [[1]];

let io: IO = <IO>;
let x: List[List[N32]] = [[1]];
> (*x.at(0).assume()).get(0)
Some(1)

let io: IO = <IO>;
let x: List[List[N32]] = [[1]];
> x.at(0).assume().*.at(0).assume().* = 2

let io: IO = <IO>;
let x: List[List[N32]] = [[2]];
> ~x.at(0).assume().*.at(0).assume().*.~
2

let io: IO = <IO>;
let x: List[List[N32]] = [[2]];
> x.at(3)
None()

let io: IO = <IO>;
let x: List[List[N32]] = [[2]];
> /clear x

let io: IO = <IO>;
> let _: { a: N32, b: N32 } = { a: 1 }
error input:1:29 - expected type `{ a: N32, b: N32 }`; found `{ a: N32 }`

let io: IO = <IO>;
> do { let x; x = (x, x); }
error input:1:17 - expected type `?1546`; found `(?1546, ?1546)`
error input:1:10 - search limit reached when finding flex of type `?1546`
error input:1:10 - cannot drop `?1546`
error input:1:10 - variable of type `?1546` read whilst uninitialized
error input:1:10 - cannot fork `?1546`

let io: IO = <IO>;
> let (a: N32, b: N32);

let io: IO = <IO>;
let a: N32;
let b: N32;
> let x: (~N32, ~N32) = ~(a, b);

let io: IO = <IO>;
let a: N32 = <N32>;
let b: N32 = <N32>;
let x: (~N32, ~N32) = <(~N32, ~N32)>;
> let y: { a: ~N32, b: ~N32 } = ~{ a, b };

let io: IO = <IO>;
let a: N32 = <N32>;
let b: N32 = <N32>;
let x: (~N32, ~N32) = <(~N32, ~N32)>;
let y: { a: ~N32, b: ~N32 } = <{ a: ~N32, b: ~N32 }>;
> ~x = (1, 2);

let io: IO = <IO>;
let a: N32 = <N32>;
let b: N32 = <N32>;
let x: (~N32, ~N32);
let y: { a: ~N32, b: ~N32 } = <{ a: ~N32, b: ~N32 }>;
> ~y = { a: 4, b: 6 }

let io: IO = <IO>;
let a: N32 = 4;
let b: N32 = 6;
let x: (~N32, ~N32);
let y: { a: ~N32, b: ~N32 };
> /clear a b x y

let io: IO = <IO>;
> let x; x.a; x.a
error input:1:5 - cannot infer type
error input:1:8 - search limit reached when finding flex of type `?1674`
error input:1:8 - search limit reached when finding impl of trait `Drop[?1674]`
error input:1:13 - search limit reached when finding flex of type `?1674`
error input:1:1 - search limit reached when finding impl of trait `Drop[?1674]`
error input:1:5 - search limit reached when finding flex of type `?1674`
error input:1:5 - variable of type `?1674` read whilst uninitialized

let io: IO = <IO>;
> Ok(true).try
error input:1:1 - no function to return from

let io: IO = <IO>;
> fn foo() -> N32 { Ok(123).try }
error input:1:19 - cannot try `Result[N32, ?2]` in a function returning `N32`
error input:1:19 - search limit reached when finding flex of type `?2`
error input:1:19 - search limit reached when finding flex of type `Result[N32, ?2]`
error input:1:19 - search limit reached when finding flex of type `?2`

let io: IO = <IO>;
> fn foo() -> Result[N32, String] { Ok(123).try }
error input:1:35 - expected type `Result[N32, String]`; found `N32`

let io: IO = <IO>;
> fn foo() -> Result[N32, String] { Err(123).try }
error input:1:35 - cannot try `Result[?3, N32]` in a function returning `Result[N32, String]`

let io: IO = <IO>;
> let x = (1, 2.0, ([Some(Ok(true)), Some(Err("hi")), None()], [1, 2, 3] as Array), ((), ((),), ((), ())));

let io: IO = <IO>;
let x: (N32, F32, (List[Option[Result[Bool, String]]], Array[N32]), ((), ((),), ((), ()))) = (
  1,
  2.0,
  ([Some(Ok(true)), Some(Err("hi")), None()], Array([1, 2, 3])),
  ((), ((),), ((), ())),
);
> x.fork()
(
  1,
  2.0,
  ([Some(Ok(true)), Some(Err("hi")), None()], Array([1, 2, 3])),
  ((), ((),), ((), ())),
)

let io: IO = <IO>;
let x: (N32, F32, (List[Option[Result[Bool, String]]], Array[N32]), ((), ((),), ((), ()))) = (
  1,
  2.0,
  ([Some(Ok(true)), Some(Err("hi")), None()], Array([1, 2, 3])),
  ((), ((),), ((), ())),
);
> x.drop()

let io: IO = <IO>;
let x: (N32, F32, (List[Option[Result[Bool, String]]], Array[N32]), ((), ((),), ((), ()))) = (
  1,
  2.0,
  ([Some(Ok(true)), Some(Err("hi")), None()], Array([1, 2, 3])),
  ((), ((),), ((), ())),
);
> /clear x

let io: IO = <IO>;
> (-8765.123e-8).abs()
8.76512277e-5

let io: IO = <IO>;
> 8765.123e-8.abs()
8.76512277e-5

let io: IO = <IO>;
> F32::inf.abs()
inf

let io: IO = <IO>;
> F32::neg_inf.abs()
inf

let io: IO = <IO>;
> F32::nan.abs()
NaN

let io: IO = <IO>;
> do { match Some(1) { Some(_) {} } }
error input:1:6 - match arms do not cover all possible cases

let io: IO = <IO>;
> let x = 1

let io: IO = <IO>;
let x: N32 = 1;
> let x = x + 1

let io: IO = <IO>;
let x: N32 = 2;
> /clear x

let io: IO = <IO>;
> match (Some(1), 2) { (None(), _) { None() } x { Some(x) } }
Some(Some(1), 2)

let io: IO = <IO>;
> 1+2
3

let io: IO = <IO>;
> for i in 0..10 { if i % 2 == 1 { continue } io.println("{i}") }
0
2
4
6
8

let io: IO = <IO>;
> #root::IO::println(&io, "hi")
hi

let io: IO = <IO>;
> Some(123) is None
error input:1:14 - expected content subpattern

let io: IO = <IO>;
> do { let list = [1, 3]; list.insert(1, 2); list.insert(100, 4); list }
[1, 2, 3, 4]

let io: IO = <IO>;
