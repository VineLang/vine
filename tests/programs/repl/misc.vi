use std::{data::Array, numeric::N64};
(1, _)
fn _foo() {}
1.as[String]
1.0.as[String]
((1,2),(3,4)).0
((1,2),(3,4)).0.0
((1,2),(3,4)).0.0.as[String]
((1,2),(3,4)).1.1.as[String]
"abc" ++ 123
([true, false]; _).show().as[String]
[1,2,3,4].slice(2)
[1,2,3,4].split_at(2)
[1,2,3,4].split_at(0)
[1,2,3,4].split_at(6)
[1,2,3,4].reversed()
let a = Array::from_fn(5, &(0; _), fn(&x: &N32) { let n = x; x += 1; n });
a.for_each(&io, fn(&io: &IO, v: N32) { io.println("{v}")})
-a.fold_front(0, fn(a: N32, b: N32) { a - b })
-a.fold_back(5, fn(a: N32, b: N32) { a - b })
move a
[1,2,3,4,5,6,7,8,9].as[Array].reversed().as[List]
List::new(100, "")
2 ** 10
4 + 4 ** 3 ** 2 / 2
12.34 ** -5
12.34 ** +0
12.34 ** +3
1024.log(2)
1000.log(2)
1025.log(2)
10.max(100)
10.min(100)
10.diff(100)
123.gcd(456)
99.sqrt()
100.sqrt()
101.sqrt()
(N64::parse("1234567890123456789000").unwrap() + N64::parse("46").unwrap()) as String
N64::parse("")
N64::parse("one")
N64::parse("1.0")
(3 as N64 ** 33) as String
(3 as N64 ** 33).log_n32(3)
((3 as N64 ** 33) - 1 as N64).log_n32(3)
((3 as N64 ** 33) + 1 as N64).log_n32(3)
"1,2,3,4".split(",")
"      1 2  3 4   ".split_trim(" ")
"1,2, 3,4, 5,6".split_once(", ")
123.show(2)
let x = [[1]];
x.get(0).*.get(0).*
x.get(0).*.get(0).* = 2
~x.get(0).*.get(0).*.~
move x
let _: { a: N32, b: N32 } = { a: 1 }
do { let x; x = (x, x); }
let (a: N32, b: N32);
let x: (~N32, ~N32) = ~(a, b);
let x: { a: ~N32, b: ~N32 } = ~{ a, b };
move (a, b, x)
let x
x.a; x.a
Ok(true)?
fn foo() -> N32 { Ok(123)? }
fn foo() -> Result[N32, String] { Ok(123)? }
fn foo() -> Result[N32, String] { Err(123)? }
let x = (1, 2.0, [Some(Ok(true)), Some(Err("hi")), None], ((), ((),), ((), ())));
x.fork()
x.drop(); let x;
