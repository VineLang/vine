
// ~1 error per line
type Foo[X] = (X, foo, _);
fn foo(x, y: Foo) {}
const bar: _ = return;
pub fn main[T, U](io: IO) {
  let x: N32 = 0.0;
  let x: F32 = 0;
  let x: (N32, N32) = (1, 2) + 0.0;
  let (a, b) = 0;
  let x; x + 1;
  1();
  let x = 3; 2 + ~x;
  x.noop();
  if 0.0 { 0 } else { "" };
  main(1, 2, 3);
  0 < 0.0 < 0 < 0 < 0.0;
  let Thing(x) = Foo(1);
  let foo: foo = foo;
  let x: T = 0;
  let x: U = x;
  let Ay::Yay = 0;
  (loop { break "x" } + 1);
  let &x: N32 = loop {};
  continue;
  break;
  return 0.0;
  let x = 1; ~x + ~x;
  x += 1.0;
  x.parse();
  123
}

// correct utilities
enum Ay { Yay, Nay }
struct Thing(N32, N32);
fn rec[T](x: T) -> T { rec(x) }
fn noop() {}
