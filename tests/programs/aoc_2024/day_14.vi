
use std::data::Array;

const width: N32 = 11;
const height: N32 = 7;
// const width: N32 = 101;
// const height: N32 = 103;

pub fn main(&io: &IO) {
  let robots = [];
  while io.read_line() is Some(line) && line.len() != 0 {
    let (_, r) = line.split_once("p=");
    let (px, r) = r.unwrap().split_once(",");
    let (py, r) = r.unwrap().split_once(" v=");
    let (vx, r) = r.unwrap().split_once(",");
    let vy = r.unwrap();
    let px = N32::parse(px).unwrap();
    let py = N32::parse(py).unwrap();
    dyn fn parse_signed(x: String, m: N32) {
      if *x.chars.get(0) == '-' {
        x.chars.pop_front();
        m - N32::parse(x).unwrap()
      } else {
        N32::parse(x).unwrap()
      }
    }
    let vx = parse_signed(vx, width);
    let vy = parse_signed(vy, height);

    robots.push_back((px, py, vx, vy));
  }

  let a = 0;
  let b = 0;
  let c = 0;
  let d = 0;
  let iter = robots.into_iter();
  while iter.next() is Some((px, py, vx, vy)) {
    let x = (px + vx * 100) % width;
    let y = (py + vy * 100) % height;
    if x < width / 2 {
      if y < height / 2 {
        a += 1;
      } else if y > height / 2 {
        b += 1;
      }
    } else if x > width / 2 {
      if y < height / 2 {
        c += 1;
      } else if y > height / 2 {
        d += 1;
      }
    }
  }

  let part1 = a * b * c * d;

  io.println("Part 1: {part1}");

  let i = 0;
  while io.read_line() is Some(line) {
    if N32::parse(line) is Some(n) {
      i = n;
    }
    io.println("\x1b[2J\x1b[H");
    let grid = Array::new(height, Array::new(width, '.'));
    let iter = robots.into_iter();
    while iter.next() is Some((px, py, vx, vy)) {
      let x = (px + vx * i) % width;
      let y = (py + vy * i) % height;
      *(*grid.get(y)).get(x) = '#';
    }
    let lines = grid.to_list();
    while lines.pop_front() is Some(line) {
      io.println(String({ chars: line.to_list() }));
    }
    io.println(i.to_string());
    i += 1;
  }

  let part2 = 0;

  io.println("Part 2: {part2}");
}
