
use #root::data::Array;

const width: N32 = 11;
const height: N32 = 7;
// const width: N32 = 101;
// const height: N32 = 103;

pub fn main(&io: &IO) {
  let robots = [];
  while io.read_line() is Some(line) and line.len() != 0 {
    let (_, r) = line.split_once("p=");
    let (px, r) = r.assume().split_once(",");
    let (py, r) = r.assume().split_once(" v=");
    let (vx, r) = r.assume().split_once(",");
    let vy = r.assume();
    let px = N32::parse(px).assume();
    let py = N32::parse(py).assume();
    let fn parse_signed(x: String, m: N32) {
      if x!.get(0).assume() == '-' {
        x!.pop_front();
        m - N32::parse(x).assume()
      } else {
        N32::parse(x).assume()
      }
    }
    let vx = parse_signed(vx, width);
    let vy = parse_signed(vy, height);

    robots.push_back((px, py, vx, vy));
  }

  let a = 0;
  let b = 0;
  let c = 0;
  let d = 0;
  for (px, py, vx, vy) in robots.iter() {
    let x = (px + vx * 100) % width;
    let y = (py + vy * 100) % height;
    when {
      x < width / 2 {
        when {
          y < height / 2 {
            a += 1;
          }
          y > height / 2 {
            b += 1;
          }
        }
      }
      x > width / 2 {
        when {
          y < height / 2 {
            c += 1;
          }
          y > height / 2 {
            d += 1;
          }
        }
      }
    }
  }

  let part1 = a * b * c * d;

  io.println("Part 1: {part1}");

  let i = 0;
  while io.read_line() is Some(line) {
    if N32::parse(line) is Some(n) {
      i = n;
    }
    io.println("\x1b[2J\x1b[H");
    let grid = Array::new(height, Array::new(width, '.'));
    for (px, py, vx, vy) in robots.iter() {
      let x = (px + vx * i) % width;
      let y = (py + vy * i) % height;
      *(*grid.at(y).assume()).at(x).assume() = '#';
    }
    for line in grid.as[List].iter() {
      io.println(line as List as String);
    }
    io.println("{i}");
    i += 1;
  }

  let part2 = 0;

  io.println("Part 2: {part2}");
}
