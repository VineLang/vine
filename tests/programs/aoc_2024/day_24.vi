
use #root::{data::Map, util::{erase, eraser, move}};

pub fn main(&io: &IO) {
  let map = Map::empty[String, _];

  while io.read_line() is Some(line) and line.len() != 0 {
    let (name, value) = line.split_once(": ");
    let value = value.assume()!.get(0).assume() == '1';
    safe erase(map.insert(name, Wire::input(value)));
  }

  let fn at_wire(wire) {
    map.at_or_insert[; _, _, safe erase](wire, Wire::new())
  }

  while io.read_line() is Some(line) {
    let pieces = line.split(" ");
    let wire_a = safe move(pieces.at(0).assume());
    let wire_b = safe move(pieces.at(2).assume());
    let wire_out = safe move(pieces.at(4).assume());
    let a = (*at_wire(wire_a)).get();
    let b = (*at_wire(wire_b)).get();
    let op = (*pieces.at(1).assume())!.get(0).assume();
    let out = when {
      op == 'A' { a & b }
      op == 'O' { a | b }
      _ { a ^ b }
    };
    (*at_wire(wire_out)).set(out);
  }

  let part1 = 0[N64];
  let &~n = &part1;
  let i = 0;
  loop {
    let wire = ['z', '0' + i / 10, '0' + i % 10] as String;
    if map.at(&wire) is Some(&wire) {
      let bit = if wire.get() {
        1[N64]
      } else {
        0[N64]
      };
      ~n ~= (~n << 1) | bit;
      i += 1;
      continue;
    }
  }

  io.println("Part 1: {part1}");

  safe erase(map);
}

struct Wire(~Bool, Bool);

mod Wire {
  pub fn new() -> Wire {
    let x;
    Wire(~x, x)
  }

  pub fn .input(value: Bool) -> Wire {
    Wire(safe eraser, value)
  }

  pub fn .get(&Wire(_, value)) -> Bool {
    value
  }

  pub fn .set(&Wire(~out, _), value: Bool) {
    out = value;
  }
}
