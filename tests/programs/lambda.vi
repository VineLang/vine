
use #root::data::Map;

pub fn main(&io: &IO) {
  while io.prompt("> ") is Some(line) {
    match Term::parse(line) {
      Ok(term) { io.println(term.print_normal(0)) }
      Err(err) { io.println("error: {err}") }
    }
  }
}

pub enum Term {
  Lambda(List[~Term], Term),
  Apply(Term, Term),
  Spine(String, List[Term]),
}

pub mod Term {
  fn .whnf(term: Term) -> Term {
    match term {
      Term::Apply(fun, arg) {
        fun = fun.whnf();
        match fun {
          Term::Lambda(param, body) {
            bind(param, arg);
            body.whnf()
          }
          Term::Spine(var, args) { Term::Spine(var, args ++ [arg]) }
          Term::Apply(app) { debug::error_with("unreachable", (app, arg)) }
        }
      }
      term { term }
    }
  }

  pub fn .print_normal(term: Term, depth: N32) -> String {
    match term.whnf() {
      Term::Lambda(param, body) {
        let var = new_var(depth);
        bind(param, Term::Spine(var, []));
        "λ{var}. {body.print_normal(depth + 1)}"
      }
      Term::Spine(var, args) {
        if args.len() == 0 {
          unsafe::erase(args);
          var
        } else {
          let out = "({var}";
          for arg in args.iter() {
            out ++= " " ++ arg.print_normal(depth);
          }
          out ++ ")"
        }
      }
      Term::Apply(app) { debug::error_with("unreachable", app) }
    }
  }

  fn bind(uses: List[~Term], term: Term) {
    for ~out in uses.iter() {
      out = unsafe::duplicate(&term);
    }
    unsafe::erase(term);
  }

  pub fn parse(source: String) -> Result[Term, String] {
    let err;
    let parser = Parser({ scope: Map::empty, chars: source as List, error: ~err });
    let term = parser.parse_term();
    ~parser.error = None();
    unsafe::erase(parser);
    if err is Some(error) {
      unsafe::erase(term);
      Err(error)
    } else {
      Ok(term)
    }
  }
}

struct Parser(pub {
  scope: Map[String, List[List[~Term]]],
  chars: List[Char],
  error: ~Option[String],
});

mod Parser {
  pub fn .parse_term(&self: &Parser) -> Term {
    let term = self.parse_atom();
    self.skip_ws();
    while self.chars.len() != 0 and self.chars.get(0).assume() != ')' {
      term = Term::Apply(term, self.parse_atom());
      self.skip_ws();
    }
    term
  }

  fn .parse_atom(&self: &Parser) -> Term {
    self.skip_ws();
    if self.chars.len() == 0 {
      return self.error("expected term");
    }
    let char = self.chars.get(0).assume();
    when {
      char == '\\' or char == 'λ' {
        self.chars.pop_front();
        self.skip_ws();
        let var = self.parse_var();
        self.expect_char('.');
        self.scope.at_or_insert[; _, _, unsafe::erase](var, []).*.push_front([]);
        let body = self.parse_atom();
        let uses = self.scope.at(&var).assume().*.pop_front().assume();
        Term::Lambda(uses, body)
      }
      char == '(' {
        self.chars.pop_front();
        let term = self.parse_term();
        self.expect_char(')');
        term
      }
      _ {
        let var = self.parse_var();
        if self.scope.at(&var) is Some(&binds) and binds.len() != 0 {
          let term;
          binds.at(0).assume().*.push_back(~term);
          term
        } else {
          self.error("unbound variable `{var}`")
        }
      }
    }
  }

  fn .parse_var(&self: &Parser) -> String {
    let chars = [];
    while self.chars.len() != 0 and self.chars.get(0) is Some(char) and char.is_alphanumeric() {
      self.chars.pop_front();
      chars.push_back(char);
    }
    if chars.len() == 0 {
      return self.error("expected variable");
    }
    String(chars)
  }

  fn .expect_char(&self: &Parser, char: Char) {
    self.skip_ws();
    if !(self.chars.pop_front() is Some(c) and c == char) {
      return self.error("expected `{String([char])}`");
    }
  }

  fn .skip_ws(&self: &Parser) {
    while self.chars.len() != 0 and self.chars.get(0).assume().is_whitespace() {
      self.chars.pop_front();
    }
  }

  fn .error[T](&self: &Parser, error: String) -> T {
    ~self.error = Some(error);
    unsafe::erase(&self);
    unsafe::eraser
  }
}

fn new_var(n: N32) -> String {
  let chars = [];
  n += 1;
  while n > 0 {
    n -= 1;
    chars.push_front('a' + (n % 26));
    n /= 26;
  }
  String(chars)
}
